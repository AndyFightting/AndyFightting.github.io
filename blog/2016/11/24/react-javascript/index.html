
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>React 基础知识 - 阿贵</title>
  <meta name="author" content="guimingsu">

  
  <meta name="description" content="React 基础知识 Nov 24th, 2016 2:31 pm React 的核心思想是：封装组件! 封装组件 !封装组件! 重要的事说三遍。React 应用都是构建在组件之上，各个组件维护自己的状态和 UI，当状态变更，自动重新渲染整个组件。组件的第一个字母必须大写, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andyfightting.github.io/blog/2016/11/24/react-javascript/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="阿贵" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">  -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

<script>
  function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
    });
  }
  $(document).bind('DOMNodeInserted', function(event) {
    addBlankTargetForLinks();
  });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">阿贵</a></h1>
  
    <h2>All growth is a leap in the dark.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andyfightting.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">React 基础知识</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-24T14:31:57+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:31 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h4>React 的核心思想是：封装组件! 封装组件 !封装组件! 重要的事说三遍。React 应用都是构建在组件之上，各个组件维护自己的状态和 UI，当状态变更，自动重新渲染整个组件。组件的第一个字母必须大写,组件只能包含一个顶层标签。</h4>

<h4>Declarative</h4>

<p><a href="https://facebook.github.io/react/">React</a> 可以很好的创建交互式组件，设计不同状态下的组件，并且React可以根据组件的不同参数高效的刷新渲染。这样的组件可以让你的代码更加的可预测并且更方便调试。</p>

<h4>Component-Based</h4>

<p>基于组件，封装一个组件，让它们管理自己的状态，然后用它们去组成更加复杂的UI。由于组件的逻辑是写在JavaScript里的而不是模板里，这样你可以很轻松的让它穿梭于复杂的数据之间，并且在DOM外保持自己的状态。</p>

<h4>Learn Once, Write Anywhere</h4>

<p>我们不假定你现在的技术栈是怎样的，所以你可以不用重写已存在的代码来用React开放新的功能。React也可以在服务器端渲染，也可以用React Native创建强大的移动应用。</p>

<h4>A Simple Component</h4>

<p>React 组件调用 <code>render()</code> 方法来输入参数然后返回要显示的样子。这个例子用一个类似XML语言的我们称之为JSX，通过<code>this.props</code>输入数据传到组件内部可以被<code>render()</code>方法获取。使用React的话，JSX是可选的，不是必须要使用的。试着点击<code>Complied JS</code>去看看通过JSX编译器产生的原生的JavaScript 代码。</p>

<h4>A Stateful Component</h4>

<p>除了通过<code>this.props</code>来传入参数，组件可以通过<code>this.state</code>来维护自己内部状态的数据。当组件的状态数据改变时，渲染器就会重新调用<code>render()</code>方法来刷新。</p>

<h4>An Application</h4>

<p>使用<code>props</code>和<code>state</code>我们可以收集一个小型的代办事项申请。这个例子用<code>state</code>来跟踪当前列表和用户输入的数据。虽然事件处理程序似乎是呈现内联,他们会通过事件代理被收集和使用。</p>

<h4>A Component Using External Plugins</h4>

<p>React 是灵活的，并且提供了一个钩子来和库或框架进行链接。这个例子使用<code>remarkable</code>,一个外部的 Markdown 库，来实时转化文本内容。</p>

<p>哎呀~ 自己翻译果然别扭&hellip;😞  React 是什么呢？React 是Facebook 封装的一组JS代码库：</p>

<p><img src="/myimg/java/react.png" alt="" /></p>

<p>按它规则可封装一个一个模块组件，这个模块组件有自己的状态，自己的逻辑等，它是一个独立的东西，然后把这样的组件一个一个组合起来。我理解的这不就是iOS或者Android自定义View 模块化吗？按照React 的规则可以混合着写JavaScript和HTML,这样的一个组件就是一个独立的模块化的View。添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。</p>

<p>React 还封装了一个自己的虚拟的DOM，通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。因为如果大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个虚拟 DOM，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 <a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">diff</a> 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性。给组件设置一个 <code>ref</code> 属性，然后用 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点对象。</p>

<h4>Hello World</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;

    &lt;script type="text/babel"&gt;
    var MyComponent = React.createClass({
      render: function() {
        return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;
      }
    });

    ReactDOM.render(&lt;MyComponent name="World !" /&gt;,
                    document.getElementById('example') );
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>上面的代码中用React的语法自定义了一个组件叫<code>MyComponent</code>,这个组件返回一个块区间，里面显示 Hello + 这个组件的<code>name</code>属性值。注意script 的type 要声明为<code>text/babel</code>。这样就可以在其他地方使用这个自定义的组件了。可以把 <code>props</code> 看作是组件的配置属性，在组件内部是不变的，只是在调用这个组件的时候传入不同的属性值来定制显示这个组件。当组件状态 <code>state</code> 有更改的时候，React 会自动调用组件的 <code>render()</code> 方法重新渲染整个组件的 UI。<code>this.props</code> 对象的属性与组件的属性一一对应，<code>this.props.children</code> 表示组件的所有子节点。需要注意， <code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 <code>this.props.children</code> 的时候要小心。上面的代码把 HTML 直接嵌入了 JS 代码里面了，这就是 React 提出的一种叫 JSX 的语法。把原来网页设计的代码分离，现在又融合了！</p>

<p><img src="/myimg/java/react_hello.png" alt="" /></p>

<p>Hello World 运行起来了！嗯~ 我已经成功了一半！😆</p>

<h4>组件组合</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;

    &lt;script type="text/babel"&gt;

    var Avatar = React.createClass({
        render: function() {
            return (
                &lt;div&gt;
                    &lt;ProfilePic username={this.props.username} /&gt;
                    &lt;ProfileName username={this.props.username} /&gt;
                &lt;/div&gt;
            );
        }
       });

    var ProfilePic = React.createClass({
        render: function() {
            return (
                &lt;img src={'https://gss0.bdstatic.com/70cFsj3f_gcX8t7mm9GUKT-xh_/avatar/100/r6s1g6.gif'} /&gt;
            );
        }
    });

    var ProfileName = React.createClass({
        render: function() {
            return (
              &lt;div&gt;
                &lt;a href={'http://guimingsu.com'}&gt;
                    {this.props.username}
                &lt;/a&gt;
              &lt;/div&gt;
            );
        }
    });

    ReactDOM.render(
        &lt;Avatar username="hello world " /&gt;,
        document.getElementById('example')
      );

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这里显示了一个Avatar 组件，这个Avatar 组件是由两个更小的组件ProfilePic和ProfileName组合而成的。父组件和子组件间可以通过<code>props</code>一层一层的传值。Remember: React is all about one-way data flow down the component hierarchy.</p>

<p><img src="/myimg/java/react_hello0.png" alt="" /></p>

<h4>状态变化</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;
    &lt;script type="text/babel"&gt;

     var LikeButton = React.createClass({
      getInitialState: function() {
        return {liked: false};
      },

      handleClick: function(event) {
        this.setState({liked: !this.state.liked});
      },

      render: function() {
        var text = this.state.liked ? 'like' : 'haven\'t liked';
        return (
          &lt;p onClick={this.handleClick}&gt;
            You {text} this. Click to toggle.
          &lt;/p&gt;
        );
      }
    });

    ReactDOM.render(
      &lt;LikeButton /&gt;,
      document.getElementById('example')
    );

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>上面代码是一个 <code>LikeButton</code> 组件，它的 <code>getInitialState</code> 方法用于定义初始状态，也就是一个对象，这个对象可以通过 <code>this.state</code> 属性读取。当用户点击组件，导致状态变化，<code>this.setState</code> 方法就修改状态值，每次修改以后，自动调用 <code>this.render</code> 方法，再次渲染组件。
由于 <code>this.props</code> 和 <code>this.state</code> 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，<code>this.props</code> 表示那些一旦定义，就不再改变的特性，而 <code>this.state</code> 是会随着用户互动而产生变化的特性。即把要跟随某个参数实时变化的代码写在 <code>render: function() {};</code>里，然后在用户调用的方法里调用<code>this.setState({ });</code>方法来改变参数就可以了，因为他们触发<code>render</code>方法。这样就可以根据不同参数值自动显示不同内容。</p>

<h4>生命周期</h4>

<p>组件的生命周期分成三个状态：</p>

<ol>
<li>Mounting：已插入真实 DOM</li>
<li>Updating：正在被重新渲染</li>
<li>Unmounting：已移出真实 DOM</li>
</ol>


<p>React 为每个状态都提供了两种处理函数，<code>will</code> 函数在进入状态之前调用，<code>did</code> 函数在进入状态之后调用，三种状态共计五种处理函数。</p>

<ol>
<li>componentWillMount()</li>
<li>componentDidMount()</li>
<li>componentWillUpdate(object nextProps, object nextState)</li>
<li>componentDidUpdate(object prevProps, object prevState)</li>
<li>componentWillUnmount()</li>
</ol>


<p>此外，React 还提供两种特殊状态的处理函数:</p>

<ol>
<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</li>
<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用</li>
</ol>


<p><img src="/myimg/java/react_life.png" alt="" /></p>

<p>把这个<a href="https://facebook.github.io/react/docs/thinking-in-react.html">官方例子</a>看完就能收获不少了。主要在于思考，拿到设计图如何拆分模块，如何组建，如何选取放置状态参数，如何看懂别人写好的代码等。<a href="/mysrc/java/reactPriceDemo.zip">下载</a></p>

<h5>链接</h5>

<ol>
<li><a href="http://www.cnblogs.com/sakurayeah/category/868210.html">React入门</a></li>
<li><a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a></li>
</ol>

</div>


      | <a href="#comments">Comments</a>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">guimingsu</span></span>

      




<time class='entry-date' datetime='2016-11-24T14:31:57+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:31 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/react/'>react</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
  <!-- JiaThis Button -->
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/11/24/atom-edit/" title="Previous Post: Atom 使用">&laquo; Atom 使用</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/11/26/react-native-basic/" title="Next Post: React Native 基础知识">React Native 基础知识 &raquo;</a>
      
    </p>
  </footer>
</article>


  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-title="Octopress博客的个性化配置"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"tianweili"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END --></div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/11/26/react-native-basic/">React Native 基础知识</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/24/react-javascript/">React 基础知识</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/24/atom-edit/">Atom 使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/23/react-native-run-bug/">React Native 问题汇总</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/17/struts-spring-mybatis/">Struts + Spring + MyBatis</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>android (9)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (10)</a></li>
<li class='category'><a href='/blog/categories/other/'>other (8)</a></li>
<li class='category'><a href='/blog/categories/react/'>react (4)</a></li>

  </ul>
</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - guimingsu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
