
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Vue - 阿贵</title>
  <meta name="author" content="guimingsu">

  
  <meta name="description" content="Vue Dec 19th, 2016 11:58 am Vue Vue是一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular，Vue提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue。因为Vue是数据驱动的，所以无需手动操作DOM。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andyfightting.github.io/blog/2016/12/19/vue/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="阿贵" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">  -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

<script>
  function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
    });
  }
  $(document).bind('DOMNodeInserted', function(event) {
    addBlankTargetForLinks();
  });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">阿贵</a></h1>
  
    <h2>认真听，好好想，慢慢回。多思考，多做笔记。</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andyfightting.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Vue</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-12-19T11:58:13+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:58 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h4>Vue</h4>

<p><a href="https://cn.vuejs.org/">Vue</a>是一个JavaScript MVVM库，它是以<strong>数据驱动和组件化</strong>的思想构建的。相比于Angular，Vue提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue。因为Vue是数据驱动的，所以无需手动操作DOM。它通过一些特殊的HTML语法，将DOM和数据绑定起来。一旦创建了绑定，DOM将和数据保持同步，每当变更了数据，DOM也会相应地更新。当然了，在使用Vue的同时时，也可以结合其他库一起使用，比如jQuery。
<img src="/myimg/js/vue.png" alt="" /></p>

<p>ViewModel是Vue的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。当创建了ViewModel后，数据就已经双向绑定好了。如上图所示：可以将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。</p>

<ol>
<li>从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据。</li>
<li>从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。</li>
</ol>


<p>Vue也像Angular似的，是通过扩展元素的属性来处理的，扩展的属性被称为<code>指令</code>，如 v-model, v-if, v-else, v-bind ,v-show 等。</p>

<p><img src="/myimg/js/vue1.png" alt="" />
组件系统是 Vue.js 另一个重要概念，就像上图所示，把一个个 <code>Vue</code> 组件组合起来就可以了，各个组件都是一个独立的个体，就像搭积木一样。</p>

<p><strong>v-model ：</strong> 可以绑定表单元素如imput,select,textarea的值.下面将input元素的值和message绑定。1：当文本框的值改变时，<code>/{/{ message /}/}</code>会自动更新，2：当message的值改变时，文本框的值也会被更新, 这就叫数据双向绑定。(忽略/,因为MarkDown转化不了所以加的)</p>

<pre><code>&lt;div id="app"&gt;
    &lt;p&gt;/{/{ message /}/}&lt;/p&gt;
    &lt;input type="text" v-model="message"/&gt;
&lt;/div&gt;
</code></pre>

<p><strong>v-if ：</strong> 是条件渲染指令，它根据表达式的真假来删除和插入元素。如<code>&lt;h1 v-if="age &gt;= 25"&gt;Age = &lt;/h1&gt;</code>,当age&lt;25时，整个h1元素都不显示，而且就html就没有该节点，不像<code>v-show</code>是有该节点，然后设置节点 display = none。</p>

<p><strong>v-show :</strong> 也是条件渲染指令，和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性是不是style=&ldquo;display:none"。</p>

<p><strong>v-else :</strong>v-else元素必须立即跟在v-if或v-show元素的后面，否则它不能被识别。</p>

<pre><code>&lt;div id="app"&gt;
    &lt;h1 v-if="age &gt;= 25"&gt;Age: &lt;/h1&gt;
    &lt;h1 v-else&gt;age不大于25&lt;/h1&gt;

    &lt;h1 v-show="age &gt;= 25"&gt;Age: &lt;/h1&gt;
    &lt;h1 v-else&gt;age不大于25&lt;/h1&gt;
&lt;/div&gt;
</code></pre>

<p>上面代码中如果age大于25，后面的v-else都不会渲染到HTML。</p>

<p><strong>v-for :</strong> 基于一个数组渲染一个列表，它和JavaScript的遍历语法相似.可以用 <code>in</code>代替。</p>

<pre><code>&lt;tr v-for="person in personArray"&gt;
  &lt;td&gt;/{/{ person.name}}&lt;/td&gt; &lt;td&gt;/{/{ person.age}}&lt;/td&gt;
&lt;/tr&gt;
</code></pre>

<p><strong>v-bind :</strong>可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是元素的属性值设置，如 <code>&lt;h1 v-bind="class:age&gt;=25?'old':'young'"&gt;class 属性值设置&lt;/h1&gt;</code>,当age大于25，class=old,否则class=young。</p>

<p><strong>v-on :</strong>用于绑定DOM事件，如<code>&lt;h1 v-on:click="showAlert"&gt;点击&lt;/h1&gt;</code>，再在methods里实现对应方法名的方法。</p>

<pre><code>methods: {
 showAlert: function() {
     alert("点击啦！！")
  }
}
</code></pre>

<p>v-bind指令可以缩写为一个冒号 <code>:</code>，v-on指令可以缩写为<code>@</code>符号。</p>

<p><code>v-bind:class="xxx"</code> &ndash;> <code>:class="xxx"</code>,  <code>v-on:click="showAlert"</code> &ndash;> <code>@click="greet"&gt;</code></p>

<p>下面是自定义一个组件叫my-component.像React似的，也是通过<code>props</code>来传参数值。v-bind 意思是给属性绑定值，下面是给item 属性绑定 data, 而 item 这个属性名字是在 <code>props: ['item'],</code> 这里定义的，data 是前面 v-for 从dataArray 里取出来的。</p>

<pre><code>&lt;div id="app"&gt;
    &lt;ol&gt;
        &lt;my-component v-for="data in dataArray" v-bind:item="data" /&gt;
    &lt;/ol&gt;
&lt;/div&gt;

&lt;script&gt;
    Vue.component('my-component', {
        props: ['item'],
        template: '&lt;li&gt;&lt;/li&gt;'
    })
    var app = new Vue({
        el: '#app',
        data: {
            dataArray: [
                {text: 'hello'},
                {text: 'world'},
            ]
        }
    })
&lt;/script&gt;
</code></pre>

<p>Vue 的生命周期函数有 init,created,ready,mounted,updated,destroyed等。
<img src="/myimg/js/lifecycle.png" width="400" alt="" /></p>

<p><strong>v-once :</strong> 使用这个指令的话值只会插入一次，之后数据再改变就不会更新了，这会影响到该节点上所有的数据绑定。</p>

<p>双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 v-html 指令。</p>

<p>像Angular一样，也有过滤器，或自定义过滤器： message | capitalize 。过滤器函数总接受表达式的值作为第一个参数。</p>

<pre><code>filters: {
    capitalize: function (value) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }
</code></pre>

<p>在 <code>computed</code> 添加计算型属性：下面是一个计算型属性myMsg, 通过获取data中的msg属性来处理，然后返回处理结果。通过<code>methods</code>里定义方法也能达到相同的效果，但<strong>计算属性是基于它的依赖缓存。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 msg 没有发生改变，多次访问 myMsg 计算属性会立即返回之前的计算结果，而不必再次执行函数。而 method 调用总会执行函数。</strong></p>

<pre><code> computed: {
    myMsg: function () {
      return this.msg.split('').reverse().join('')
    }
  }
</code></pre>

<p>还有 <code>watch</code> 它用于观察 Vue 实例上的数据变动。下面是观察msg,如果msg变动就会执行方法给myMsg赋值。方法是异步操作。</p>

<pre><code>watch: {
    msg: function (val) {
      this.myMsg = val + 'hello'
    },
  }
</code></pre>

<p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：</p>

<pre><code>computed: {
  myMsg: {
    get: function () {
      return "xxx"
    },
    set: function (newValue) {
      //do something
    }
  }
}
</code></pre>

<p><strong>v-bind</strong>增强版 1.<code>&lt;div v-bind:class="{ active: isActive }"&gt;&lt;/div&gt;</code>,如果isActive为true,calss = active.</p>

<p>2.<code>&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;</code> 直接绑定一个对象。当在一个<strong>定制</strong>的组件上用到 class 属性的时候，这些类将被添加到<strong>根元素</strong>上面，这个元素上已经存在的类不会被覆盖。</p>

<pre><code>data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
</code></pre>

<p>对象语法，v-bind:style 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。 CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）：</p>

<pre><code>//1.
&lt;div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"&gt;&lt;/div&gt;
data: {
  activeColor: 'red',
  fontSize: 30
}

//2.
&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt;
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
</code></pre>

<p>Vue 会复用已有元素而不是从头开始渲染。可通过设置key 值来唯一区分，就不会复用了。这个类似 Vue 1.x 的 track-by=&ldquo;$index&rdquo; 。</p>

<p>下面的数组方法也会触发刷新,而filter(), concat(), slice() 。这些不会改变原始数组，但总是返回一个新数组。</p>

<pre><code>push()
pop()
shift()
unshift()
splice()
sort()
reverse()
</code></pre>

<p>事件修饰符：</p>

<pre><code>.once
.stop //阻止事件冒泡
.prevent //取消事件默认处理
.capture //开启事件捕获
.self
.once
.ctrl
.alt
.shift
.meta
</code></pre>

<p>按键别名：可以通过全局 config.keyCodes 对象自定义按键修饰符别名。(Vue.config.keyCodes.f1 = 112)</p>

<pre><code>.enter
.tab
.delete (捕获 “删除” 和 “退格” 键)
.esc
.space
.up
.down
.left
.right
</code></pre>

<p>由于 JavaScript 的限制， Vue 不能检测以下变动的数组：当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue当你修改数组的长度时，例如： vm.items.length = newLength为了避免第一种情况，以下两种方式将达到像 vm.items[indexOfItem] = newValue 的效果， 同时也将触发状态更新：</p>

<pre><code>1.Vue.set(example1.items, indexOfItem, newValue)
2.example1.items.splice(indexOfItem, 1, newValue)
</code></pre>

<p>避免第二种情况，使用 splice：<code>example1.items.splice(newLength)</code></p>

<pre><code>//自定义全局组件
Vue.component('my-component', {

})
//自定义局部组件
var Child = {
  template: '&lt;div&gt;A custom component!&lt;/div&gt;'
}
new Vue({
  components: {
    // &lt;my-component&gt; 将只在父模板可用
    'my-component': Child
  }
})
</code></pre>

<p>父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。prop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 props 选项声明 “prop”。prop的名字形式会从 camelCase 转为 kebab-case。（myMessage &ndash;> my-message）</p>

<p>prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。</p>

<p>改变 prop 可通过两种方法曲线救国：就像React props也不应该修改，而是修改state里的属性一样。</p>

<pre><code>1.prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；
2.prop 作为需要被转变的原始值传入。
</code></pre>

<p>像React一样，props也可以指定类型：String，Number，Boolean，Function，Object，Array。type 也可以是一个自定义构造器，使用 instanceof 检测。</p>

<pre><code> props: {
    // 基础类型检测 （`null` 意思是任何类型都可以）
    propA: Number,
    // 多种类型
    propB: [String, Number],
    // 必传且是字符串
    propC: {
      type: String,
      required: true
    },
    // 数字，有默认值
    propD: {
      type: Number,
      default: 100
    },
    // 数组／对象的默认值应当由一个工厂函数返回
    propE: {
      type: Object,
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        return value &gt; 10
      }
    }
  }
</code></pre>

<p>父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>使用 $on(eventName) 监听事件
</span><span class='line'>使用 $emit(eventName) 触发事件</span></code></pre></td></tr></table></div></figure>


<p>自定义组件模板：</p>

<pre><code>&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;my-component v-bind:my-name="name" v-bind:my-age="age"&gt;&lt;/my-component&gt;
    &lt;/div&gt;

    &lt;template id="myComponent"&gt;
        &lt;table&gt;
            &lt;tr&gt;
                &lt;th colspan="2"&gt;
                    子组件数据
                &lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;my name&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;my age&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/template&gt;
&lt;/body&gt;

&lt;script&gt;
    var vm = new Vue({
        el: '#app',
        data: {
            name: 'andy',
            age: 18
        },
        components: {
            'my-component': {
                template: '#myComponent',
                props: ['myName', 'myAge']
            }
        }
    })
&lt;/script&gt;

-------------------------------
&lt;script type="text/x-template" id="myCom"&gt;
  &lt;div&gt;
    &lt;p&gt;hello&lt;/p&gt;
  &lt;/div&gt;
&lt;/script&gt;

Vue.component('my-com', {
  template: '#myCom',
})                          
</code></pre>

<p>v-bind:my-name.sync=&ldquo;name&rdquo; 这是用在子组件属性中 .sync 意思是子组件的数据会影响父组件，默认是不会的的。</p>

<p>.once 用子子组件属性中，表示只绑定一次父组件的数据。</p>

<p>熟悉值不能用双括号绑定值，只能用 v-bind 绑定。在 v-bind 用于 class 和 style 属性时， 表达式的结果类型除了字符串之外，还可以是对象或数组。</p>

<p>计算型属性与方法的区别是： 计算型属性会有缓存依赖，不是每次都会执行，只有值变了才执行。而方法是每次都执行。</p>

<p>Vue 会复用控件，用key属性来区分不同控件。v-bind:key = &ldquo;$index&rdquo; 相当于Vue 1.x 的 track-by=&ldquo;$index&rdquo; 。</p>

<p>注意 v-show 不支持 template 语法。 template 用 v-if . 主要 show 与 if 的区别，show 都有node，只是设置 display 属性。</p>

<p>v-for 迭代对象的话是迭代对象的值。 自定义组件使用v-for 值也不会自动传到组件里去，而要v-bind:item=&ldquo;item"，然后组件里用props: [&lsquo;item&rsquo;] 接收。
不自动注入 item 到组件里的原因是，因为这使得组件会紧密耦合到 v-for 如何运作。在一些情况下，明确数据的来源可以使组件可重用。</p>

<p>方法调用的时候可以用特殊变量 $event 把事件传入方法里。</p>

<p>v-model 指令在表单控件元素上创建双向数据绑定。它会根据<code>控件类型</code>自动选取正确的方法来更新元素。input,textarea,select，单选框，复选框。</p>

<p>对于限制性元素，可以用 is  来代替。如：</p>

<pre><code>&lt;table&gt;
  &lt;tr is="my-row"&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>

<p>is 还可以用来动态绑定组件：</p>

<pre><code>&lt;component v-bind:is="currentView"&gt;&lt;/component&gt;

var vm = new Vue({
  el: '#example',
  data: {
    currentView: 'archive'
  },
  components: {
    home: { 
        template: '&lt;p&gt; home ------ &lt;/&gt;'
    },
    posts: { 
         template: '&lt;p&gt; posts ------&lt;/&gt;'
     },
    archive: { 
         template: '&lt;p&gt; archive ------&lt;/&gt;'
    }
  }
})
</code></pre>

<p>自定义组件里 data 必须是函数：</p>

<pre><code> data: function () {
    return {
       key: value,
       key: value,
       key: value,
    }
  }
</code></pre>

<p>父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。
不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。</p>

<p>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</p>

<h3>基本使用</h3>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;script src="./vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id="app"&gt;
  &lt;ol v-once&gt;
    &lt;todo-item v-for="item in groceryList" v-bind:todo="item"&gt;&lt;/todo-item&gt;
  &lt;/ol&gt;

&lt;template v-if="seen"&gt;
    &lt;p  v-on:click = "helloTap"&gt;  &lt;/p&gt;
&lt;/template&gt;
&lt;p v-else&gt; show else&lt;/p&gt;

&lt;my-com msg = "my component" v-on:increment = "increments"&gt;&lt;/my-com&gt;
&lt;my-com2 msg = "my component2"&gt;&lt;/my-com2&gt;

&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
var bus = new Vue();

Vue.component('todoItem', {
  props: ['todo'],
  template: '&lt;li&gt;&lt;/li&gt;',

   filters: {
    capitalize: function (value) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }

})

var vm = new Vue({
  el: '#app',

  data: {
    groceryList: [
      { text: 'aegetables' },
      { text: 'cheese' },
      { text: 'Whatever else humans are supposed to eat' }
    ],
     msg: "hello",
     seen: true
  },

  computed:{
    rMsg: function () {
      return this.msg.split('').reverse().join('')
    }
  },

  methods:{
    helloTap: function(){
        alert("hello");
    },
     increments: function(){
        alert("helloss");
    }
  },

  components:{
    'my-com':{
      props: ['msg'],

data: function () {
  return {
    innerData: 'innerData  hello',
  }
},

  methods: {
    increment: function () {
      this.$emit('increment')
    }
  },

       template: '&lt;div&gt;&lt;p&gt;&lt;/p&gt;  &lt;p&gt;&lt;/p&gt;&lt;/div&gt;',
    },

    'my-com2':{
      props: ['msg'],
       template: '&lt;p&gt;&lt;/p&gt;',
    },

  },

 filters: {
    capitalize: function (value) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  },

   beforeCreate:function(){
    console.log("----------beforeCreate");
  },
  created:function(){
    console.log("----------created");
  },
   beforeMount:function(){
    console.log("----------beforeMount");
  },
   mounted:function(){
    console.log("----------mounted");
  },
   beforeUpdate:function(){
    console.log("----------beforeUpdate");
   },
  updated:function(){
    console.log("----------updated");
  },
  beforeDestroy:function(){
    console.log("----------destroyed");
  },
  destroyed:function(){
    console.log("----------destroyed");
  },

  watch:{
    groceryList: function(newValue){
     console.log("--------------groceryList变了1");
    }
  }

})

vm.$watch('groceryList', function (newVal, oldVal) {
   console.log("--------------groceryList变了2");
})

&lt;/script&gt;

&lt;/html&gt;
</code></pre>
</div>


      | <a href="#comments">Comments</a>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">guimingsu</span></span>

      




<time class='entry-date' datetime='2016-12-19T11:58:13+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:58 am</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/javascript/'>javascript</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
  <!-- JiaThis Button -->
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/12/03/node-js/" title="Previous Post: Node">&laquo; Node</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/12/20/weex/" title="Next Post: Weex">Weex &raquo;</a>
      
    </p>
  </footer>
</article>


  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-title="Octopress博客的个性化配置"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"tianweili"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END --></div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/02/11/front-end/">前端基础知识</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/30/utf8/">Unicode、UTF-8编码起源</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/28/google-protocol-buffer/">Google Protocol Buffer</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/27/suan-fa/">排序算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/21/es6/">ECMAScript 6</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>android (9)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (9)</a></li>
<li class='category'><a href='/blog/categories/java/'>java (6)</a></li>
<li class='category'><a href='/blog/categories/javascript/'>javascript (5)</a></li>
<li class='category'><a href='/blog/categories/other/'>other (5)</a></li>
<li class='category'><a href='/blog/categories/react/'>react (8)</a></li>

  </ul>
</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - guimingsu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
