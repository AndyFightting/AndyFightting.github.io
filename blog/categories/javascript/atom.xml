<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2017-02-14T09:15:24+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[前端基础知识]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/25/front-end/"/>
    <updated>2016-12-25T13:45:11+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/25/front-end</id>
    <content type="html"><![CDATA[<h4>*JSONP原理</h4>

<p>JSON是一种数据交换格式，JSONP(JSON Padding)是数据的传递方式，不一样的概念。打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用“暗号”书写的情报，传递给自己同志时使用的接头方式。一个是描述信息的格式，一个是信息传递时约定的方法。</p>

<p>JSONP是为了解决跨域问题，因为受限于浏览器的同源策略(域名相同，协议相同，端口相同)，XMLHttpRequest 不能进行跨域请求，但是 script 标签却可以(有src属性的标签都可以，如img,iframe)。JSONP的原理就是：<strong>让服务器端调用本地的JS方法，在调用的时候把数据当做参数传进去，然后本地就可以获得数据进行处理了。</strong></p>

<p>远程服务器remoteserver.com根目录下有个remote.js文件代码如下：</p>

<pre><code>localHandler({"result":"我是远程js带来的数据"});
</code></pre>

<p>现在我们在test.html页面定义一个函数，然后在远程remote.js中传入数据进行调用,就获取到跨域服务器端的数据了。</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type="text/javascript"&gt;
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
    &lt;/script&gt;
    &lt;script type="text/javascript" src="http://remoteserver.com/remote.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>基本原理就是这样，剩下的就是如何弹性封装了，如：</p>

<pre><code>&lt;script type="text/javascript"&gt;
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };

    var url = "http://remoteserver.com/remote.js?id=123&amp;callback=localHandler";
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
   document.getElementsByTagName('head')[0].appendChild(script); 
&lt;/script&gt;
</code></pre>

<h3>* <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">JS原型链是什么</a></h3>

<p>在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部属性。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。</p>

<p>Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>

<p>JavaScript的对象中都包含了一个 prototype 内部属性，这个属性所对应的就是该对象的原型。在JavaScript的原型对象中，还包含一个"constructor"属性，这个属性对应创建所有指向该原型的实例的构造函数。JavaScript 不包含传统的类继承模型，而是使用 prototypal 原型模型。</p>

<pre><code>XXX.__proto__ :原型(父类)。
XXX.protoype :原型对象(父实例)。
</code></pre>

<p><a href="http://blog.jobbole.com/66441/">参考</a></p>

<h4>*cookie、sessionStorage、localStorage的区别</h4>

<p>document.cookie: 是服务器端保存在客户端的一段信息，如保存登录信息，记住密码等,它可以设置过期时间自动清除,4K左右.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，所以不宜过大。如服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。</p>

<p>window.sessionStorage: session即会话，关闭浏览器即清除。5M左右，仅保存在客户端中，不参与通信。</p>

<p>window.localStorage: 本地持久化，一直都在除非手动删除。5M左右。</p>

<p>sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面。</p>

<p>localStorage：在所有同源窗口中都是共享的。</p>

<p>cookie：也是在所有同源窗口中都是共享的。</p>

<p>共同点：都是保存在浏览器中，且都是同源的。</p>

<p>不同点：大小不同，有效期不同，作用域不同。</p>

<h3>* 创建一个从1到100的数组</h3>

<p>一看这题目应该就不是for循环这么简单了</p>

<p>递归：</p>

<pre><code>  function test(arr, num) {
      if (num &gt; 100) {
          return arr
      }
      arr.push(num);
      return test(arr, num + 1)
  }
  var arr = test([], 1);
</code></pre>

<p>Generator函数：</p>

<pre><code>function* test(i) {
    yield i;
    if (i &lt; 100) {
        yield* test(i + 1);
    }
}
 var arr =   Array.from(test(1));
</code></pre>

<h3>* 说说React &amp; Vue</h3>

<p>虚拟DOM, 单向数据流，双向绑定响应式，组件化，模板+js+css，JSX语法,生命周期，指令，依赖追踪，检查机制,更快的渲染更小的体积, 庞大的社区，RN，Weex,引用本地模块。</p>

<p><a href="http://cn.vuejs.org/v2/guide/comparison.html">对比</a> ,<a href="http://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247484393&amp;idx=1&amp;sn=142b8e37dfc94de07be211607e468030&amp;chksm=9723612ba054e83db6622a891287af119bb63708f1b7a09aed9149d846c9428ad5abbb822294&amp;mpshare=1&amp;scene=1&amp;srcid=1026oUz3521V74ua0uwTcIWa&amp;from=groupmessage&amp;isappinstalled=0#wechat_redirect&amp;utm_source=tuicool&amp;utm_medium=referral">参考</a></p>

<h4>*<a href="http://www.w3school.com.cn/css/css_boxmodel.asp">CSS盒模型</a></h4>

<p><img src="/myimg/js/cssbox.png" width="400" alt="" /></p>

<p>背景应用于由内容和内边距、边框组成的区域。width,heightz只是内容宽高，不包括padding,border,marin.</p>

<h3>*get和post请求的区别</h3>

<p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE,可以应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</p>

<p>GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&amp;相连。POST把提交的数据则放置在是HTTP包的包体中。</p>

<p>GET方式提交的数据有大小限制，而POST理论上没有。</p>

<p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。</p>

<p><a href="https://www.oschina.net/news/77354/http-get-post-different">99%的人都理解错了&hellip;</a></p>

<h3>*什么是HTTPS</h3>

<p>https是https+ssl(Secure Socket Layer),它是从底层协议的层面来解决如下问题：</p>

<ol>
<li>数据裸奔问题</li>
<li>数据被篡改问题</li>
<li>身份验证问题</li>
</ol>


<p>它的基本思路是采用公钥加密法(RSA)，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。由于非对称加密的效率问题，一般是用对称加密给数据进行加密，然后把对称加密的密钥进行RSA加密来传输，并且对称加密的密钥是动态变化的。</p>

<h3>*说说TCP/UDP</h3>

<p>TCP: 传输控制协议，三次握手，四次挥手。面向连接，安全可靠。传输大量数据，慢。</p>

<p>UDP: 用户数据协议，面向非连接，直接发数据，不可靠，发小量数据，快。</p>

<h3>*JS类的创建</h3>

<p> <strong>构造函数法</strong></p>

<pre><code>    function Dog() {
       this.name = "金毛";
    }
    var dog = new Dog();
    alert(dog.name);
</code></pre>

<p><strong>Object.create()法</strong>, 但是不能实现私有属性和私有方法</p>

<pre><code>      var Dog = {
    　　　　name: "金毛",
    　　　　makeSound: function(){ alert("hello world"); }
    　　};
    　　var dog = Object.create(Dog);
    　　alert(dog.name); 
    　　cat1.makeSound(); 
</code></pre>

<p> <strong>极简法</strong> (这不就是工厂方法吗？工厂的属性和方法是私有的且是共享的)</p>

<p>封装：</p>

<pre><code>  var Cat = {
　　　　createNew: function(){
　　　　　　var cat = {};
　　　　　　cat.name = "大毛";
　　　　　　cat.makeSound = function(){ alert("喵喵喵"); };
　　　　　　return cat;
　　　　}
　　};
　　var cat1 = Cat.createNew();
　　cat1.makeSound();
</code></pre>

<p> 继承：</p>

<pre><code class="">   var Animal = {
　　　　createNew: function(){
　　　　　　var animal = {};
　　　　　　animal.sleep = function(){ alert("睡懒觉"); };
　　　　　　return animal;
　　　　}
　　};
   var Cat = {
　　　　createNew: function(){
　　　　　　var cat = Animal.createNew();
　　　　　　cat.name = "大毛";
　　　　　　cat.makeSound = function(){ alert("喵喵喵"); };
　　　　　　return cat;
　　　　}
　　};
   var cat1 = Cat.createNew();
　　cat1.sleep();
　　cat1.makeSount();
</code></pre>

<p>私有属性和方法：下面只要不是定义在cat对象上的方法和属性，都是私有的。</p>

<pre><code>  var Cat = {
　　　　createNew: function(){
　　　　　　var cat = {};
　　　　　　var sound = "喵喵喵"; //私有属性
　　　　　　cat.makeSound = function(){ alert(sound); };
　　　　　　return cat;
　　　　}
　　};
　　var cat1 = Cat.createNew();
　　alert(cat1.sound); // undefined
</code></pre>

<p>数据共享：</p>

<pre><code>  var Cat = {
　　　　sound : "喵喵喵", //被各个实例共享
　　　　createNew: function(){
　　　　　　var cat = {};
　　　　　　cat.makeSound = function(){ alert(Cat.sound); };
　　　　　　return cat;
　　　　}
　　};
　　var cat1 = Cat.createNew();
　　var cat2 = Cat.createNew();
　　cat1.makeSound(); // 喵喵喵
</code></pre>

<p><strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">ES6 class法</a></strong></p>

<pre><code>class Cat { 
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(this.name + ' makes a noise.');
  }
}

class Lion extends Cat {
  speak() {
    super.speak();
    console.log(this.name + ' roars.');
  }
}
</code></pre>

<p><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">参考</a></p>

<h3>*JS闭包</h3>

<p>闭包就是能够读取其他函数内部变量的函数。闭包使得函数拥有私有变量称为可能，它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。因为里面的闭包函数是个全局变量，会一直在内存中。</p>

<p>下面计数器受匿名函数的作用域保护，只能通过 add 方法修改。</p>

<pre><code>var add = (function () {
   var counter = 0;
   return function () {
      return counter += 1;
    }
})();

add();
add();
add();
</code></pre>

<p><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">参考</a></p>

<h3>* use strict</h3>

<p>严格模式，使得JS在更严格的条件下运行，有如下优势：</p>

<pre><code>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为
消除代码运行的一些不安全之处，保证代码运行的安全
提高编译器效率，增加运行速度
为未来新版本的JS特性做好铺垫
</code></pre>

<h3>* CSS Reset 是什么</h3>

<p>在HTML标签在浏览器里有默认的样式，例如 p 标签有上下边距，strong标签有字体加粗样式，em标签有字体倾斜样式。不同浏览器的默认样式之间也会有差别。把浏览器提供的默认样式覆盖掉, 这就是CSS Reset。</p>

<h3>* 回调地狱</h3>

<p>即异步回调的层层嵌套,可以用 Promise 对象、Generator函数，Async函数来解决。</p>

<pre><code>$.ajax({  
    url: url1,  
    success: function(data){  
        $.ajax({  
            url: url2,  
            data: data,  
            success: function(data){  
                $.ajax({  
                    //...
                });  
            }      
        });  
    }  
});  
</code></pre>

<h3>* xss和csrf是什么</h3>

<p>XSS它的全名是：Cross-site scripting 夸站脚本攻击，为了和CSS层叠样式表区分所以取名XSS。是一种网站应用程序的安全漏洞攻击，是代码注入的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p>

<p>提交过滤。</p>

<p>CSRF全名是：Cross-site request forgery 跨站请求伪造，也是不攻击服务器端而攻击正常访问网站的用户。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。大多数网站是通过 cookie 等方式辨识用户身份再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机发起用户所不知道的请求。</p>

<p>验证码，域名判断，添加token。</p>

<h3>* 图片滚动到了才加载原理</h3>

<p>即懒加载延迟加载，原理是：先在img src中放一张占位符图片，而真实的图片地址存放在相对应一个属性 data-img中，这样的话 那么页面加载的时候 只加载src地址 不会对属性的图片真正地址加载，滚动时候判断 待加载的资源相对于浏览器顶端的距离小于可视区域相对于浏览器顶端的距离 如果为true的话 则把相对应的data-img值赋值给src 加载，否则不加载。</p>

<p>主要有三种模式：</p>

<pre><code>第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟，如果用户在加载前就离开了页面，那么就不会加载。
第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。
第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。
</code></pre>

<h3>* 把URL参数解析为一个对象</h3>

<pre><code>var url = "http://www.taobao.com/index.php?key0=0&amp;key1=1&amp;key2=2";
var obj = parseUrl(url);

function parseUrl(argu){
  var str = argu.split('?')[1];
  var result = {};
  var temp = str.split('&amp;');
  for(var i=0; i&lt;temp.length; i++)
  {
     var temp2 = temp[i].split('=');
     result[temp2[0]] = temp2[1];
  }
  return result;
}
</code></pre>

<h3>* flex布局与传统布局</h3>

<p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。</p>

<p>flex容器布局：默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>

<p><img src="/myimg/js/flexbox.png" width="600" alt="" /></p>

<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">参考</a></p>

<h3>* JS事件流</h3>

<p>事件流：事件在页面中传播的顺序。</p>

<p>捕获，冒泡：xxx.addEventListener(type,handler,flag),flag是一个bool值，true表示事件捕捉阶段执行，false表示事件冒泡阶段执行，默认是冒泡。</p>

<p><img src="/myimg/js/event.png" width="400" alt="" /></p>

<p><a href="http://www.cnblogs.com/starof/p/4066381.html">参考</a></p>

<h3>* 从输入 URL 到页面加载完的过程中都发生了什么事情</h3>

<pre><code>检查浏览器缓存，如果有的话直接解析显示。
DNS域名解析，层层寻找，负载均衡，找到对应的IP
TCP链接，三次握手(HTTPS更多次)
加载策略，RSA密钥协商，加密解密
服务器处理，数据库查询，返回页面
网页重定向
页面里的资源链接再获取数据，浏览器渲染
</code></pre>

<h3>* link和import的区别</h3>

<pre><code>来源不同：link 属于html标签，而@import完全是css提供的一种方式。link还能加载其他东西如RSS,而import只能加载CSS.
加载顺序不同：当一个页面被加载的时候，link引用的CSS会同时被加载，而@import引用的CSS 会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁，阿里云APP总这样闪），网速慢的时候还挺明显。
兼容性差别：由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。
使用dom控制样式时的差别：当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。
</code></pre>

<h3>* JS优缺点</h3>

<pre><code>JavaScript是一种基于对象（Object）和事件驱动（Event Driven,单线程事件轮询）、动态、弱类型、基于原型的语言。
函数作为一等公民存在,函数式编程。动态性，指定函数的执行语境，动态混入，动态修改原型等。

允许同名函数的重复定义，后面的定义可以覆盖前面的定义。隐式类型转换。全局变量难以控制，null &amp; undefined鸡肋。
</code></pre>

<h3>* CSS预处理</h3>

<p>CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的逻辑程序、函数等,在编程语言中的一些基本特性，可以让你的 CSS 更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。</p>

<p><a href="http://less.bootcss.com/">Less</a> 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。</p>

<p><a href="https://segmentfault.com/q/1010000002527156">参考</a></p>

<h3>* 函数声明 &amp; 函数表达式</h3>

<p>定义函数的方法主要有三种：</p>

<ol>
<li>函数声明(Function Declaration)</li>
<li>函数表达式Function Expression)</li>
<li>new Function构造函数</li>
</ol>


<p>用函数声明创建的函数funDeclaration可以在funDeclaration定义之前就进行调用；而用函数表达式创建的funExpression函数不能在funExpression被赋值之前进行调用。</p>

<pre><code>//声明
function functionName(arg1, arg2){}
//表达式
var  variable = function(arg1, arg2){}
</code></pre>

<p>用函数声明创建的函数funDeclaration可以在funDeclaration定义之前就进行调用；而用函数表达式创建的funExpression函数不能在funExpression被赋值之前进行调用。</p>

<pre><code>funDeclaration("Declaration");//=&gt; true
     function funDeclaration(type){
         return type==="Declaration";
     }

 funExpression("Expression");//=&gt;error
     var funExpression = function(type){
         return type==="Expression";
     }
</code></pre>

<p><a href="http://www.cnblogs.com/isaboy/p/javascript_function.html">参考</a></p>

<h3>* <a href="http://webpackdoc.com/amd.html">AMD(异步模块定义)</a> &amp; <a href="http://webpackdoc.com/commonjs.html">CommonJs规范</a></h3>

<p>CommonJS是服务器端模块化规范，NodeJS采用了这个规范。根据它的规范，一个文件就是一个模块，每个模块都在一个单独的作用域，也就是说在该模块内部定义的变量，无法被其他模块读取，除非定义global对象的属性。CommonJS加载模块是同步的，也就是说只有加载完成，才能执行后面的操作。它的 exports 才是对外接口。</p>

<p>CommonJS 规范是为了解决 JavaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行。该规范的主要内容是，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。</p>

<pre><code>所有代码都运行在模块作用域，不会污染全局作用域。
模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
模块加载的顺序，按照其在代码中出现的顺序。
</code></pre>

<pre><code>//模块定义 example.js
var x = 5;
var addX = function (value) {
  return value + x;
};
module.exports.x = x;
module.exports.addX = addX;

//使用模块
var example = require('./example.js');
console.log(example.x); // 5
console.log(example.addX(1)); // 6
</code></pre>

<p>Node内部提供一个Module构建函数。所有模块都是Module的实例。每个模块内部，都有一个module对象，代表当前模块。它有以下属性。module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p>

<pre><code>module.id 模块的识别符，通常是带有绝对路径的模块文件名。
module.filename 模块的文件名，带有绝对路径。
module.loaded 返回一个布尔值，表示模块是否已经完成加载。
module.parent 返回一个对象，表示调用该模块的模块。
module.children 返回一个数组，表示该模块要用到的其他模块。
module.exports 表示模块对外输出的值。
</code></pre>

<p>AMD规范则是非同步的加载模块，允许指定回调函数。由于nodeJS主要用于服务器编程，模块文件一般都在本地，所以加载起来比较快，不用考虑非同步的加载方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器端加载模块，则必须采用非同步模式，所以浏览器一般采用AMD规范。</p>

<p>规范其实只有一个主要接口 define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。</p>

<pre><code>define(['package/lib'], function(lib){
  function foo(){
    lib.log('hello world!');
  }

  return {
    foo: foo
  };
});
</code></pre>

<p><a href="http://javascript.ruanyifeng.com/nodejs/module.html">参考</a></p>

<h3>* attribute和property的区别</h3>

<p>attribute: 是一个属性节点，每个DOM元素都有一个对应的 attributes 属性来存放所有的 attribute节点。</p>

<pre><code>&lt;div class="box" id="box" gameid="880"&gt;hello&lt;/div&gt;
上面div的 attributes 为：[ class="box", id="box", gameid="880" ]
可以这样来访问attribute节点：
var elem = document.getElementById( 'box' );
console.log( elem.attributes[0].name ); // class
console.log( elem.attributes[0].value ); // box
通常要获取一个attribute节点直接用getAttribute方法：
console.log( elem.getAttribute('gameid') ); // 880
elem.setAttribute('testAttr', 'testVal');
console.log( elem.removeAttribute('gameid') ); // undefined
</code></pre>

<p>property：就是一个属性，如果把DOM元素看成是一个普通的Object对象，那么property就是一个以名值对(name=”value”)的形式存放在Object中的属性。要添加和删除property也简单多了，和普通的对象没啥分别。</p>

<pre><code>elem.gameid = 880; // 添加
console.log( elem.gameid ) // 获取
delete elem.gameid // 删除
</code></pre>

<p>之所以attribute和property容易混倄在一起的原因是，很多attribute节点还有一个相对应的property属性，比如上面的div元素的id和class既是attribute，也有对应的property，不管使用哪种方法都可以访问和修改。DOM元素一些默认常见的attribute节点都有与之对应的property属性.</p>

<pre><code>console.log( elem.getAttribute('id') ); // box
console.log( elem.id ); // box
elem.id = 'hello';
console.log( elem.getAttribute('id') ); // hello
</code></pre>

<p>但是对于自定义的attribute节点，或者自定义property，两者就没有关系了。</p>

<pre><code>console.log( elem.getAttribute('gameid') ); // 880
console.log( elem.gameid ); // undefined
elem.areaid = '900';
console.log( elem.getAttribute('areaid') ) // null
</code></pre>

<p>对于IE6-7来说，没有区分attribute和property：</p>

<pre><code>console.log( elem.getAttribute('gameid') ); // 880
console.log( elem.gameid ); // 880
elem.areaid = '900';
console.log( elem.getAttribute('areaid') ) // 900
</code></pre>

<p>attribute是一个属性节点对象，而property则是对象的一个字段</p>

<p><img src="/myimg/js/attribute.png" alt="" /></p>

<p><a href="https://www.web-tinker.com/article/20115.html">参考</a>, <a href="http://www.cnblogs.com/elcarim5efil/p/4698980.html">参考</a></p>

<h3>* ajax 原理</h3>

<p>Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。</p>

<pre><code>function test(){
    var xmlhttp;
    if (window.XMLHttpRequest){
        //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
        xmlhttp=new XMLHttpRequest();
    }
    else{
        // IE6, IE5 浏览器执行代码
        xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
    }
    xmlhttp.onreadystatechange=function(){
        if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200){
            document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
        }
    }
    xmlhttp.open("GET","/try/ajax/ajax_info.txt",true);
    xmlhttp.send();
}
</code></pre>

<p>优点：异步通信，按需加载
缺点：破坏了浏览器的back,history功能，安全问题，csrf(跨站请求伪造)，不能很好的支持移动设备</p>

<p><a href="http://www.cnblogs.com/SanMaoSpace/archive/2013/06/15/3137180.html">参考</a></p>

<h3>* <a href="http://www.zhangxinxu.com/wordpress/2013/07/jquery-%E5%8E%9F%E7%90%86-%E6%9C%BA%E5%88%B6/">jquery 原理分析</a></h3>

<p>jquery 是一个JS函数库，即选取元素(CSS选取器一样)，然后对元素进行操作的封装。它包含以下功能：</p>

<pre><code>HTML 元素选取
HTML 元素操作
CSS 操作
HTML 事件函数
JavaScript 特效和动画
HTML DOM 遍历和修改
AJAX
</code></pre>

<h3>* 作用域链</h3>

<p>域：Scope这个术语被用来描述在某个代码块可见的所有实体（或有效的所有标识符），更精准一点，叫做上下文（context）或当前执行环境（environment）。作用域就是变量与函数的可访问范围。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。</p>

<p>在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是 scope，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>

<p>当一个函数创建后，它的作用域链，会被创建此函数的作用域中可访问的数据对象填充。</p>

<p><a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html">参考</a></p>

<h3>* JS事件委托</h3>

<h3>* this</h3>

<p>this不是author-time binding，而是 runtime binding。
this的上下文基于函数调用的情况。和函数在哪定义无关，而和函数怎么调用有关。
this在具体情况下的分析：</p>

<ol>
<li><p>在全局上下文（任何函数以外），this指向全局对象。
<code>
console.log(this === window); // true
</code></p></li>
<li><p>在函数内部时，this由函数怎么调用来确定。</p></li>
</ol>


<h4>2.1</h4>

<p>简单调用,this必须指向对象，那么默认就指向全局对象。</p>

<pre><code>function f1(){
  return this;
}
f1() === window; // global object
</code></pre>

<p>在严格模式下，this保持进入execution context时被设置的值。如果没有设置，那么默认是undefined。它可以被设置为任意值**（包括null/undefined/1等等基础值，不会被转换成对象）</p>

<pre><code>function f2(){
  "use strict"; 
  return this;
}
f2() === undefined;
</code></pre>

<h4>2.2</h4>

<p>当函数作为对象方法调用时，this指向该对象。</p>

<pre><code>var o = {
  prop: 37,
  f: function() {
    return this.prop;
  }
};
console.log(o.f()); // logs 37
</code></pre>

<h4>2.3</h4>

<p>在构造函数（函数用new调用）中，this指向要被constructed创建的新对象。</p>

<h4>2.4</h4>

<p>Function.prototype上的call和apply可以指定函数运行时的this。</p>

<pre><code>function add(c, d){
  return this.a + this.b + c + d;
}

var o = {a:1, b:3};
add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16
add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34
</code></pre>

<p>注意，当用call和apply而传进去作为this的不是对象时，将会调用内置的ToObject操作转换成对象。所以4将会装换成new Number(4)，而null/undefined由于无法转换成对象，全局对象将作为this。</p>

<h4>2.5 bind</h4>

<p>ES5引进了Function.prototype.bind。f.bind(someObject)会创建新的函数（函数体和作用域与原函数一致），但this被永久绑定到someObject，不论你怎么调用。</p>

<h4>2.6 As a DOM event handler</h4>

<p>this自动设置为触发事件的dom元素。</p>

<p><a href="http://www.cnblogs.com/yuanzm/p/4150558.html">参考</a></p>

<h3>* 拖拽实现</h3>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
        var params = {
            left: 0,
            top: 0,
            currentX: 0,
            currentY: 0,
            flag: false
        };
        var getCss = function(o,key){
            return o.currentStyle? o.currentStyle[key] : document.defaultView.getComputedStyle(o,false)[key];
        };

        var startDrag = function(bar, target, callback){
            if(getCss(target, "left") !== "auto"){
                params.left = getCss(target, "left");
            }
            if(getCss(target, "top") !== "auto"){
                params.top = getCss(target, "top");
            }
            bar.onmousedown = function(event){
                params.flag = true;
                if(!event){
                    event = window.event;
                    bar.onselectstart = function(){
                        return false;
                    }
                }
                var e = event;
                params.currentX = e.clientX;
                params.currentY = e.clientY;
            };
            document.onmouseup = function(){
                params.flag = false;
                if(getCss(target, "left") !== "auto"){
                    params.left = getCss(target, "left");
                }
                if(getCss(target, "top") !== "auto"){
                    params.top = getCss(target, "top");
                }
            };
            document.onmousemove = function(event){
                var e = event ? event: window.event;
                if(params.flag){
                    var nowX = e.clientX, nowY = e.clientY;
                    var disX = nowX - params.currentX, disY = nowY - params.currentY;
                    target.style.left = parseInt(params.left) + disX + "px";
                    target.style.top = parseInt(params.top) + disY + "px";
                }

                if (typeof callback == "function") {
                    callback(parseInt(params.left) + disX, parseInt(params.top) + disY);
                }
            }
        };

    &lt;/script&gt;

&lt;/head&gt;
&lt;body id="box" style="position:absolute; "&gt;
&lt;div style="width: 100px;height: 100px;background-color: red" id="bar"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    var oBox = document.getElementById("box");
    var oBar = document.getElementById("bar");
    startDrag(oBar, oBox);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3>* session</h3>

<pre><code>1，session 在服务器端，cookie 在客户端（浏览器）
2，session 默认被存在在服务器的一个文件里（不是内存）
3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
4，session 可以放在 文件、数据库、或内存中都可以。
5，用户验证这种场合一般会用 session
</code></pre>

<h3>* <a href="http://stackoverflow.com/questions/211383/what-methods-of-clearfix-can-i-use">浮动清除</a></h3>

<h3>* 前端性能优化</h3>

<ol>
<li><a href="http://www.cnblogs.com/autumn123/p/4237286.html">CSS精灵(CSS Sprites)</a>,把网页中一些零散的图片整合到一张图片中，然后通过background-position来定位获取。减少网页请求，设计师修改风格只需在一张图片上操作，没命名困扰，能减少字节(aaa>A)。
改动麻烦，一改全动，要么就新增。</li>
<li><a href="https://yq.aliyun.com/articles/49918">JS文件合并</a></li>
<li>JS延迟加载(setTimeout)，图片延迟按需加载(jquery lazyload)，预加载资源</li>
<li>减少DOM元素数量</li>
<li>避免重定向跳转</li>
<li>减小cookie大小</li>
<li>避免空的src,因为它仍然会发送请求</li>
<li>资源压缩传输（Google protocol buffer）</li>
<li>利用缓存，cache-control,Expires</li>
<li>缓存DNS查找</li>
<li>减少http请求(CSS精灵，文件合并都是为了这个)</li>
<li>浏览器会对同一个域的下载链接数有限制(一般是6个)，所以可以按域名来划分下载内容，增大并发下载数量。</li>
<li><a href="http://kb.cnblogs.com/page/121664/">使用CDN</a>(Content Delivery Network，即内容分发网络,将网站的内容发布到最接近用户的网络"边缘"，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度)</li>
</ol>


<p><a href="https://developer.mozilla.org/en-US/docs/Web">MDN</a></p>

<p><a href="https://leohxj.gitbooks.io/front-end-database/content/index.html">前端参考手册</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ECMAScript 6]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/21/es6/"/>
    <updated>2016-12-21T13:14:56+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/21/es6</id>
    <content type="html"><![CDATA[<h3>Generator 函数</h3>

<p>执行该函数时只是返回一个内部调用栈的指针，然后手动执行 <code>next()</code> 方法进行一次栈里的 <code>yield</code> 表达式。next 方法每次返回一个对象<code>{value: undefined, done: false}</code>
value 的值就是 yield 表达式的值，done 是最有一个yield是否都执行完了。每次调用 next 方法都是在上一次执行的 yield 后再执行下一次的 yield,也就是相当于Generator函数可以暂停，然后继续。next 方法还可以传入一个参数到函数内部，它会替换上一次 yield 的返回值(注意区分不是next方法的放回值，next方法始终是返回一个对象)。也就是说可以用 next方法动态的向函数里传参数，函数的执行时分段的，可以暂停，可以继续。Generator 函数还可以用 for of 进行遍历执行。</p>

<p><strong># 动态传参：</strong> Generator 函数的暂停执行的效果，意味着可以把异步操作写在 yield 语句里面，等到调用 next 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在 yield 语句下面，反正要等到调用next 方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>

<pre><code>      //next 传参
      function* myGenerator() {
          let a = yield 'hello';        //执行test.next('A')后： a = undefined,暂停在此处，等待下一次的next再继续
          let b = yield 'world' + a;    //执行test.next('B')后： a = 'B', b = undefined,暂停在此处，等待下一次的next再继续
          let c = yield 'generator' + b;//执行test.next('C')后： a = 'B', b = 'C', c = undefined ,暂停在此处，等待下一次的next再继续
          return '结束' + c;             //执行test.next('D')后： a = 'B', b = 'C', c = 'D'
        }

        let test = myGenerator();

        test.next('A');  //反回对象： {value: "hello", done: false} ,第一次的next传参是无效的，没意义的！
        test.next('B');  //反回对象： {value: "worldB", done: false}
        test.next('C');  //反回对象： {value: "generatorC", done: false}
        test.next('D');  //反回对象： {value: "结束D", done: true}
</code></pre>

<p><strong># for of  遍历:</strong> 注意，一旦 next 方法的返回对象的done属性为 true，for&hellip;of 循环就会中止，且不包含该返回对象，所以上面代码的 return 语句返回的 4，不包括在 for&hellip;of 循环之中。</p>

<pre><code class="">        function *foo() {
          yield 1;
          yield 2;
          yield 3;
          return 4;
        }
        for (let v of foo()) {
          console.log(v);
        }
        // 1 2 3 
</code></pre>

<p><strong># 捕获外部错误：</strong> Generator 函数还有一个特点，它可以在函数体外抛出错误，然后在函数体内捕获。也可以函数体内抛错，外部捕获。 注意下面 throw 的不同！！</p>

<pre><code>   var g = function* () {
      while (true) {
        try {
          console.log('aaa');
          yield console.log('bbb');
          console.log('ccc');
        } catch (error) {
          console.log('内部捕获', error);
        }
      }
    };

    var i = g();
    i.next();
    try {
      i.throw('a'); //这是迭代器的 throw 方法
    } catch (error) {
      console.log('外部捕获', error);
    }
  //aaa
  //bbb
  //内部捕获 a
  //aaa   //为何这里还会执行 ？？
  //bbb
</code></pre>

<p><strong># 异步操作：</strong>  可以像下面那样就不用函数回调了！只是在异步操作成功后调用next就可以。注意，makeAjaxCall 函数中的 next 方法，必须加上 response 参数，因为 yield 语句构成的表达式，本身是没有值的，总是等于 undefined。</p>

<pre><code>   function* main() {
      var result = yield request("http://some.url");
      var resp = JSON.parse(result);
        console.log(resp.value);
    }

    function request(url) {
      makeAjaxCall(url, function(response){
        it.next(response);
      });
    }

    var it = main();
    it.next();
</code></pre>

<h3>Promise 对象</h3>

<p>Promise 对象是用来处理异步操作流程的，避免了层层嵌套的回调函数。</p>

<pre><code>  const step0 = function () {
      return new Promise(function(resolve, reject) {
          setTimeout(()=&gt;{
            console.log('step 0 处理');
              resolve(); //表示异步处理成功
          },2000);
      });
    };

    const step1 = function () {
      return new Promise(function(resolve, reject) {
        setTimeout(()=&gt;{
          console.log('step 1 处理');
          resolve(); //表示异步处理成功
        },2000);
      });
    };

    function allSuccess() {
        console.log('全部成功了');
    }

    function failed() {
      console.log('失败了');
    }

    step0().then(step1).then(allSuccess,failed);
</code></pre>

<p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>

<pre><code>var p = Promise.all([p1,p2,p3]);
</code></pre>

<p>p的状态由p1、p2、p3决定，分成两种情况。</p>

<ol>
<li>只有p1、p2、p3的状态都变成resolve，p的状态才会变成resolve，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要p1、p2、p3之中有一个被reject，p的状态就变成reject，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li>
</ol>


<p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。与all方法不同的是只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值。</p>

<p><strong>Catch:</strong>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>

<p><strong>注意：</strong>区别一下几种情况：</p>

<pre><code>// 写法一
doSomething().then(function () {
  return doSomethingElse();
}).then(finalHandler);

// 写法二
doSomething().then(function () {
  doSomethingElse();
}).then(finalHandler);

// 写法三
doSomething().then(doSomethingElse()).then(finalHandler);

// 写法四
doSomething().then(doSomethingElse).then(finalHandler);
</code></pre>

<p>写法一finalHandler的参数，是doSomethingElse返回的结果，下面最后会打印出hello.</p>

<pre><code>const doSomething = function () {
      return new Promise(function(resolve, reject) {
        console.log('step 0 处理');
        resolve();
      });
    };

    const doSomethingElse = function () {
       new Promise(function(resolve, reject) {
        console.log('step 1 处理');
        resolve();
      });

       return 'hello'
    };

    function finalHandler(msg) {
        console.log(msg);
    }

    doSomething().then(function () {
      return doSomethingElse();
    }).then(finalHandler);
</code></pre>

<p>写法二的finalHandler回调函数的参数是undefined。写法三的finalHandler回调函数的参数，是doSomethingElse函数返回的回调函数的运行结果。主要是写法三和写法四的区别，三的话doSomethingElse是马上执行，finalHandler拿不到它的返回结果！而四可以拿到它的返回结果。</p>

<pre><code>//三的打印
step 0
setp 1
undefined

//四的打印结果
step 0
setp 1
hello
</code></pre>

<h3>Async 函数</h3>

<p>async函数与Promise、Generator函数一样，是用来取代回调函数、解决异步操作的一种方法。它本质上是Generator函数的语法糖。</p>

<pre><code>  var a = function (){
      return new Promise(function (resolve, reject){
             setTimeout(()=&gt;{
               console.log('处理 a');
                 resolve();
             },1000);
      });
    };

    var b = function (){
      return new Promise(function (resolve, reject){
        setTimeout(()=&gt;{
          console.log('处理 b');
          resolve();
        },1000);
      });
    };

    var gen =async function(){
       await a();
       await b();
      console.log('结束');
    };

     gen();
</code></pre>

<ol>
<li>内置执行器。Generator函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li>
<li>更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>
</ol>


<h4>块级别的 let,const, 不会变量提升，会有暂时性死区。let可变，const常量只能初始化赋值一次。const的指向不能修改，但对象的属性可以修改。注意for循环中用var做临时变量时，循环结束后该临时变量还在！用let就不会。</h4>

<pre><code>var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[0](); // 10 ，全部都是 10   
</code></pre>

<h4>for of遍历，可遍历对象的[key,value],遍历set,map, for in 不行。基于Iterator接口遍历。</h4>

<h4>默认参数，&hellip;不定个数参数，&hellip;对象展开, 不定参数只能放最后，</h4>

<h4>Set,Map,WeakSet,WeakMap</h4>

<h4>对象增强,直接写变量和方法作为对应的属性</h4>

<h4>字符窜模板插值 ${}</h4>

<h4>解构，匹配赋值，var {name:n, age:a} = getUser(); //n=getUser().name, a=getUser().age</h4>

<h4>Symbol，解决属性名冲突问题，始终唯一  Symbol(&lsquo;a&rsquo;) != Symbol(&lsquo;a&rsquo;)</h4>

<h4>Proxy，代理拦截 var p = new Proxy(target, handler); 操作 p 就会被handler代理拦截。</h4>

<h4>语法糖，用 => 定义方法， class 类, 像java似的写代码，<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">注意：</a></h4>

<pre><code>// 加上括弧包着是返回一个对象字面表达式, 注意两种区别 ！
 params =&gt; ({foo: bar})
 params =&gt; { statements }
</code></pre>

<p><strong>下面这种方式定义的方法会自动绑定上下文 this, 所以React可以用这样来代替手动 bind(this)</strong> <a href="https://facebook.github.io/react/docs/handling-events.html">这里</a></p>

<pre><code> &lt;button onClick={this.handleClick}&gt;
  handleClick = () =&gt; {  
    //thist 可用
  }

  //或者 这样也会自动绑定this
  &lt;button onClick={() =&gt; this.handleClick()}&gt;
  handleClick() {
     //this 可用
  }
</code></pre>

<h4>字符编码，之前都是基于 UTF-16 两个字节的编码，length 和 charAt()都是基于这样来读取的。然而 ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。对于那些需要四个字节存储的字符，再用之前的length ， charAt() 来操作就无法正确读取，所以得用新的方法新的方式来统一处理。codePointAt可以正确提取给定位置字符串的对应 Unicode 码.</h4>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">Mozilla MDN 文档</a></p>

<p><a href="http://es6.ruanyifeng.com/#docs/reference">ECMAScript 6 入门</a></p>

<p><a href="http://javascript.ruanyifeng.com/">JavaScript 标准参考</a></p>

<p><a href="https://github.com/irideas/es6features">ES6 Features</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Weex]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/20/weex/"/>
    <updated>2016-12-20T22:14:37+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/20/weex</id>
    <content type="html"><![CDATA[<p>Weex 代码由 template、style、script 三个部分构成。template 里只能有一个根节点，只能是 div, scroller, list 三者之中的一个。</p>

<p>style 样式不要用驼峰写法，用小写横杆分离。数据绑定写法和Vue一样，用两个大括号包着，且template和script里的数据是双向绑定的。双括号里的数据绑定也可以有简单的表达式，如果要复杂计算，用Vue那样的计算型属性。</p>

<pre><code>&lt;script&gt;
  module.exports = {
    data: {
      firstName: 'John',
      lastName: 'Smith'
    },
    computed: {
      fullName: function() {
        return this.firstName + ' ' + this.lastName
      }
    },
    methods: {
      changeName: function() {
        this.firstName = 'Terry'
      }
    }
  }
&lt;/script&gt;
</code></pre>

<p>属性也可以getter setter, 就不再说和Vue一样了，weex就是基于Vue 的。</p>

<pre><code>computed: {
      fullName: {
        get: function() {
          return this.firstName + ' ' + this.lastName
        },

        set: function(v) {
          var s = v.split(' ')
          this.firstName = s[0]
          this.lastName = s[1]
        }
      }
    },
    methods: {
      changeName: function() {
        this.fullName = 'Terry King'
      }
    }
  }
</code></pre>

<p>内嵌 style 样式的值 或者 class 的值等其他属性值也可以 用双大括号动态绑定。class 可以有多个名称，用空格分开。<strong>style 的选取器只支持类选取器！其他如id选取，组合选取器啥的都没有！class name 可以有多个！</strong></p>

<p>onXXX 开头的就是用于绑定事件的特性，特性名中 on 之后的部分就是事件的类型，特性的值就是处理该事件的函数名。函数名外不需要添加语法中的大括号。onclick=&ldquo;toggle"。</p>

<p>可以使用一个特殊的参数 $event，代表事件描述对象，即默认事件处理函数的第一个参数。onclick=&ldquo;update($event, 1, 2)"，onclick="foo&rdquo; 和 onclick=&ldquo;foo($event)&rdquo; 是等价的。</p>

<p>每当一次事件被触发的时候，都会产生一个事件描述对象，该对象会默认作为第一个参数传递给事件处理函数，或以 $event 形参的方式出现在内联事件处理函数中。</p>

<p>每个事件描述对象至少包含以下几个特性：</p>

<pre><code>type (string): 事件名称, 如: click
target (Element): 目标元素
timestamp (number): 事件触发时的时间戳数字
</code></pre>

<p>if, repeat：双括号可以省略。 if=&ldquo;/{/{shown/}/}&rdquo; ,repeat=&ldquo;(k,v) in list&rdquo;.if=&ldquo;condition&rdquo; 和 if=&ldquo;/{/{condition/}/}&rdquo; 都是可以的，两者等价使用。if 不能用在 template 的根组件上，否则将无法被 Weex 正常的识别和处理。</p>

<p>repeat 默认有个index 索引。</p>

<p>当修改 repeat 中的数组时，在写法上会受到一定的限制，具体如下：</p>

<pre><code>直接通过“角标”修改数组的某个项目 (如 this.items[0] = ...) 是不会触发视图自动更新的。
我们在数组的原型上提供了一个额外的方法：this.items.$set(index, item) 来完成相同的事情。
// 和 `this.items[0] = ...` 作用相同，但会自动触发视图更新
this.items.$set(0, { childMsg: 'Changed!'})

直接通过修改 length 来改变数组长度 (如 this.items.length = 0) 也是不会触发视图自动更新的。
我们推荐您直接赋值一个新的空数组把旧的替换掉。

// 和 `this.items.length = 0` 作用相同，但会自动触发视图更新
this.items = []
</code></pre>

<p>默认的 track-by 的值就是数组的索引值。track-by=&ldquo;xxx&rdquo;</p>

<p>static 特性可以一次性把数据设置到模板相应的位置上，但是今后不会随着数据的变化而更新。这样可以减少无谓的数据绑定，有效控制和优化长列表、纯静态页面在运行时的开销。不过也要小心使用不要导致原本需要更新的视图没有触发更新。《div static》</p>

<p>weex 把屏幕都看作是750px，会更具具体设备适配。</p>

<p>子元素样式不会继承父亲的，这和css会继承不一样！！</p>

<pre><code>以一整棵树的方式一次性添加到视图中 (append="tree")，还是
每个子组件都产生一次单独的添加到视图的指令 (append="node")
默认情况下，除了 cell 组件的默认渲染过程是 tree 模式，其它组件都默认按照 node 模式进行渲染。
</code></pre>

<p>在同目录下创建和被封装组件同名的 we 文件之外，在 script 中通过 require 其它目录的 we 文件定义同名组件，在主文件下新增 element name=&ldquo;xxx&rdquo; 标签，name 特性的值为新创建的组件名，其 element 内部的内容是定义该组件的代码。组件各自的 style 是相互独立的，不会担心不同组件中相同的 class name 相互干扰。不论通过父组件把数据传递进来还是在当前组件内部对数据发起修改，只有在组件的 data 选项中明确写明的字段才会被正常的监听。如果自定义组件在父组件中有 id 特性，则可以在父组件上下文中通过 this.$vm(id) 接口来访问该自定义组件的上下文，也可以通过 this.$el(id) 来找到其背后真实的原生组件。</p>

<pre><code> methods: {
      back2Top: function () {
        var el = this.$el('goto-top')
        dom.scrollToElement(el, { offset: 10 })
      }
    }
</code></pre>

<p>data、methods、computed 中的字段是不能相互重复的，因为它们都会通过组件实例的 this 访问到。</p>

<p>this.$vm(id) 方法可以访问自定义子组件的上下文,当前上下文中的 this._parent (将改为 this.$parent)可以获取其父级上下文。</p>

<pre><code> methods: {
      update: function (e) {
        this.$vm('sub').setTitle('Updated')
      }
    }
</code></pre>

<p>从子组件向父组件通信，首先父组件要监听特定类型的自定义事件，而子组件可以使用 this.<em>parent 找到父组件，然后再调用 this.</em>parent.$emit(type, detail) 方法，即可实现自下而上的通信。
this.$on(name, handler) 用于监听name 函数，this.$emit(name, detail) 用于触发name函数，通过event.detail传参数，是个json对象。</p>

<pre><code>//子组件中想触发父组件的 notify 方法。
methods: {
        test: function () {
          this._parent.$emit('notify', {a: 1})
        }
      }
 //父组件中监听 notify 是否被触发，      
 created: function () {
      this.$on('notify', function(event) {
        this.eventType = event.type
        this.eventDetail = JSON.stringify(event.detail)
      })
    }
</code></pre>

<p>从父组件向子组件通信，首先子组件要监听特定类型的自定义事件，而父组件可以使用 this.$vm(id) 找到子组件，然后再调用 this.$vm(id).$emit(type, detail) 方法，即可实现自上而下的通信。</p>

<h4>开发技巧</h4>

<p>官方<code>weex inint xxx</code> 建的项目有点乱，扫一扫等一堆没必要的代码给新手增加复杂度。还是新建一个OC项目，pod 导入Weex:</p>

<pre><code>source 'https://github.com/CocoaPods/Specs.git'

target 'MyWeex_iOS' do
platform :ios, '7.0'
pod 'WeexSDK', '~&gt; 0.8.0'
end
</code></pre>

<p>然后真正需要的代码很少的，不需要扫一扫才能看了!</p>

<pre><code>@interface AppDelegate ()
@end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{
    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
    self.window.backgroundColor = [UIColor whiteColor];

    [WXSDKEngine initSDKEnviroment];

    self.window.rootViewController = [[ViewController alloc] init];
    [self.window makeKeyAndVisible];

    return YES;
}

@end
</code></pre>

<p>然后开启它的监听，<code>weex index.we  -o . --watch</code>，这样每次修改就会自动编译weex文件了，然后Xcode再运行就可以了！把LOCAL_HOST改成本地IP地址就可在真机上运行了。</p>

<pre><code>#import "ViewController.h"
#define LOCAL_HOST @"127.0.0.1"
#define INDEX_URL [NSString stringWithFormat:@"http://%@:8081/weex_tmp/h5_render/index.js",LOCAL_HOST]


@interface ViewController ()

@end

@implementation ViewController
@synthesize instance,weexView;


- (void)viewDidLoad{
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor redColor];

    [self renderView];
}


- (void)dealloc{
    [instance destroyInstance];
}

- (void)renderView{
    CGFloat width = self.view.frame.size.width;
    CGFloat height = self.view.frame.size.height;

    [instance destroyInstance];
    instance = [[WXSDKInstance alloc] init];
    instance.viewController = self;
    instance.frame = CGRectMake(0, 0, width,height);

    __weak typeof(self) weakSelf = self;
    instance.onCreate = ^(UIView *view) {
        [weakSelf.weexView removeFromSuperview];
        weakSelf.weexView = view;
        [weakSelf.view addSubview:weakSelf.weexView];
    };

    instance.onFailed = ^(NSError *error) {
       NSLog(@"%@", @"Render Failed...");
    };

    instance.renderFinish = ^(UIView *view) {
         NSLog(@"%@", @"Render Finish...");

    };

    instance.updateFinish = ^(UIView *view) {
        NSLog(@"%@", @"Update Finish...");
    };

    [instance renderWithURL:[NSURL URLWithString:INDEX_URL] options:nil data:nil];
}
@end
</code></pre>

<p><strong>$dispatch 只能是子组件向父组件通信， $broadcast 只能是父组件向子组件通信，反过来都不行！</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vue]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/19/vue/"/>
    <updated>2016-12-19T11:58:13+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/19/vue</id>
    <content type="html"><![CDATA[<h4>Vue</h4>

<p><a href="https://cn.vuejs.org/">Vue</a>是一个JavaScript MVVM库，它是以<strong>数据驱动和组件化</strong>的思想构建的。相比于Angular，Vue提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue。因为Vue是数据驱动的，所以无需手动操作DOM。它通过一些特殊的HTML语法，将DOM和数据绑定起来。一旦创建了绑定，DOM将和数据保持同步，每当变更了数据，DOM也会相应地更新。当然了，在使用Vue的同时时，也可以结合其他库一起使用，比如jQuery。
<img src="/myimg/js/vue.png" alt="" /></p>

<p>ViewModel是Vue的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。当创建了ViewModel后，数据就已经双向绑定好了。如上图所示：可以将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。</p>

<ol>
<li>从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据。</li>
<li>从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。</li>
</ol>


<p>Vue也像Angular似的，是通过扩展元素的属性来处理的，扩展的属性被称为<code>指令</code>，如 v-model, v-if, v-else, v-bind ,v-show 等。</p>

<p><img src="/myimg/js/vue1.png" alt="" />
组件系统是 Vue.js 另一个重要概念，就像上图所示，把一个个 <code>Vue</code> 组件组合起来就可以了，各个组件都是一个独立的个体，就像搭积木一样。</p>

<p><strong>v-model ：</strong> 可以绑定表单元素如imput,select,textarea的值.下面将input元素的值和message绑定。1：当文本框的值改变时，<code>/{/{ message /}/}</code>会自动更新，2：当message的值改变时，文本框的值也会被更新, 这就叫数据双向绑定。(忽略/,因为MarkDown转化不了所以加的)</p>

<pre><code>&lt;div id="app"&gt;
    &lt;p&gt;/{/{ message /}/}&lt;/p&gt;
    &lt;input type="text" v-model="message"/&gt;
&lt;/div&gt;
</code></pre>

<p><strong>v-if ：</strong> 是条件渲染指令，它根据表达式的真假来删除和插入元素。如<code>&lt;h1 v-if="age &gt;= 25"&gt;Age = &lt;/h1&gt;</code>,当age&lt;25时，整个h1元素都不显示，而且就html就没有该节点，不像<code>v-show</code>是有该节点，然后设置节点 display = none。</p>

<p><strong>v-show :</strong> 也是条件渲染指令，和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性是不是style=&ldquo;display:none"。</p>

<p><strong>v-else :</strong>v-else元素必须立即跟在v-if或v-show元素的后面，否则它不能被识别。</p>

<pre><code>&lt;div id="app"&gt;
    &lt;h1 v-if="age &gt;= 25"&gt;Age: &lt;/h1&gt;
    &lt;h1 v-else&gt;age不大于25&lt;/h1&gt;

    &lt;h1 v-show="age &gt;= 25"&gt;Age: &lt;/h1&gt;
    &lt;h1 v-else&gt;age不大于25&lt;/h1&gt;
&lt;/div&gt;
</code></pre>

<p>上面代码中如果age大于25，后面的v-else都不会渲染到HTML。</p>

<p><strong>v-for :</strong> 基于一个数组渲染一个列表，它和JavaScript的遍历语法相似.可以用 <code>in</code>代替。</p>

<pre><code>&lt;tr v-for="person in personArray"&gt;
  &lt;td&gt;/{/{ person.name}}&lt;/td&gt; &lt;td&gt;/{/{ person.age}}&lt;/td&gt;
&lt;/tr&gt;
</code></pre>

<p><strong>v-bind :</strong>可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是元素的属性值设置，如 <code>&lt;h1 v-bind="class:age&gt;=25?'old':'young'"&gt;class 属性值设置&lt;/h1&gt;</code>,当age大于25，class=old,否则class=young。</p>

<p><strong>v-on :</strong>用于绑定DOM事件，如<code>&lt;h1 v-on:click="showAlert"&gt;点击&lt;/h1&gt;</code>，再在methods里实现对应方法名的方法。</p>

<pre><code>methods: {
 showAlert: function() {
     alert("点击啦！！")
  }
}
</code></pre>

<p>v-bind指令可以缩写为一个冒号 <code>:</code>，v-on指令可以缩写为<code>@</code>符号。</p>

<p><code>v-bind:class="xxx"</code> &ndash;> <code>:class="xxx"</code>,  <code>v-on:click="showAlert"</code> &ndash;> <code>@click="greet"&gt;</code></p>

<p>下面是自定义一个组件叫my-component.像React似的，也是通过<code>props</code>来传参数值。v-bind 意思是给属性绑定值，下面是给item 属性绑定 data, 而 item 这个属性名字是在 <code>props: ['item'],</code> 这里定义的，data 是前面 v-for 从dataArray 里取出来的。</p>

<pre><code>&lt;div id="app"&gt;
    &lt;ol&gt;
        &lt;my-component v-for="data in dataArray" v-bind:item="data" /&gt;
    &lt;/ol&gt;
&lt;/div&gt;

&lt;script&gt;
    Vue.component('my-component', {
        props: ['item'],
        template: '&lt;li&gt;&lt;/li&gt;'
    })
    var app = new Vue({
        el: '#app',
        data: {
            dataArray: [
                {text: 'hello'},
                {text: 'world'},
            ]
        }
    })
&lt;/script&gt;
</code></pre>

<p>Vue 的生命周期函数有 init,created,ready,mounted,updated,destroyed等。
<img src="/myimg/js/lifecycle.png" width="400" alt="" /></p>

<p><strong>v-once :</strong> 使用这个指令的话值只会插入一次，之后数据再改变就不会更新了，这会影响到该节点上所有的数据绑定。</p>

<p>双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 v-html 指令。</p>

<p>像Angular一样，也有过滤器，或自定义过滤器： message | capitalize 。过滤器函数总接受表达式的值作为第一个参数。</p>

<pre><code>filters: {
    capitalize: function (value) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }
</code></pre>

<p>在 <code>computed</code> 添加计算型属性：下面是一个计算型属性myMsg, 通过获取data中的msg属性来处理，然后返回处理结果。通过<code>methods</code>里定义方法也能达到相同的效果，但<strong>计算属性是基于它的依赖缓存。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 msg 没有发生改变，多次访问 myMsg 计算属性会立即返回之前的计算结果，而不必再次执行函数。而 method 调用总会执行函数。</strong></p>

<pre><code> computed: {
    myMsg: function () {
      return this.msg.split('').reverse().join('')
    }
  }
</code></pre>

<p>还有 <code>watch</code> 它用于观察 Vue 实例上的数据变动。下面是观察msg,如果msg变动就会执行方法给myMsg赋值。方法是异步操作。</p>

<pre><code>watch: {
    msg: function (val) {
      this.myMsg = val + 'hello'
    },
  }
</code></pre>

<p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：</p>

<pre><code>computed: {
  myMsg: {
    get: function () {
      return "xxx"
    },
    set: function (newValue) {
      //do something
    }
  }
}
</code></pre>

<p><strong>v-bind</strong>增强版 1.<code>&lt;div v-bind:class="{ active: isActive }"&gt;&lt;/div&gt;</code>,如果isActive为true,calss = active.</p>

<p>2.<code>&lt;div v-bind:class="classObject"&gt;&lt;/div&gt;</code> 直接绑定一个对象。当在一个<strong>定制</strong>的组件上用到 class 属性的时候，这些类将被添加到<strong>根元素</strong>上面，这个元素上已经存在的类不会被覆盖。</p>

<pre><code>data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
</code></pre>

<p>对象语法，v-bind:style 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。 CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）：</p>

<pre><code>//1.
&lt;div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"&gt;&lt;/div&gt;
data: {
  activeColor: 'red',
  fontSize: 30
}

//2.
&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt;
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
</code></pre>

<p>Vue 会复用已有元素而不是从头开始渲染。可通过设置key 值来唯一区分，就不会复用了。这个类似 Vue 1.x 的 track-by=&ldquo;$index&rdquo; 。</p>

<p>下面的数组方法也会触发刷新,而filter(), concat(), slice() 。这些不会改变原始数组，但总是返回一个新数组。</p>

<pre><code>push()
pop()
shift()
unshift()
splice()
sort()
reverse()
</code></pre>

<p>事件修饰符：</p>

<pre><code>.once
.stop //阻止事件冒泡
.prevent //取消事件默认处理
.capture //开启事件捕获
.self
.once
.ctrl
.alt
.shift
.meta
</code></pre>

<p>按键别名：可以通过全局 config.keyCodes 对象自定义按键修饰符别名。(Vue.config.keyCodes.f1 = 112)</p>

<pre><code>.enter
.tab
.delete (捕获 “删除” 和 “退格” 键)
.esc
.space
.up
.down
.left
.right
</code></pre>

<p>由于 JavaScript 的限制， Vue 不能检测以下变动的数组：当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue当你修改数组的长度时，例如： vm.items.length = newLength为了避免第一种情况，以下两种方式将达到像 vm.items[indexOfItem] = newValue 的效果， 同时也将触发状态更新：</p>

<pre><code>1.Vue.set(example1.items, indexOfItem, newValue)
2.example1.items.splice(indexOfItem, 1, newValue)
</code></pre>

<p>避免第二种情况，使用 splice：<code>example1.items.splice(newLength)</code></p>

<pre><code>//自定义全局组件
Vue.component('my-component', {

})
//自定义局部组件
var Child = {
  template: '&lt;div&gt;A custom component!&lt;/div&gt;'
}
new Vue({
  components: {
    // &lt;my-component&gt; 将只在父模板可用
    'my-component': Child
  }
})
</code></pre>

<p>父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。prop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 props 选项声明 “prop”。prop的名字形式会从 camelCase 转为 kebab-case。（myMessage &ndash;> my-message）</p>

<p>prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。</p>

<p>改变 prop 可通过两种方法曲线救国：就像React props也不应该修改，而是修改state里的属性一样。</p>

<pre><code>1.prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；
2.prop 作为需要被转变的原始值传入。
</code></pre>

<p>像React一样，props也可以指定类型：String，Number，Boolean，Function，Object，Array。type 也可以是一个自定义构造器，使用 instanceof 检测。</p>

<pre><code> props: {
    // 基础类型检测 （`null` 意思是任何类型都可以）
    propA: Number,
    // 多种类型
    propB: [String, Number],
    // 必传且是字符串
    propC: {
      type: String,
      required: true
    },
    // 数字，有默认值
    propD: {
      type: Number,
      default: 100
    },
    // 数组／对象的默认值应当由一个工厂函数返回
    propE: {
      type: Object,
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        return value &gt; 10
      }
    }
  }
</code></pre>

<p>父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！
<code>
使用 $on(eventName) 监听事件
使用 $emit(eventName) 触发事件
</code>
自定义组件模板：</p>

<pre><code>&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;my-component v-bind:my-name="name" v-bind:my-age="age"&gt;&lt;/my-component&gt;
    &lt;/div&gt;

    &lt;template id="myComponent"&gt;
        &lt;table&gt;
            &lt;tr&gt;
                &lt;th colspan="2"&gt;
                    子组件数据
                &lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;my name&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;my age&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/template&gt;
&lt;/body&gt;

&lt;script&gt;
    var vm = new Vue({
        el: '#app',
        data: {
            name: 'andy',
            age: 18
        },
        components: {
            'my-component': {
                template: '#myComponent',
                props: ['myName', 'myAge']
            }
        }
    })
&lt;/script&gt;

-------------------------------
&lt;script type="text/x-template" id="myCom"&gt;
  &lt;div&gt;
    &lt;p&gt;hello&lt;/p&gt;
  &lt;/div&gt;
&lt;/script&gt;

Vue.component('my-com', {
  template: '#myCom',
})                          
</code></pre>

<p>v-bind:my-name.sync=&ldquo;name&rdquo; 这是用在子组件属性中 .sync 意思是子组件的数据会影响父组件，默认是不会的的。</p>

<p>.once 用子子组件属性中，表示只绑定一次父组件的数据。</p>

<p>熟悉值不能用双括号绑定值，只能用 v-bind 绑定。在 v-bind 用于 class 和 style 属性时， 表达式的结果类型除了字符串之外，还可以是对象或数组。</p>

<p>计算型属性与方法的区别是： 计算型属性会有缓存依赖，不是每次都会执行，只有值变了才执行。而方法是每次都执行。</p>

<p>Vue 会复用控件，用key属性来区分不同控件。v-bind:key = &ldquo;$index&rdquo; 相当于Vue 1.x 的 track-by=&ldquo;$index&rdquo; 。</p>

<p>注意 v-show 不支持 template 语法。 template 用 v-if . 主要 show 与 if 的区别，show 都有node，只是设置 display 属性。</p>

<p>v-for 迭代对象的话是迭代对象的值。 自定义组件使用v-for 值也不会自动传到组件里去，而要v-bind:item=&ldquo;item"，然后组件里用props: [&lsquo;item&rsquo;] 接收。
不自动注入 item 到组件里的原因是，因为这使得组件会紧密耦合到 v-for 如何运作。在一些情况下，明确数据的来源可以使组件可重用。</p>

<p>方法调用的时候可以用特殊变量 $event 把事件传入方法里。</p>

<p>v-model 指令在表单控件元素上创建双向数据绑定。它会根据<code>控件类型</code>自动选取正确的方法来更新元素。input,textarea,select，单选框，复选框。</p>

<p>对于限制性元素，可以用 is  来代替。如：</p>

<pre><code>&lt;table&gt;
  &lt;tr is="my-row"&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>

<p>is 还可以用来动态绑定组件：</p>

<pre><code>&lt;component v-bind:is="currentView"&gt;&lt;/component&gt;

var vm = new Vue({
  el: '#example',
  data: {
    currentView: 'archive'
  },
  components: {
    home: { 
        template: '&lt;p&gt; home ------ &lt;/&gt;'
    },
    posts: { 
         template: '&lt;p&gt; posts ------&lt;/&gt;'
     },
    archive: { 
         template: '&lt;p&gt; archive ------&lt;/&gt;'
    }
  }
})
</code></pre>

<p>自定义组件里 data 必须是函数：</p>

<pre><code> data: function () {
    return {
       key: value,
       key: value,
       key: value,
    }
  }
</code></pre>

<p>父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。
不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。</p>

<p>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</p>

<h3>基本使用</h3>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;script src="./vue.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id="app"&gt;
  &lt;ol v-once&gt;
    &lt;todo-item v-for="item in groceryList" v-bind:todo="item"&gt;&lt;/todo-item&gt;
  &lt;/ol&gt;

&lt;template v-if="seen"&gt;
    &lt;p  v-on:click = "helloTap"&gt;  &lt;/p&gt;
&lt;/template&gt;
&lt;p v-else&gt; show else&lt;/p&gt;

&lt;my-com msg = "my component" v-on:increment = "increments"&gt;&lt;/my-com&gt;
&lt;my-com2 msg = "my component2"&gt;&lt;/my-com2&gt;

&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
var bus = new Vue();

Vue.component('todoItem', {
  props: ['todo'],
  template: '&lt;li&gt;&lt;/li&gt;',

   filters: {
    capitalize: function (value) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }

})

var vm = new Vue({
  el: '#app',

  data: {
    groceryList: [
      { text: 'aegetables' },
      { text: 'cheese' },
      { text: 'Whatever else humans are supposed to eat' }
    ],
     msg: "hello",
     seen: true
  },

  computed:{
    rMsg: function () {
      return this.msg.split('').reverse().join('')
    }
  },

  methods:{
    helloTap: function(){
        alert("hello");
    },
     increments: function(){
        alert("helloss");
    }
  },

  components:{
    'my-com':{
      props: ['msg'],

data: function () {
  return {
    innerData: 'innerData  hello',
  }
},

  methods: {
    increment: function () {
      this.$emit('increment')
    }
  },

       template: '&lt;div&gt;&lt;p&gt;&lt;/p&gt;  &lt;p&gt;&lt;/p&gt;&lt;/div&gt;',
    },

    'my-com2':{
      props: ['msg'],
       template: '&lt;p&gt;&lt;/p&gt;',
    },

  },

 filters: {
    capitalize: function (value) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  },

   beforeCreate:function(){
    console.log("----------beforeCreate");
  },
  created:function(){
    console.log("----------created");
  },
   beforeMount:function(){
    console.log("----------beforeMount");
  },
   mounted:function(){
    console.log("----------mounted");
  },
   beforeUpdate:function(){
    console.log("----------beforeUpdate");
   },
  updated:function(){
    console.log("----------updated");
  },
  beforeDestroy:function(){
    console.log("----------destroyed");
  },
  destroyed:function(){
    console.log("----------destroyed");
  },

  watch:{
    groceryList: function(newValue){
     console.log("--------------groceryList变了1");
    }
  }

})

vm.$watch('groceryList', function (newVal, oldVal) {
   console.log("--------------groceryList变了2");
})

&lt;/script&gt;

&lt;/html&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/03/node-js/"/>
    <updated>2016-12-03T10:24:36+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/03/node-js</id>
    <content type="html"><![CDATA[<p><a href="http://www.nodebeginner.org/index-zh-cn.html#javascript-and-nodejs">Node 入门</a> <strong>墙裂推荐！</strong></p>

<p>Node.js是单线程的，它通过事件轮询（event loop）来实现并行操作。</p>

<p><strong>它是这样处理的：“嘿，longTimeFunction(),你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”</strong>  JavaScript都是基于这样单线程的事件回调来处理异步的。</p>

<p><strong>相对采用将内容传递给服务器的方式，采用将服务器“传递”给内容的方式来实现异步。就是将response对象通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。</strong></p>

<p>下面是上传图片显示图片的 <a href="/mysrc/java/node.zip">Demo:</a></p>

<p>index.js</p>

<pre><code>var server = require("./server");
var router = require("./router");
var requestHandlers = require("./requestHandlers");

var handle = {}
handle["/"] = requestHandlers.start;
handle["/start"] = requestHandlers.start;
handle["/upload"] = requestHandlers.upload;
handle["/show"] = requestHandlers.show;

server.start(router.route, handle);
</code></pre>

<p>router.js</p>

<pre><code>function route(handle, pathname, response, request) {
  if (typeof handle[pathname] === 'function') {
    handle[pathname](response, request);
  } else {
    response.writeHead(404, {"Content-Type": "text/html"});
    response.write("404 Not found");
    response.end();
  }
}
exports.route = route;
</code></pre>

<p>server.js</p>

<pre><code>var http = require("http");
var url = require("url");

function start(route, handle) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    route(handle, pathname, response, request);
  }
  http.createServer(onRequest).listen(8888);
}
exports.start = start;
</code></pre>

<p>requestHandlers.js</p>

<pre><code>var querystring = require("querystring"),
    fs = require("fs"),
    formidable = require("formidable");

function start(response) {
  var body = '&lt;html&gt;'+
    '&lt;head&gt;'+
    '&lt;meta http-equiv="Content-Type" content="text/html; '+
    'charset=UTF-8" /&gt;'+
    '&lt;/head&gt;'+
    '&lt;body&gt;'+
    '&lt;form action="/upload" enctype="multipart/form-data" '+
    'method="post"&gt;'+
    '&lt;input type="file" name="upload" multiple="multiple"&gt;'+
    '&lt;input type="submit" value="确定上传" /&gt;'+
    '&lt;/form&gt;'+
    '&lt;/body&gt;'+
    '&lt;/html&gt;';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();
}

function upload(response, request) {
  var form = new formidable.IncomingForm();
  form.parse(request, function(error, fields, files) {
    fs.renameSync(files.upload.path, "./tmp/test.png");
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write("received image:&lt;br/&gt;");
    response.write("&lt;img src='http://andyfightting.github.io/show' /&gt;");
    response.end();
  });
}

function show(response) {
  fs.readFile("./tmp/test.png", "binary", function(error, file) {
    if(error) {
      response.writeHead(500, {"Content-Type": "text/plain"});
      response.write(error + "\n");
      response.end();
    } else {
      response.writeHead(200, {"Content-Type": "image/png"});
      response.write(file, "binary");
      response.end();
    }
  });
}

exports.start = start;
exports.upload = upload;
exports.show = show;
</code></pre>

<p>运行： <code>cd node</code> <code>node index.js</code></p>

<p>Node.js 是运行在服务端的 JavaScript。Node.js 应用是由几部分组成的：</p>

<pre><code>1. 引入 require 模块：可以使用 require 指令来载入 Node.js 模块。
2. 创建服务器：服务器可以监听客户端的请求
3. 接收请求与响应请求: 可以使用浏览器或客户端发送 HTTP 请求，服务器接收请求后返回响应数据。
</code></pre>

<h4>Hello World</h4>

<p>创建一个test.js文件，里面输入如下内容。终端进入文件所在文件夹，执行<code>node test.js</code>,浏览器地址栏输入<code>http://127.0.0.1:8888/</code>就可以看到Hello World了。</p>

<pre><code>//引用http模块
var http = require('http');
http.createServer(function (request, response) {
    // 发送 HTTP 头部 
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, {'Content-Type': 'text/plain'});
    // 发送响应数据 "Hello World"
    response.end('Hello World！\n');
}).listen(8888);
</code></pre>

<h4>NPM</h4>

<p>npm 是js包管理工具，像 CocoaPods 似的可以下载被人编写的第三方包，也可以把自己写的包上传的npm服务器。</p>

<p><code>npm install 包名</code> 本地安装,将安装包放在 ./node_modules 下，如果没有 node_modules 文件夹，会在当前执行 npm 命令的目录下生成 node_modules 文件夹。然后就可以通过require(包名) 来引入本地安装的包。</p>

<p><code>npm install 包名字 -g</code> 全局安装，将安装包放在 /usr/local 下或者 node 的安装目录。</p>

<p><code>npm uninstall 包名</code> 卸载包</p>

<p><code>npm update 包名</code> 更新包</p>

<p><code>npm search 包名</code> 搜索包</p>

<h4>package.json</h4>

<p>package.json 用于表示需要安装的包的属性，如名字，版本，依赖等。package.json 文件是必不可少的。可通过<code>npm init</code>创建该文件。</p>

<pre><code>//Package.json 属性说明
name - 包名。
version - 包的版本号。
description - 包的描述。
homepage - 包的官网 url 。
author - 包的作者姓名。
contributors - 包的其他贡献者姓名。
dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。
repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。
main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require("express")。
keywords - 关键字
</code></pre>

<h4>回调函数</h4>

<p>Node.js 异步编程的直接体现就是回调。Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>

<pre><code>//顺序执行
var fs = require("fs");
var data = fs.readFileSync('input.txt');
console.log(data.toString());
console.log("程序执行结束!");

//异步回调
var fs = require("fs");
fs.readFile('input.txt', function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});
console.log("程序执行结束!");
</code></pre>

<h4>事件驱动</h4>

<p>Node.js 每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用并处理并发。基本上所有的事件机制都是用观察者模式实现。当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。
当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p>

<p><img src="/myimg/react/reactevent.png" width="400" alt="" /></p>

<p>在 Node 应用程序中，执行异步操作将回调函数作为最后一个参数， 回调函数里接收错误的对象作为回调函数的第一个参数。</p>

<pre><code>//回调函数是readFile的最后一个参数，err是回调函数的第一个参数
var fs = require("fs");
fs.readFile('input.txt', function (err, data) {
   if (err){
      console.log(err.stack);
      return;
   }
   console.log(data.toString());
});
console.log("程序执行完毕");
</code></pre>

<p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。许多对象都会分发事件，如一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是基于 events.EventEmitter 的实例。</p>

<p>events 模块只提供了一个对象： events.EventEmitter(事件分发器)。EventEmitter 的核心就是事件触发与事件监听器功能的封装。
可以通过require(&ldquo;events&rdquo;);来访问该模块。EventEmitter 对象如果在实例化时发生错误，会触发 &lsquo;error&rsquo; 事件。当添加新的监听器时，'newListener' 事件会触发，当监听器被移除时，'removeListener' 事件被触发。EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>

<pre><code>var events = require('events'); 
var emitter = new events.EventEmitter(); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener1', arg1, arg2); 
}); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener2', arg1, arg2); 
}); 
emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); 

//打印出
//listener1 arg1 参数 arg2 参数
//listener2 arg1 参数 arg2 参数
</code></pre>

<h4>EventEmitter 方法</h4>

<pre><code>addListener(eventName, listenerFun): 为指定事件添加一个监听器到监听器数组的尾部。
on(eventName, listenerFun):为指定事件注册一个监听器，接受一个字符串 eventName 和一个回调函数。
once(eventName, listenerFun): 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。
removeListener(eventName, listenerFun):移除指定事件的某个监听器，监听器 必须是该事件已经注册过的监听器。
removeAllListeners([eventName]):移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。
setMaxListeners(n)：默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。
listeners(eventName)：返回指定事件的监听器数组。
emit(eventName, [arg1], [arg2], [...]):按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。
listenerCount(emitter, eventName):类方法，返回指定事件的监听器数量。
</code></pre>

<p>实例：</p>

<pre><code>var events = require('events');
var eventEmitter = new events.EventEmitter();

// 监听器1   
var listener1 = function listener1() {
   console.log('监听器 listener1 执行。');
}

// 监听器2       
var listener2 = function listener2() {
  console.log('监听器 listener2 执行。');
}

// 绑定 connection 事件，处理函数为 listener1 
eventEmitter.addListener('connection', listener1);

// 绑定 connection 事件，处理函数为 listener2
eventEmitter.on('connection', listener2);

var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');
console.log(eventListeners + " 个监听器监听连接事件。");

// 处理 connection 事件 
eventEmitter.emit('connection');

// 移除监绑定的 listener1 函数
eventEmitter.removeListener('connection', listener1);
console.log("listener1 不再受监听。");

// 触发连接事件
eventEmitter.emit('connection');

eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');
console.log(eventListeners + " 个监听器监听连接事件。");

console.log("程序执行完毕。");

//打印结果
//2 个监听器监听连接事件。
//监听器 listener1 执行。
//监听器 listener2 执行。
//listener1 不再受监听。
//监听器 listener2 执行。
//1 个监听器监听连接事件。
//程序执行完毕
</code></pre>

<h5>error 事件</h5>

<p>EventEmitter 定义了一个特殊的事件<code>error</code>，它包含了错误的语义，在遇到异常的时候通常会触发 error 事件。
当 error 被触发时，如果没有对应的监听器就会把它当作异常，退出程序并输出错误信息。
所以要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。</p>

<p>大多数时候不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，
只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>

<h4>Buffer 类</h4>

<p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理文件流时，必须使用到二进制数据。
所以在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。可以让 Node.js 处理二进制数据，
每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。
一个 Buffer 类似于一个整数数组，utf-8 是默认的编码方式。</p>

<pre><code>//写数据
buf.write(string, offset, length, encoding)；
string - 写入缓冲区的字符串。
offset - 缓冲区开始写入的索引值，默认为 0 。
length - 写入的字节数，默认为 buffer.length。
encoding - 使用的编码。默认为 'utf8' 。
返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。

//读数据
buf.toString(encoding, start, end)；
encoding - 使用的编码。默认为 'utf8' 。
start - 指定开始读取的索引位置，默认为 0。
end - 结束位置，默认为缓冲区的末尾。
返回值是用指定的编码返回字符串。
</code></pre>

<h5>常用方法</h5>

<pre><code>new Buffer(size)：配一个新的 size 大小单位为8位字节的 buffer。
new Buffer(buffer)：拷贝参数 buffer 的数据到 Buffer 实例。
new Buffer(str, encoding)分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 'utf8'。
buf.length: 返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。
buf.write(string[, offset[, length]][, encoding]):写入数据。
buf.toJSON()：将 Buffer 实例转换为 JSON 对象。
buf.equals(otherBuffer)：比较两个缓冲区是否相等。
buf.compare(otherBuffer):比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。
buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]):buffer 拷贝，源和目标可以相同。 
targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。
</code></pre>

<h4>Stream 流</h4>

<p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。
<strong>所有的 Stream 对象都是 EventEmitter 的实例</strong></p>

<pre><code>Stream 有四种流类型：
1. Readable - 可读操作。
2. Writable - 可写操作。
3. Duplex - 可读可写操作.
4. Transform - 操作被写入数据，然后读出结果。

所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：
data - 当有数据可读时触发。
end - 没有更多的数据可读时触发。
error - 在接收和写入过程中发生错误时触发。
finish - 所有数据已被写入到底层系统时触发。
</code></pre>

<p>读取文件例子：</p>

<pre><code>var fs = require("fs");
var data = '';

// 创建可读流
var readerStream = fs.createReadStream('input.txt');

// 设置编码为 utf8。
readerStream.setEncoding('UTF8');

// 处理流事件 --&gt; data, end, and error
readerStream.on('data', function(chunk) {
   data += chunk;
});

readerStream.on('end',function(){
   console.log(data);
});

readerStream.on('error', function(err){
   console.log(err.stack);
});

console.log("程序执行完毕");
</code></pre>

<h4>模块系统</h4>

<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。一个 Node.js 文件就是一个模块，这个文件可能是JavaScript、JSON 或者编译过的C/C++ 扩展等。
Node.js 提供了<code>exports</code> 和 <code>require</code> 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p>

<p>require方法中的文件查找策略：</p>

<p><img src="/myimg/react/require.png" width="400" alt="" /></p>

<h4>函数</h4>

<p>在JavaScript中，一个函数可以作为另一个函数的参数。可以先定义一个函数变量，然后传递，也可以在传递参数的地方直接定义函数(不要名字的函数，匿名函数)。</p>

<pre><code>function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, "Hello");

//也可以直接传递匿名函数

function execute(someFunction, value) {
  someFunction(value);
}

execute(function(word){ console.log(word) }, "Hello");
</code></pre>

<h4>全局对象</h4>

<p>JavaScript 中有一个特殊的对象，称为全局对象，它及其所有属性都可以在程序的任何地方访问，即全局变量。
在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。
在 Node.js 可以直接访问到 global 对象的属性，而不需要在应用中包含它。<strong>注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。</strong></p>

<pre><code>满足以下条 件的变量是全局变量：
1.在最外层定义的变量；
2.全局对象的属性；
3.隐式定义的变量（未定义直接赋值的变量）。
</code></pre>

<p><strong>__filename ：</strong>表示当前正在执行的文件名,输出文件的绝对路径。</p>

<p><strong>__dirname ：</strong>表示当前正在执行的文件目录。</p>

<p><strong>setTimeout(cb, ms) :</strong> 全局函数,在指定的毫秒(ms)数后执行指定函数(cb)。只执行一次指定函数。返回一个代表定时器的句柄值。</p>

<p><strong>clearTimeout(t) :</strong> 全局函数,用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。</p>

<p><strong>setInterval(cb, ms) :</strong>setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。
返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。
setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</p>

<p><strong>console :</strong> 全局对象，常用方法有<code>console.log()</code>,<code>console.info()</code>,<code>console.warn()</code>,<code>console.error()</code></p>

<p><strong>process :</strong>全局变量，即 global 对象的属性。便于我们更好的控制系统的交互,很多属性和方法。<code>process.stdout</code>,<code>process.exet()</code>&hellip;</p>

<p><a href="https://nodejs.org/dist/latest-v7.x/docs/api/">Node.js API</a></p>
]]></content>
  </entry>
  
</feed>
