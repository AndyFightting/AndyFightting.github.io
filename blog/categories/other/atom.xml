<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Other | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/other/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-12-03T16:08:10+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Struts + Spring + MyBatis]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/18/struts-spring-mybatis/"/>
    <updated>2016-11-18T09:22:51+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/18/struts-spring-mybatis</id>
    <content type="html"><![CDATA[<h4>基本信息：</h4>

<p><code>Mac OS 10.11</code>, <code>eclipse neon</code>, <code>jdk1.8</code>, <code>tomcat7</code>, <code>struts2.5.5</code>, <code>spring4.3.4</code>, <code>mybatis3.4.1</code>,<code>mybatis-spring1.3</code>,<code>mysql数据库</code></p>

<h4>结构简介：</h4>

<pre><code>用struts2的配置文件来控制方法的调用和页面的跳转，
jps和Action通过strtus2标签方式或者EL表达式传值取值。
Action负责业务逻辑处理，Action调用Service接口，Service接口注入某个Service的实现，
在Service的实现里调用Dao来处理数据库。
而Dao是用Mybatis通过对应的xml映射文件来关联的,
且Action里的Service实现注入,Service实现类里的Dao注入,Dao的Section注入，
都是通过Spring配置文件实现的。
</code></pre>

<h4>截图:</h4>

<p><img src="/myimg/java/ssm_index.png" alt="" />
<img src="/myimg/java/ssm_list.png" alt="" />
<img src="/myimg/java/ssm_json.png" alt="" />
<img src="/myimg/java/ssm.png" alt="" /></p>

<p><a href="/mysrc/java/SSM.zip">下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringMVC + Spring + Hibernate]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/17/springmvc-hibernate-jian/"/>
    <updated>2016-11-17T19:34:43+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/17/springmvc-hibernate-jian</id>
    <content type="html"><![CDATA[<h4>基本信息：</h4>

<p><code>Mac OS 10.11</code>, <code>eclipse neon</code>, <code>jdk1.8</code>, <code>tomcat7</code>, <code>spring4.3.4</code>, <code>Hibernate5.2.4</code>,<code>jackson2.5</code>,<code>mysql数据库</code></p>

<h4>截图:</h4>

<p><img src="/myimg/java/ssh_frame.png" alt="" />
<img src="/myimg/java/ssh_pack.png" alt="" /></p>

<h4>Controller从JSP取值</h4>

<pre><code>//1.使用HttpServletRequest获取
public String addUser(HttpServletRequest request) {
    String name = request.getParameter("name");
    String pass = request.getParameter("password");
    return "/addUser";
}
//2.使用注解
public String addUser(@RequestParam("name") String name,@RequestParam("password") String password) {
    System.out.println(name+password);
    return "/addUser";
}
//3.自动注入Entity属性
public String addUser(User user) {
    System.out.println(user.getName() + user.getPassword());
    return "/addUser";
}
</code></pre>

<h4>Controller传值给JSP</h4>

<pre><code>//1.使用HttpServletRequest 然后setAttribute()，就和Servlet中一样
public String getAllUser(HttpServletRequest request) {
    request.setAttribute("userList", userService.getAllUser());
    return "/index";
}
//2.使用Spring的ModelMap `public class ModelMap extends LinkedHashMap&lt;String, Object&gt;`，ModelMap数据会利用HttpServletRequest的Attribute传值
public String getAllUser(ModelMap modelMap) {
    modelMap.put("userList", userService.getAllUser());
    return "/index";
}
//3.HttpServletReequest的getSession()  
public String getAllUser(HttpServletRequest request) {
    HttpSession session = request.getSession();
    session.setAttribute("userList", userService.getAllUser());
    return "/index";
}
</code></pre>

<p><a href="/mysrc/java/SSH.zip">下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hibernate 的使用]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/16/hibernate/"/>
    <updated>2016-11-16T09:20:12+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/16/hibernate</id>
    <content type="html"><![CDATA[<p>可以认为MyBatis是半自动化，而Hibernate是全自动化(也可半自动)。MyBatis是面向表和列的SQL查询，而Hibernate是用面向对象和对象属性的 HQL查询。 HQL 查询被 Hibernate 翻译为传统的 SQL 查询从而对数据库进行操作。尽管Hibernate可以直接使用本地 SQL 语句，但还是尽可能的使用 HQL 语句，以避免数据库移植产生的麻烦。在 HQL 中一些关键字比如 SELECT ，FROM 和 WHERE 等，是不区分大小写的，但对象名和属性名是区分大小写的。Hibernate也可以用注解方式来进行对象和表的关系映射，类似于<a href="http://ormlite.com/">OrmLit</a>这样。</p>

<p><img src="/myimg/java/hibernate_frame.png" alt="" /></p>

<p>和Mybatis 很像，都是加载配置文件得到SessionFactory, 然后通过SessionFactory获取 Session,然后用Session进行HQL操作。</p>

<p>Hibernate(5.2.4)配置文件</p>

<pre><code>&lt;?xml version="1.0" encoding="GBK"?&gt;  
&lt;!DOCTYPE hibernate-configuration PUBLIC  
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"  
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;
&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:mysql://localhost:8889/java_db&lt;/property&gt;
        &lt;property name="connection.username"&gt;root&lt;/property&gt;
        &lt;property name="connection.password"&gt;root&lt;/property&gt;
        &lt;!-- 指定连接池里最大连接数 --&gt;
        &lt;property name="hibernate.c3p0.max_size"&gt;50&lt;/property&gt;
        &lt;!-- 指定连接池里最小连接数 --&gt;
        &lt;property name="hibernate.c3p0.min_size"&gt;5&lt;/property&gt;
        &lt;!-- 指定连接池里连接的超时时长 --&gt;
        &lt;property name="hibernate.c3p0.timeout"&gt;3000&lt;/property&gt;
        &lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt;
        &lt;property name="hibernate.c3p0.max_statements"&gt;100&lt;/property&gt;
        &lt;property name="hibernate.c3p0.idle_test_perxiod"&gt;3000&lt;/property&gt;
        &lt;property name="hibernate.c3p0.acquire_increment"&gt;2&lt;/property&gt;
        &lt;property name="hibernate.c3p0.validate"&gt;true&lt;/property&gt;
        &lt;!-- 指定数据库方言 --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt;
        &lt;!-- 根据需要自动创建数据表 --&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;
        &lt;!-- 显示Hibernate持久化操作所生成的SQL --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;
        &lt;!-- 将SQL脚本进行格式化后再输出 --&gt;
        &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;

        &lt;!-- 下面罗列所有的映射文件 --&gt;
        &lt;mapping resource="com/sgm/config/user.xml" /&gt;

    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre>

<p>对象到表的映射文件</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; 
&lt;hibernate-mapping package="com.sgm.bean"&gt;
   &lt;class name="User" table="user"&gt;
      &lt;id name="id" type="int" column="id"&gt;
         &lt;generator class="native"/&gt;
      &lt;/id&gt;
      &lt;property name="name" column="name" type="string"/&gt;
      &lt;property name="password" column="password" type="string"/&gt;
   &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>基本使用</p>

<pre><code>public class Main {
    private static SessionFactory factory;
    static{
        try {
            Configuration config = new Configuration().configure("com/sgm/config/hibernate.xml");
            factory = config.buildSessionFactory();
        } catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
        }
    }

@SuppressWarnings("unchecked")
public static void main(String[] args) {
    Session session = factory.openSession();
    Transaction transaction = null;
    try {
        transaction = session.beginTransaction();
        //数据库处理

        transaction.commit();
    } catch (Exception e) {
        if (transaction != null)
            transaction.rollback();
        e.printStackTrace();
    } finally {
        session.close();
    }
  }
}
</code></pre>

<p><img src="/myimg/java/hibernate_zsg.png" alt="" /></p>

<p>一般情况下，用不带entityName参数的方法就可以了。带entityName的是hibernate在探索不使用pojo类进行O/R，不建议使用。</p>

<h4>查询</h4>

<pre><code>//from后面是对象！不是表名！对象和表在mapper文件里关联好了。hql面向的是对象，不是表！
String hql = "FROM User as u where u.id &gt;= 17 ";
Query&lt;User&gt; query = session.createQuery(hql);
List&lt;User&gt; list = query.getResultList();

//用setParameter设置查询参数，setFirstResult和setMaxResults可用于分页
String hql="from User as u where u.name=? and u.password = :password ORDER BY u.id DESC";
Query&lt;User&gt; query=session.createQuery(hql);
query.setParameter(0, "andy");
query.setParameter("password", "123");
query.setFirstResult(1);//从结果集的那一条开始(包括这一条)
query.setMaxResults(2);//最多几条
List&lt;User&gt; list=query.getResultList();

//query也可以用于批量修改和删除 
String hql = "UPDATE User set name = :name WHERE id &gt;= :id";
//String hql = "DELETE from User WHERE name = :name and id &gt;= :id";
Query&lt;User&gt; query = session.createQuery(hql);
query.setParameter("name", "andy hello");
query.setParameter("id", 19);
int result = query.executeUpdate();
System.out.println("处理了几条数据: " + result);
</code></pre>

<h4><a href="https://docs.jboss.org/hibernate/entitymanager/3.5/reference/en/html/querycriteria.html">CriteriaQuery</a> <a href="https://github.com/treehouse/giflib-hibernate/commit/f97a2828a466e849d8ae84884b5dce60a66cf412">废弃更新日志</a></h4>

<p>注意新的创建方式引用的包是 <code>import javax.persistence.criteria.CriteriaQuery</code>,而不是<code>import org.hibernate.criterion.CriteriaQuery</code>!!!</p>

<pre><code>//旧的已被废弃
session.createCriteria(User.class) 的创建方式已经被废弃
//改为这样,因为5.2.4的session已经继承了EntityManager，所以可以直接getCriteriaBuilder()。
CriteriaBuilder cb = session.getCriteriaBuilder();
CriteriaQuery&lt;User&gt; query = cb.createQuery(User.class);
Root&lt;User&gt; user = query.from(User.class);
query.select(user).where(cb.equal(user.get("name"), "andy"));
List&lt;User&gt; list = session.createQuery(query).getResultList();
</code></pre>

<h4>原生SQL</h4>

<pre><code>String sql = "select * from user where id = :tmpId";
NativeQuery&lt;User&gt; nativeQuery = session.createNativeQuery(sql,User.class);
nativeQuery.setParameter("tmpId", 19);
nativeQuery.setFirstResult(1);
nativeQuery.setMaxResults(2);
List&lt;User&gt; list = nativeQuery.getResultList();
//nativeQuery.executeUpdate(); 修改或者删除
</code></pre>

<h4>one-to-many / many-to-one</h4>

<p>举个栗子： <code>User(单方)----Book(多方)</code>,一个user有多个book, 一个book只属于一个user。</p>

<pre><code>public class User {
    public int id;
    public String name;
    private Set&lt;Book&gt; books = new HashSet&lt;Book&gt;();
    //下面 getter setter
}

public class Book {
    public int id;
    public String name;
    public User user;
    //下面 getter setter
}
</code></pre>

<p>User mapper</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;
&lt;hibernate-mapping package="com.sgm.bean"&gt;
    &lt;class name="User" table="user"&gt;
        &lt;id name="id" type="int" column="id"&gt;
            &lt;generator class="native" /&gt;
        &lt;/id&gt;
        &lt;property name="name" column="name" type="string" /&gt;

        &lt;set name="books" inverse="true" cascade="all"&gt;
            &lt;key column="userId"&gt;&lt;/key&gt;
            &lt;one-to-many class="com.sgm.bean.Book" /&gt;
        &lt;/set&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>Book mapper</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;
&lt;hibernate-mapping package="com.sgm.bean"&gt;
    &lt;class name="Book" table="book"&gt;
        &lt;id name="id" type="int" column="id"&gt;
            &lt;generator class="native" /&gt;
        &lt;/id&gt;
        &lt;property name="name" column="name" type="string" /&gt;

        &lt;many-to-one name="user" class="com.sgm.bean.User"&gt;
            &lt;column name="userId"&gt;&lt;/column&gt;
        &lt;/many-to-one&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>测试</p>

<pre><code>public class Main {
    private static SessionFactory factory;
    static {
        try {
            Configuration config = new Configuration().configure("com/sgm/config/hibernate.xml");
            factory = config.buildSessionFactory();
        } catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
        }
    }

    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        Session session = factory.openSession();
        Transaction transaction = null;
        try {
            transaction = session.beginTransaction();
            // do some work
            User user = new User();
            user.setName("andy");

            Book book1 = new Book();
            book1.setName("哈利波特");
            book1.setUser(user);

            Book book2 = new Book();
            book2.setName("功夫之王");
            book2.setUser(user);

            user.getBooks().add(book1);
            user.getBooks().add(book2);

            session.save(user);

            transaction.commit();
        } catch (Exception e) {
            if (transaction != null)
                transaction.rollback();
            e.printStackTrace();
        } finally {
            session.close();
        }
    }
}
</code></pre>

<p><img src="/myimg/java/hibernate_om.png" alt="" /></p>

<h4>中文乱码</h4>

<p>用Hibernate 插入中文到MySQL数据库时，即使MySQL数据库设置编码 <code>Character set = utf-8</code> 还是乱码。要改Hibernate 的配置：
<code>
&lt;property name="connection.url"&gt;jdbc:mysql://localhost:8889/java_db&lt;/property&gt;
//改为
&lt;property name="connection.url"&gt;&lt;![CDATA[jdbc:mysql://localhost:8889/java_db?useUnicode=true&amp;characterEncoding=utf8]]&gt;&lt;/property&gt;
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring 依赖注入]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/15/spring-ioc/"/>
    <updated>2016-11-15T09:17:48+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/15/spring-ioc</id>
    <content type="html"><![CDATA[<p><a href="https://spring.io/">Spring</a>是一个大东西，框架集合。Spring MVC, Spring AOP, Spring IoC&hellip;等等。先看看Spring IoC(Inversion of Control)控制反转。就是把原先要手动 new 一个对象，现在只要在Srping 的配置文件里配置就可以了，从主动控制对象，到被动接收对象，这就叫控制反转，也叫依赖注入(dependency injection)！ 依赖注入是Spring的核心机制，把对象之间的依赖关系转为用配置文件来管理，这有赖于它的核心组件 Beans, Core, Context 。</p>

<p><img src="/myimg/java/spring_core.png" alt="" /></p>

<p>开始之前要下载Spring jar包，但是官网上只看到了maven 和 gradle 的添加方式，要手动下载jar包还不好找呢，藏得跟宝藏似的。<a href="http://repo.spring.io/release/org/springframework/spring/">Spring jar 包下载</a>，还需要它的依赖包 <a href="http://commons.apache.org/proper/commons-logging/download_logging.cgi">Commons Logging</a>。</p>

<p><img src="/myimg/java/spring_jar.png" alt="" /></p>

<p>把上面的包下载下来添加到项目里，然后 Add to build path。</p>

<p><img src="/myimg/java/spring_add.png" alt="" /></p>

<p>Spring 可以用注解方式注入和xml方式注入。</p>

<h5>1.注解的方式注入一个接口的实现</h5>

<p>接口定义</p>

<pre><code>public interface MessageInterface {
   public String getMessage();
   public String getName();
}
</code></pre>

<p>操作Action</p>

<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component //必须要
public class MessageAction {

final private MessageInterface service;

@Autowired //可不要
public MessageAction(MessageInterface service) {
    this.service = service;
}

public void printMessage() {
    System.out.println(this.service.getMessage() + this.service.getName());
  }
}
</code></pre>

<p>测试类</p>

<pre><code>import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.*;

@Configuration //可不要
@ComponentScan //必须要
public class Application {
    @Bean
    MessageInterface injectImp() {
        return new MessageInterface() {
            public String getMessage() {
              return "Hello World!";
            };

        public String getName(){
            return "sgm";
        }
    };
}

  public static void main(String[] args) {
      ApplicationContext context = new AnnotationConfigApplicationContext(Application.class);
      MessageAction printer = context.getBean(MessageAction.class);
      printer.printMessage();
  }
}
</code></pre>

<p>结果打印出</p>

<pre><code>Hello World!sgm
</code></pre>

<pre><code class="">@Configuration 用于标注一个类，表示bean定义的源文件
@ComponentScan  用于标注一个类，表示扫描指定包中的@Component标注的类。通过该实例得到 ApplicationContext
@Component  用于标注一个类组件，然后通过 ApplicationContext 对象获取
@Bean 用于注入一个实例对象，相当于Spring &lt;bean&gt;XML里的配置
@Autowired  用于标注setter方法，构造器，包含多个参数的方法，集合等等，用于自动注入绑定实例
</code></pre>

<h5>2.用xml的方式注入一个接口的实现</h5>

<p>如下，UserService是接口，里面定义一个print()方法。UserServiceImp是UserService的一个实现类，实现print(&ldquo;hello wrold&rdquo;)。</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="userService" class="com.sgm.implement.UserServiceImp"/&gt;

&lt;/beans&gt;
</code></pre>

<p>userService.print()就会打印出绑定实现类里的"hello wrold"。</p>

<pre><code> ApplicationContext context =  new ClassPathXmlApplicationContext("com/sgm/spring/bean.xml");
 UserService userService = (UserService) context.getBean("userService");
 userService.print();
</code></pre>

<p>用xml的方式还可以通过类的构造函数注入，上面的例子是通过属性的set方法注入的。</p>

<pre><code>&lt;bean id="serviceProvider" class="com.sgm.service.ServiceProvider"&gt;
    &lt;constructor-arg ref="userService"&gt;&lt;/constructor-arg&gt;  
&lt;/bean&gt; 

&lt;bean id="userService" class="com.sgm.implement.UserServiceImp"/&gt;
</code></pre>

<p>xml默认都是注入一个单例对象的，即bean的属性 scope = &ldquo;singleton&rdquo; 为默认值。如果要每次都注入一个新对象，则设置bean的属性 scope = &ldquo;prototype"。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis 的使用]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/14/mybatis/"/>
    <updated>2016-11-14T19:26:25+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/14/mybatis</id>
    <content type="html"><![CDATA[<p>Mybatis是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>

<p>需要两个包：<a href="https://github.com/mybatis/mybatis-3/releases">MyBatis包</a>和<a href="https://www.mysql.com/products/connector/">JDBC Driver for MySQL</a></p>

<p>无论是用过的mybatis和hibernate他们的共同点：
<code>
1.从配置文件(通常是XML配置文件中)得到sessionfactory
2.由sessionfactory产生session
3.在session中完成对数据的增删改查和事务提交等
4.在用完之后关闭session
5.在java 对象和数据库之间有mapping的配置文件，也通常是xml文件
</code></p>

<p>主要XML配置文件中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源和决定事务范围和控制方式的事务管理器。通过加载该文件获取SqlSessionFactory。</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;!--对象别名定义 --&gt;
    &lt;typeAliases&gt;
        &lt;typeAlias alias="User" type="com.sgm.java.User" /&gt;
    &lt;/typeAliases&gt;

&lt;!--数据库连接 --&gt;
&lt;environments default="development"&gt;
    &lt;environment id="development"&gt;
        &lt;transactionManager type="JDBC" /&gt;
        &lt;dataSource type="POOLED"&gt;
            &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt;
            &lt;property name="url" value="jdbc:mysql://localhost:8889/java_db" /&gt;
            &lt;property name="username" value="root" /&gt;
            &lt;property name="password" value="root" /&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;

&lt;!--数据库操作映射文件 --&gt;
&lt;mappers&gt;
    &lt;mapper resource="com/sgm/mybatis/User.xml" /&gt;
&lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>

<p>数据库操作映射文件</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;!--namespace很重要，绑定对应的接口文件！--&gt;
&lt;mapper namespace="com.sgm.java.UserDao"&gt;

&lt;resultMap type="User" id="resultListUser"&gt;
    &lt;result column="name" property="name" /&gt;
    &lt;result column="age" property="age" /&gt;
&lt;/resultMap&gt;

&lt;!--id名字要和UserDao里的方法名一样  --&gt;
&lt;insert id="addUser" parameterType="User" useGeneratedKeys="true" keyProperty="id"&gt;
    insert into user(name, age) values(#{name}, #{age});
&lt;/insert&gt;

&lt;delete id="deleteUserById" parameterType="int"&gt;
    delete from user where id = #{id};
&lt;/delete&gt;

&lt;update id="updateUser" parameterType="User" &gt;
     update user set name = #{name}, age = #{age} where id = #{id};
&lt;/update&gt;

&lt;select id="getAllUsers" resultMap="resultListUser"&gt;
    select * from user ;
&lt;/select&gt;

&lt;select id="selectUserById" parameterType="int" resultType="User"&gt;
   select * from user where id = #{id};
&lt;/select&gt;
&lt;/mapper&gt;
</code></pre>

<p>定义数据库操作接口，方法要和对应的映射文件里的id名称一样！</p>

<pre><code>public interface UserDao {
    //  方法名要和User.xml配置文件里的id名称一样
    public void addUser(User user);

    public void deleteUserById(int id);

    public void updateUser(User user);

    public List&lt;User&gt; getAllUsers();

    public User selectUserById(int id);
}
</code></pre>

<p>操作的Java对象</p>

<pre><code>public class User {
        public int id;
        public String name;
        public int age;

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre>

<p>测试</p>

<pre><code>public class Main {
    private static Reader reader;
    private static SqlSessionFactory sqlSessionFactory;

static {
    try {
        reader = Resources.getResourceAsReader("MyBatisConfig.xml");
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public static void main(String[] args) {
    SqlSession session = sqlSessionFactory.openSession();
    UserDao userDao = session.getMapper(UserDao.class);

    try {
//          // 增
//          User newUser = new User();
//          newUser.setName("andy");
//          newUser.setAge(20);
//          userDao.addUser(newUser);
//          session.commit();//必须提交
//          System.out.println("reult------： 新增的userId " + newUser.getId());    
//          //删
//          userDao.deleteUserById(1);
//          session.commit();//必须提交

//          //改
//          User updateUser = new User();
//          updateUser.setId(4);
//          updateUser.setName("andy");
//          updateUser.setAge(20);
//          userDao.updateUser(updateUser);
//          session.commit();//必须提交

//          //列表
//          List&lt;User&gt; userList = userDao.getAllUsers();
//          for(User user : userList){
//              System.out.println("reult------：  " + user.getName());            
//          }
            //查单个
//          User user = userDao.selectUserById(4);
//          System.out.println("reult------：  " + user.getName());
        } finally {
            session.close();//必须关闭
        }
    }
}
</code></pre>

<h3>传参方式</h3>

<h5>1.用下标获取</h5>

<pre><code>//Dao层接口定义
public User selectUser(String name,String password);
//对应的映射方法,用下标获取
&lt;select id="selectUser" resultMap="userList"&gt;
    select  *  from user where name = #{0} and password=#{1}
&lt;/select&gt;
//定义userList
&lt;resultMap type="User" id="userList"&gt;
    &lt;result column="id" property="id" /&gt;
    &lt;result column="name" property="name" /&gt;
    &lt;result column="password" property="password" /&gt;
&lt;/resultMap&gt;
</code></pre>

<h5>2.传自定义对象</h5>

<pre><code>public void updateUser(User user);
&lt;update id="updateUser" parameterType="User"&gt;
    update user set name = #{name}, password = #{password} where id = #{id};
&lt;/update&gt;
//定义User别名
&lt;typeAliases&gt;
    &lt;typeAlias alias="User" type="com.sgm.bean.User" /&gt;
&lt;/typeAliases&gt;
</code></pre>

<h5>3.用注解的方式</h5>

<pre><code>public User selectUser(@Param("name")String name,@Param("password")String password);
&lt;select id="selectUser" resultType="User"&gt;
    select * from user where name = #{name} and password = #{password};
&lt;/select&gt;
</code></pre>

<h4>动态SQL语句</h4>

<pre><code>&lt;select id="selectSameAddressUser" parameterType="User" resultType="userList"&gt;
    select * from user 
        &lt;if test="name != null"&gt;
            title = #{name}
        &lt;/if&gt;
        &lt;if test="address != null"&gt;
            and address = #{address}
        &lt;/if&gt;
&lt;/select&gt;
</code></pre>

<h3>注意!</h3>

<h5>SqlSessionFactoryBuilder</h5>

<p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围,也就是局部方法变量。可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p>

<h5>SqlSessionFactory</h5>

<p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次。因此 SqlSessionFactory 的最佳范围是应用范围。可以使用单例模式或者静态单例模式。</p>

<h5>SqlSession</h5>

<p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的范围是请求或方法范围。不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。每次操作应该打开一个 SqlSession，处理数据，处理完后就关闭它。关闭操作很重要，应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。
<code>
SqlSession session = sqlSessionFactory.openSession();
try {
  // do work
} finally {
  session.close();
}
</code></p>
]]></content>
  </entry>
  
</feed>
