<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Other | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/other/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-11-16T10:34:09+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native Demo]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/14/react-native/"/>
    <updated>2016-11-14T19:46:09+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/14/react-native</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringMVC + MyBatis 框架搭建]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/14/springmvc-plus-mybatda-jian/"/>
    <updated>2016-11-14T19:34:43+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/14/springmvc-plus-mybatda-jian</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis 使用]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/14/mybatis/"/>
    <updated>2016-11-14T19:26:25+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/14/mybatis</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序 Demo]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/08/wei-xin-demo/"/>
    <updated>2016-11-08T19:43:46+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/08/wei-xin-demo</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/19/desigin-pattern/"/>
    <updated>2015-12-19T21:51:06+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/19/desigin-pattern</id>
    <content type="html"><![CDATA[<p>我理解的设计模式都是为了让代码模块化，结构化，各司其职，再把各个模块通过"接口"组合起来。封装变化；多用组合少用继承；针对接口编程，不针对实现编程；为交互对象之间的松耦合设计而努力；对扩展开放，对修改关闭。</p>

<h3>1.MVC模式</h3>

<p>看图就可以了，简洁明了~
<img src="/myimg/other/mvc.png" alt="image" /><!--more--></p>

<h3>2.策略模式</h3>

<p>比如有个父类有飞行功能，然后有很多子类的飞行功能各不一样，如果去继承父类然后分别实现不同的飞行行为，这就坑爹了&hellip;具体做法应该是：把飞行行为完全独立出来成一个Interface，然后不同的飞行行为再在单独的类中实现，不同的子类要不同的飞行行为的话就取对应的行为实现对象。</p>

<p>父类：</p>

<pre><code>public class Duck {//父类

public FlyInterface flyInterface;//行为的接口成员变量

public void performFly(){//统一调用的飞行方法
    flyInterface.fly();
}

public void setFlyInterface(FlyInterface fi){//动态改变飞行行为
    flyInterface = fi;
  }
}
</code></pre>

<p>行为接口：</p>

<pre><code>public interface FlyInterface { //行为接口
void fly();//要实现的行为方法
}
</code></pre>

<p>行为的一种具体实现：</p>

<pre><code>public class FlyPatternOne implements FlyInterface {//飞行行为的一种实现，可以有很多个不同的实现
@Override
public void fly() {
    //这里是具体飞行行为代码

  }
}
</code></pre>

<p>某一个子类：</p>

<pre><code>public class SubDuck extends Duck{
public SubDuck(){
    //默认的飞行行为，不同的子类有不同的飞行行为，如 FlyPatternTwo FlyPatternThree...等
    flyInterface = new FlyPatternOne();
  }
}
</code></pre>

<p><img src="/myimg/other/chelue.png" alt="image" /></p>

<p>1,找出可能需要变化之处，把它们独立封装起来，不要和那些不需要变化的代码混合在一起。</p>

<p>2.针对接口编程，而不是针对实现编程。</p>

<p>3.多用组合，少用继承。</p>

<h3>3.观察者模式</h3>

<p>好好看图吧，把它转化为具体代码加深理解
<img src="/myimg/other/guanCha0.jpg" alt="image" />
<img src="/myimg/other/guanCha1.jpg" alt="image" />
<img src="/myimg/other/guanCha2.jpg" alt="image" />
<img src="/myimg/other/guanCha3.jpg" alt="image" /></p>

<p>看完上面例子，下面的设计图也更好理解了。
<img src="/myimg/other/guanCha4.jpg" alt="image" /></p>

<p>使用Java内置的观察者模式
<img src="/myimg/other/guanCha5.jpg" alt="image" />
<img src="/myimg/other/guanCha6.jpg" alt="image" />
<img src="/myimg/other/guanCha7.jpg" alt="image" />
<img src="/myimg/other/guanCha8.jpg" alt="image" /></p>

<p>Swing中的观察者模式
<img src="/myimg/other/guanCha9.jpg" alt="image" /></p>

<p>要点
<img src="/myimg/other/guanCha10.jpg" alt="image" /></p>

<h3>4.装饰模式</h3>

<p>动态的将责任附加到对象上，用对象组合的方式来解决继承滥用的问题。利用继承设计子类的行为是在编译时静态决定的，而且所有的子类都会继承到相同的行为。如果利用组合的做法扩展对象的行为，就可以在运行时动态的进行扩展。类应该多扩展开放，对修改关闭。即在不修改现有代码的情况下可以添加新的行为。</p>

<p>装饰着和被装饰着必须是同一类型，所以通过继承来实现。这里的继承是用来达到“类型一致”的，而不是为了通过继承得到“行为”。“行为”来自装饰着和基础组件，其他与装饰着之间的组合关系。
<img src="/myimg/other/zhuangShi.jpg" alt="image" />
<img src="/myimg/other/zhuangShi0.jpg" alt="image" />
<img src="/myimg/other/zhuangShi1.jpg" alt="image" />
<img src="/myimg/other/zhuangShi2.jpg" alt="image" />
<img src="/myimg/other/zhuangShi3.jpg" alt="image" />
<img src="/myimg/other/zhuangShi4.jpg" alt="image" />
<img src="/myimg/other/zhuangShi5.jpg" alt="image" />
<img src="/myimg/other/zhuangShi6.jpg" alt="image" /></p>

<h3>5.工厂模式</h3>

<p>当每次“new”的时候都会实例化一个类，所以这是用的实现编程而不是接口编程。“工厂”就是一个专门负责产生对象的一个类。</p>
]]></content>
  </entry>
  
</feed>
