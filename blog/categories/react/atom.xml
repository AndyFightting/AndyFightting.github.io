<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: React | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/react/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-12-01T18:11:21+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native Navigator]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/01/react-navigator/"/>
    <updated>2016-12-01T09:27:30+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/01/react-navigator</id>
    <content type="html"><![CDATA[<p>这里主要记录一下Navigator的基本使用，页面间的传参，回调，以及在push,pop过程中生命周期方法的调用顺序。</p>

<p>React 的“页面”的概念和Android或iOS有点不一样，不像Android有个Activity作为页面容器，iOS有Controller作为页面容器。React 的“页面”本身就是一个组件集合，和Text,Image等基础组件是一个级别的东西。只不过是把多个组件拼起来充满屏幕，就组成一个“页面”了。</p>

<p>通过在Navigator的route里放置一个params参数，params里面放key-value传参。注意，方法也是对象，也可以当做value传递，这样就可回调了。就像Android的接口回调或iOS的block似的，在A页面实现方法，然后传递给B页面，在B页面使用方法，这样数据就从B回传给A了。数据从方法使用的地方传到方法实现的地方。</p>

<h4>在Index.js里初始化Navigator并且显示第一个页面FirstView:</h4>

<p><img src="/myimg/java/lift0.png" width="500" alt="" /></p>

<h4>从FirstView push 到SecondView</h4>

<p><img src="/myimg/java/lift1.png" width="500" alt="" /></p>

<h4>不调用FirstView的回调方法直接pop。</h4>

<p><img src="/myimg/java/life3.png" width="500" alt="" /></p>

<h4>如果在SecondView里点击返回的时候，先掉用FirstView的回调方法, 在回调方法里调用 setState() 刷新FirstView，然后 pop 。</h4>

<p><img src="/myimg/java/lift2.png" width="500" alt="" /></p>

<p>从上面可以看出不管是从A到B还是从B返回A,A的componentWillReceiveProps都会被调用! A的更新流程都会先走一遍！</p>

<p><img src="/myimg/java/life4.png" width="600" alt="" /></p>

<pre><code>configureScene 属性用来配置场景动画。
configureScene={(route, routeStack) =&gt; {
                return Navigator.SceneConfigs.PushFromRight;
              }}
</code></pre>

<pre><code>在/node_modules/react-native/Libraries/CustomComponents/Navigator/NavigatorSceneConfigs 中预设了很多转场动画。
PushFromRight
PushFromLeft
FloatFromRight // We will want to customize this soon
FloatFromLeft
FloatFromBottom
FloatFromBottomAndroid
FadeAndroid
HorizontalSwipeJump
HorizontalSwipeJumpFromRight
HorizontalSwipeJumpFromLeft
VerticalUpSwipeJump
VerticalDownSwipeJump
</code></pre>

<h4>其他方法</h4>

<pre><code>getCurrentRoutes() - 获取当前栈里的所有路由
jumpBack() - 跳回之前的路由，还保留现在的，还可以再跳回来，会保留原样
jumpForward() - 与上一个方法对应
jumpTo(route) - 跳转到已有的场景并且不卸载
push(route) - 跳转到新的场景，并且将场景入栈
pop() - 跳转回去并且卸载掉当前场景
replace(route) - 用一个新的路由替换掉当前场景
replaceAtIndex(route, index) - 替换掉指定序列的路由场景
replacePrevious(route) - 替换掉之前的场景
resetTo(route) - 跳转到新的场景，并且重置整个路由栈
immediatelyResetRouteStack(routeStack) - 用新的路由数组来重置路由栈
popToRoute(route) - pop到路由指定的场景，在整个路由栈中，处于指定场景之后的场景将会被卸载
popToTop() - pop到栈中的第一个场景，卸载掉所有的其他场景
</code></pre>

<h4>index.ios.js</h4>

<pre><code>import React, {Component} from 'react';
import {View,Navigator,AppRegistry} from 'react-native';
import FirstView from './FirstView';

   var logName = 'Index:--------';

   export default class BaseNavigator extends Component {
     constructor(props){
          console.log(logName + 'constructor');
          super(props);
      }
      componentWillMount(){
          console.log(logName + 'componentWillMount');
      }
       render() {
         console.log(logName+'render')
        return (
        &lt;Navigator
          //把下面一行的/都去掉，因为Markdown转化不了所以加的
          initialRoute=/{/{params: /{/},view: FirstView /}/}
          renderScene={(route, navigator) =&gt; {
            let ShowedView = route.view;
            return &lt;ShowedView {...route.params} nav={navigator} /&gt;
          }} /&gt;
        );
       }

       componentDidMount() {
           console.log(logName + 'componentDidMount');
       }

       componentWillReceiveProps(nextprops){
              console.log(logName + 'componentWillReceiveProps');
        }
        shouldComponentUpdate(nextProps,nextState){
              console.log(logName + 'shouldComponentUpdate');
            return true;
        }
        componentWillUpdate(nextProps,nextState){
              console.log(logName + 'componentWillUpdate');
        }
        componentDidUpdate(prevProps,prevState){
            console.log(logName + 'componentDidUpdate');
        }
        componentWillUnmount(){
            console.log(logName + 'componentWillUnmount');
        }
   }
AppRegistry.registerComponent('MyReact', () =&gt; BaseNavigator);
</code></pre>

<h4>FirstView.js</h4>

<pre><code>import React,{Component} from 'react';
import {View,StyleSheet,Text} from 'react-native';
import SecondView from './SecondView';

var logName = 'FirstView:--------';
export default class FirstView extends Component { 
  constructor(props) {
    console.log(logName + 'constructor');
        super(props);
        this.state = {
            callBackMsg: '',
        };
    }
   componentWillMount(){
       console.log(logName + 'componentWillMount');
   }

    render() {
      console.log(logName+'render')
        return (
            &lt;View style={styles.backView}&gt;
                  &lt;Text style={styles.tapView}  onPress={this.pressedFun.bind(this)}&gt;点击跳转&lt;/Text&gt;
                  &lt;Text style={styles.msgView}&gt;
                    {this.state.callBackMsg}
                  &lt;/Text&gt;
            &lt;/View&gt;
        );
    }
    componentDidMount() {
        console.log(logName + 'componentDidMount');
    }

    componentWillReceiveProps(nextprops){
           console.log(logName + 'componentWillReceiveProps');
     }
     shouldComponentUpdate(nextProps,nextState){
           console.log(logName + 'shouldComponentUpdate');
         return true;
     }
     componentWillUpdate(nextProps,nextState){
           console.log(logName + 'componentWillUpdate');
     }
     componentDidUpdate(prevProps,prevState){
         console.log(logName + 'componentDidUpdate');
     }
     componentWillUnmount(){
         console.log(logName + 'componentWillUnmount');
     }
//-------个人方法--------
    pressedFun() {
        let nav = this.props.nav;
        let tmpThis = this;
            nav.push({
                view: SecondView,
                params:{
                  userId: 123,
                  userName: 'andy',
                  callBackFun: function(newMsg){
                      tmpThis.setState({
                        callBackMsg: newMsg,
                      })
                  },
                },
            });
          }
}

const styles = StyleSheet.create({
  backView:{
    flex: 1,
    justifyContent: 'center',
    backgroundColor: 'azure',
  },
  tapView:{
    fontSize: 20,
    alignSelf: 'center',
    textAlign: 'center',
    width: 130,
    height: 50,
    lineHeight: 50,
    color: 'yellow',
    borderColor: 'yellow',
    borderWidth: 2,
    borderRadius: 25,
    backgroundColor: 'blue',
    overflow: 'hidden',//不然边角会有背景色
  },
  msgView:{
    fontSize: 16,
    marginTop: 30,
    textAlign: 'center',
  },
});
</code></pre>

<h4>SecondView.js</h4>

<pre><code>import React,{Component} from 'react';
import {View,Navigator,StyleSheet,TouchableWithoutFeedback,Image,Text,} from 'react-native';

var logName = 'SecondView:--------';
export default class SecondView extends Component {
  static defaultProps = {
      // testProp: 'testProp默认值',
  }
  static propTypes = {
      // testProp: React.PropTypes.string.isRequired,
  }
  constructor(props) {
        console.log(logName + 'constructor');
        super(props);
        this.state = {};
    }
    componentWillMount(){
        console.log(logName + 'componentWillMount');
    }
    render() {
      console.log(logName+'render')
       return (
            &lt;View style={styles.backView}&gt;
              &lt;View style={styles.titleBackView}&gt;
              &lt;TouchableWithoutFeedback onPress={this.backPressed.bind(this)}&gt;
                 &lt;Image style={styles.backImage} source= {require('./images/backImage.png')}/&gt;
              &lt;/TouchableWithoutFeedback&gt;
                &lt;Text style={styles.titleView}&gt;标题&lt;/Text&gt;
              &lt;/View&gt;
                &lt;Text&gt;上个页面传来的参数userId: {this.props.userId}&lt;/Text&gt;
                &lt;Text&gt;上个页面传来的参数userName: {this.props.userName}&lt;/Text&gt;
            &lt;/View&gt;
        );
    }
    componentDidMount() {
        console.log(logName + 'componentDidMount');
    }

    componentWillReceiveProps(nextprops){
           console.log(logName + 'componentWillReceiveProps');
     }
     shouldComponentUpdate(nextProps,nextState){
           console.log(logName + 'shouldComponentUpdate');
         return true;
     }
     componentWillUpdate(nextProps,nextState){
           console.log(logName + 'componentWillUpdate');
     }
     componentDidUpdate(prevProps,prevState){
         console.log(logName + 'componentDidUpdate');
     }
     componentWillUnmount(){
         console.log(logName + 'componentWillUnmount');
     }

//------个人方法--------
     backPressed() {
         let nav = this.props.nav;
             this.props.callBackFun('这是消失的页面通过回调方法传来的数据！');
             nav.pop();
     }
}
const styles = StyleSheet.create({
  backView:{
    flex: 1,
    backgroundColor: 'bisque',
  },
  titleBackView:{
    height: 65,
    backgroundColor: 'darkkhaki',
    flexDirection: 'row'
  },
  titleView:{
    height:45,
    lineHeight:45,
    marginTop:20,
    color: 'white',
    fontSize: 18,
    textAlign: 'center',
    alignSelf: 'center',
    flex: 1,
    marginRight:20,
  },
  backImage:{
    marginTop:35,
    marginLeft:10,
    width: 10,
    height: 20,
  },
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native组件生命周期]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/30/react-native-life/"/>
    <updated>2016-11-30T11:08:59+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/30/react-native-life</id>
    <content type="html"><![CDATA[<p>生命周期就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期是开发的基础。ES5语法和ES6语法有所变化，在ES5语法中，有getDefaultPropTypes方法，这个方法在组件被创建时调用一次，它的返回值成为了this.props的初始值。而ES6语法中，属性的类型和默认值声明不像ES5语法那样在组件定义内部声明,而是在组件定义的外部声明，所以没有了getDefaultPropTypes方法.</p>

<p><img src="/myimg/java/life2.png" alt="" /></p>

<h4>可以把组件生命周期大致分为三个阶段：</h4>

<pre><code>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；
第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互接收事件更新界面；
第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。
</code></pre>

<p><strong>constructor(props) :</strong>这个方法会在组件创建的时候调用一次。 这个方法中可以通过this.state初始化状态参数，ES5是通过getInitialState()方法初始化的。</p>

<p><strong>getDefaultProps() :</strong>在组件类创建的时候调用一次，然后返回值被缓存下来。全局调用一次，所有实例共享。</p>

<p><strong>getInitialState() :</strong>在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。</p>

<p><strong>componentWillMount() :</strong>在组件创建并初始化了状态之后，在第一次 render() 之前。可以在这里做一些初始化操作。这个函数在整个生命周期中只被调用一次。</p>

<p><strong>render() :</strong>这个方法是必须的，对视图进行渲染，也可以返回 null 或者 false 来表明不需要渲染任何东西.</p>

<p><strong>componentDidMount() :</strong>在组件第一次绘制之后，会调用该方法通知组件已经加载完成。这个方法调用的时候，其虚拟 DOM 已经构建完成，可以在这个函数里获取其中的元素或者子组件。框架是先调用子组件的该方法，然后再调用父组件的。可以在这里发起网络请求等。</p>

<p><strong>componentWillReceiveProps(nextProps) :</strong> 父组件改变子组件的属性的时候会调用该方法,初次渲染时不会调用该方法。参数nextProps是即将被设置的属性，旧的属性还是可以通过 this.props 来获取。</p>

<p><strong>shouldComponentUpdate(nextProps,nextState) :</strong>当组件接收到新的属性或状态改变的话会调用该方法。参数 nextProps 和上面的方法一样。nextState 表示组件即将更新的状态值。这个方法的返回值决定是否需要更新组件，默认返回true。可以重载这个函数来决定组件是否需要更新。</p>

<p><strong>componentWillUpdate(nextProps,nextState) :</strong>如果组件状态改变，并且上面的方法返回为true，就会开始准更新组件。这里可以做一些在更新组件之前要做的事情。<strong>在这个方法里面不能再调用 this.setState 来修改状态</strong>。这个方法调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着就会调用 render() 来更新组件了。</p>

<p><strong>componentDidUpdate(prevProps,prevState) :</strong>在调用了 render() 更新组件同步到 DOM 中之后立刻调用该方法。因为到这里已经完成了属性和状态的更新了，此方法的参数变成了 prevProps 和 prevState。</p>

<p><strong>componentWillUnmount() :</strong>当组件从 DOM 中移除的时候就会调用该方法。可以这个方法中做一些资源清理工作。</p>

<p><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5 ES6写法对照表</a></p>

<p><a href="http://blog.kdchang.cc/2016/04/04/react-react-native-es5-es6-cheat-sheet/">ES5 ES6区别</a></p>

<p><a href="https://babeljs.io/blog/2015/06/07/react-on-es6-plus">React on ES6</a></p>

<p><a href="http://egorsmirnov.me/2015/06/14/react-and-es6-part2.html">React and ES6</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flexbox 布局]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/30/css-flex-box/"/>
    <updated>2016-11-30T08:56:06+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/30/css-flex-box</id>
    <content type="html"><![CDATA[<p>弹性盒子布局由弹性容器和弹性子item组成。容器默认存在两根轴：水平的主轴和垂直的交叉轴。主轴的开始位置叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。item默认沿主轴排列。item占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size
<img src="/myimg/java/flexbox.png" width="600" alt="" /></p>

<p><strong>用在容器上的属性：</strong>
<code>
flex-direction :决定item的排列方向。(row,row-reverse,column,column-reverse)
flex-wrap :决定item如何换行。(nowrap,wrap,wrap-reverse)
justify-content :决定itme在主轴上的对齐方式。(flex-start,flex-end,center,space-between,space-around)
align-items :决定item在交叉轴上的对齐方式。(stretch,flex-start,flex-end,center,baseline:item第一行文字基线对齐)
align-content :决定多条交叉轴线的对齐方式。(flex-start,flex-end,center,space-between,space-around,stretch)
</code>
align-content:</p>

<p><img src="/myimg/java/flex1.png" width="400" alt="" /></p>

<p><strong>用在Item上的属性</strong></p>

<pre><code>order :定义item的排列顺序。数值越小，排列越靠前，默认为0。
flex-grow :定义item的放大比例。默认为0，即如果存在剩余空间也不放大。有多个的话按比例均分。
flex-shrink :定义item的缩小比例。默认为1，即如果空间不足，该项目将缩小。0则不缩小。
flex-basis :定义了在分配多余空间之前，item占据的主轴空间,默认auto,即本来大小。
flex : flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。
align-self :设置item自身在交叉轴上的对齐方式。可覆盖align-items属性。
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
(auto,flex-start,flex-end,center,baseline,stretch)
</code></pre>

<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，也有些差异:flexDirection的默认值是column而不是row，alignItems的默认值是stretch而不是flex-start。使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求。</p>

<p><code>flexDirection</code>: 决定布局的主轴。子元素是沿着水平轴方向排列，还是沿着竖直轴方向排列。</p>

<p><code>justifyContent</code>: 决定子元素沿着主轴的排列方式。有flex-start、center、flex-end、space-around 和 space-between。</p>

<p><code>alignItems</code>: 决定其子元素沿着交叉轴的排列方式。有flex-start、center、flex-end以及stretch。<strong>注意：要使stretch选项生效的话，子元素在次轴方向上不能固定尺寸。</strong></p>

<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Fexbox布局实例</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 样式属性]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/29/rn-style/"/>
    <updated>2016-11-29T22:27:51+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/29/rn-style</id>
    <content type="html"><![CDATA[<p>React Native 采用CSS样式来布局，也会有继承和覆盖作用。只要在样式表中书写一个不存在的样式，就会报错，提示该样式不存在，然后提供所有可用的样式：
<img src="/myimg/java/style.png" alt="" /></p>

<pre><code>//边框
borderBottomWidth 
borderLeftWidth 
borderRightWidth 
borderTopWidth 
borderWidth 
</code></pre>

<pre><code>//边框颜色
borderBottomColor
borderLeftColor
borderRightColor
borderTopColor
borderColor
</code></pre>

<pre><code>//外边距
marginTop
marginBottom
marginLeft
marginRight
marginVertical //相当于marginTop 和 marginBottom
marginHorizontal //相当于 marginLeft 和 marginRight
margin
</code></pre>

<pre><code>//内边距  
paddingTop  
paddingBottom
paddingLeft  
paddingRight  
paddingVertical //相当于 paddingTop 和 paddingBottom
paddingHorizontal  //相当于 paddingLeft 和 paddingRight
padding 
</code></pre>

<pre><code>//边框圆角
borderTopLeftRadius
borderTopRightRadius
borderBottomLeftRadius
borderBottomRightRadius
borderRadius
</code></pre>

<pre><code>//flex 布局
flex number 
flexDirection enum('row', 'column') 
flexWrap enum('wrap', 'nowrap') 
alignItems enum('flex-start', 'flex-end', 'center', 'stretch') 
alignSelf enum('auto', 'flex-start', 'flex-end', 'center', 'stretch') 
justifyContent enum('flex-start', 'flex-end', 'center', 'space-between', 'space-around') 
position属性值为absolute和relative，当使用绝对布局时，定位根据屏幕来进行。
</code></pre>

<pre><code>//字体相关属性
color 字体颜色
fontFamily 字体族
fontSize 字体大小
fontStyle 字体样式，正常，倾斜等，值为enum('normal', 'italic')
fontWeight 字体粗细，值为enum("normal", 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900')
letterSpacing 字符间隔
lineHeight 行高
textAlign 字体对齐方式，值为enum("auto", 'left', 'right', 'center', 'justify')
textDecorationLine 上划线，下划线，删除线，无修饰，值为enum("none", 'underline', 'line-through', 'underline line-through')
textDecorationStyle 修饰的线的类型 enum("solid", 'double', 'dotted', 'dashed')
textDecorationColor 修饰的线的颜色
writingDirection enum("auto", 'ltr', 'rtl') 书写方向，从左往右写还是从右往左写
</code></pre>

<pre><code>//图片相关属性
resizeMode enum('cover', 'contain', 'stretch')
overflow enum('visible', 'hidden') 超出部分是否显示，hidden为隐藏
tintColor 着色，rgb字符串类型
opacity 透明度
scaleX:水平方向缩放
scaleY:垂直方向缩放
rotation:旋转
translateX:水平方向平移
translateY:水平方向平移
//阴影,默认透明的，要设置shadowOpacity大于0才有效果
shadowColor
shadowOffset
shadowOpacity
shadowRadius
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 问题汇总]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/28/react-native-run-bug/"/>
    <updated>2016-11-28T18:46:09+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/28/react-native-run-bug</id>
    <content type="html"><![CDATA[<p>Android 设备:小米 red note MUI 8.0, iOS 设备:iPhone 6Plus 8.3</p>

<h5>1.运行不起来</h5>

<p>按照<a href="https://facebook.github.io/react-native/docs/getting-started.html#content">官网</a>的步骤一步一步下来运行报：</p>

<pre><code>com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Failed to establish session
</code></pre>

<p><a href="https://github.com/facebook/react-native/issues/6499">这里</a>说小米系列的手机都这样，我们平时用Android Studio调试运行不是会弹出个弹出框问是否安装吗？这是用USB链接的，所以没问题，但是用命令就掉动不起来那弹出框&hellip;
<img src="/myimg/java/react_error_xm0.png" alt="" /></p>

<p>解决办法如下，关键是第4步，关闭小米的优化
<img src="/myimg/java/react_error_xm1.png" alt="" /></p>

<h5>2.运行不起来</h5>

<p>报错：</p>

<pre><code>com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Unable to upload some APKs
</code></pre>

<p>解决：把 /项目/android/build.gradle 文件里的 <code>classpath 'com.android.tools.build:gradle:1.3.1'</code> 改成 <code>classpath 'com.android.tools.build:gradle:1.2.3'</code>就可以了&hellip;.why? yeah,why?</p>

<h5>3.白屏</h5>

<p>运行起来了，等啊等，怎么还是白屏？不是有东西的吗？摇啊摇不是有弹出框的吗？弹出框呢？？</p>

<p>解决：进系统设置，应用管理，找到这个应用，点击应用详情里的权限管理，开启显示悬浮框。刷新一下再摇一摇就有弹出框了。</p>

<h5>4.Could not connect to development server</h5>

<p>摇啊摇弹出框后，点击最后的 <code>Dev Settings</code> ，然后设置 <code>Debug server host &amp; port for device</code> 为<code>本机IP:8081</code>后返回刷新出现如下错误:</p>

<p><img src="/myimg/java/react_error2.png" alt="" /></p>

<p>解决：命令行进入项目文件夹，运行如下命令：</p>

<pre><code>react-native start &gt; /dev/null 2&gt;&amp;1 &amp; curl "http://localhost:8081/index.android.bundle?platform=android" -o "android/app/src/main/assets/index.android.bundle"
</code></pre>

<p>如果提示没有 assets 文件夹，则先手动建一个再运行。之后就能真机运行起来了：</p>

<p><img src="/myimg/java/react_android.png" alt="" /></p>

<h5>iOS模拟器Cmd+R不刷新，Cmd+D也没弹出框</h5>

<p>解决：要开启模拟器的键盘链接。模拟器菜单<code>Hardware</code>-><code>Keyboard</code> 选中 <code>Connect Hardware Keyboard</code></p>
]]></content>
  </entry>
  
</feed>
