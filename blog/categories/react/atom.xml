<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: React | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/react/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2017-02-12T20:43:16+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native 和 iOS 互相调用]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/02/react-ios/"/>
    <updated>2016-12-02T09:19:38+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/02/react-ios</id>
    <content type="html"><![CDATA[<p>这里记录如何在iOS项目中集成React Native ，和他们之间互相传参，互相调用。</p>

<p>初学者可能都是按照RN官网来学习的，通过 <code>react-native init xxx</code> 来创建一个新项目，iOS和Android都放在一起了，对于新手来说有点乱，其实他们就是共用了配置文件和依赖库。但通过单独在iOS中集成RN更能清楚的知道需要的是哪些东西。</p>

<p>CocoaPods，如果pod版本是 0.39.0 请更新版本，依次用如下命令，我更新到了1.2.0：</p>

<pre><code>gem install cocoapods --pre
pod repo update --verbose
</code></pre>

<p>1.用Xcode新建一个OC项目叫MyRN_iOS，在项目文件夹里新建一个文件夹叫ReactComponent(名字随意)，在这文件夹里新建 <code>package.json</code> 文件里放：</p>

<pre><code>{
  "name": "MyRN_iOS",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "start": "node node_modules/react-native/local-cli/cli.js start"
  },
  "dependencies": {
    "react": "15.4.1",
    "react-native": "0.39.2"
  }
}
</code></pre>

<p>2.进入<code>package.json</code>所在文件夹即ReactComponent，执行命令<code>npm install</code>安装依赖包。</p>

<p>3.进入ReactComponent里创建index.ios.js文件(位置和命名随意都可以 xxx.js，只不过我放这里，后面配置的时候会用它的具体路径)，里面放过hello world：</p>

<pre><code>import React, { Component } from 'react';
import {
  AppRegistry,
  StyleSheet,
  Text,
  View
} from 'react-native';

class NativeRNApp extends Component {
  render() {
    return (
        &lt;View style={styles.container}&gt;
            &lt;Text style={styles.welcome}&gt;
               hello world
            &lt;/Text&gt;
        &lt;/View&gt;
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5FCFF',
  },
  welcome: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10,
  },
});

//  项目名必须对应!! 
AppRegistry.registerComponent('MyRN_iOS', () =&gt; NativeRNApp);
</code></pre>

<p>4.这里就是pod 操作了。进入项目文件夹，新建 <code>vim Podfile</code> 文件：（不知道为啥要8.0才可以，不然提示版本不够，稍后再看这问题），然后 <code>pod install</code> 安装。</p>

<pre><code>target 'MyRN_iOS' do
platform :ios, ‘8.0’

pod 'React', :path =&gt; ‘./ReactComponent/node_modules/react-native', :subspecs =&gt; [
 'Core',
  'ART',
  'RCTActionSheet',
  'RCTAdSupport',
  'RCTGeolocation',
  'RCTImage',
  'RCTNetwork',
  'RCTPushNotification',
  'RCTSettings',
  'RCTText',
  'RCTVibration',
  'RCTWebSocket',
  'RCTLinkingIOS',
]

end
</code></pre>

<p>6.OC里加载RN文件</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    NSString * strUrl = @"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true";
    NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];

    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation
                                                         moduleName:@"MyRN_iOS"
                                                  initialProperties:nil
                                                      launchOptions:nil];
    self.view = rootView;
}
</code></pre>

<p>7.还要允许OC进行 http 通信..
<img src="/myimg/js/fuck.png" width="700" alt="" /></p>

<p>8.Xcode打开项目然后Run,发现红屏报 can not connect server 。进入 <code>package.json</code>所在文件夹即ReactComponent, 执行 <code>npm start</code>,再运行Xcode就可以了。</p>

<p>用 WebStorm 或者 Sublime Text 打开上面新建项目是创建的文件夹 ReactComponent ,编辑里面的 js 文件，然后再Xcode运行。(是这样处理吧，还是我打开的方式不对…😂)</p>

<h4>OC向RN传参</h4>

<p>RN 可以看成就是MVC中的V, 它是通过 <code>RCTRootView</code> 包装了一下，而 RCTRootView 就是继承于 UIView 的！在初始化 RCTRootView的时候， initialProperties 这里传入一个字典，然后就可以在js的 props 中根据字典的key获取值了。</p>

<pre><code>//--OC中传字典
    NSDictionary* dic = @{
        @"name":@"andy",
        @"age":@"18",
    };
    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsLocation
                                                         moduleName:@"MyRN_iOS"
                                                  initialProperties:dic
                                                      launchOptions:nil];
 //JS中通过props读取传来的字典
  render() {
        return (
            &lt;View style={styles.container}&gt;
                &lt;Text style={styles.welcome}&gt;
                    {this.props.name} --- {this.props.age}
                &lt;/Text&gt;
            &lt;/View&gt;
        );
    }
</code></pre>

<h5>坑！本来单纯的在RN中调用点击事件是很简单的，前提是ViewController 中 self.view =rCTRootView; 。但是当用 [self.view addSubview:rCTRootView]; 时，即时在 RN 代码中设置 width,height 了，点击是没效果的！要在OC代码中设置 rCTRootView 的 frame 后才有效果！</h5>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native Navigator]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/01/react-navigator/"/>
    <updated>2016-12-01T09:27:30+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/01/react-navigator</id>
    <content type="html"><![CDATA[<p>这里主要记录一下Navigator的基本使用，页面间的传参，回调，以及在push,pop过程中生命周期方法的调用顺序。</p>

<p>React 的“页面”的概念和Android或iOS有点不一样，不像Android有个Activity作为页面容器，iOS有Controller作为页面容器。React 的“页面”本身就是一个组件集合，和Text,Image等基础组件是一个级别的东西。只不过是把多个组件拼起来充满屏幕，就组成一个“页面”了。</p>

<p>通过在Navigator的route里放置一个params参数，params里面放key-value传参。注意，方法也是对象，也可以当做value传递，这样就可回调了。就像Android的接口回调或iOS的block似的，在A页面实现方法，然后传递给B页面，在B页面使用方法，这样数据就从B回传给A了。数据从方法使用的地方传到方法实现的地方。</p>

<h4>在Index.js里初始化Navigator并且显示第一个页面FirstView:</h4>

<p><img src="/myimg/java/lift0.png" width="500" alt="" /></p>

<h4>从FirstView push 到SecondView</h4>

<p><img src="/myimg/java/lift1.png" width="500" alt="" /></p>

<h4>不调用FirstView的回调方法直接pop。</h4>

<p><img src="/myimg/java/life3.png" width="500" alt="" /></p>

<h4>如果在SecondView里点击返回的时候，先掉用FirstView的回调方法, 在回调方法里调用 setState() 刷新FirstView，然后 pop 。</h4>

<p><img src="/myimg/java/lift2.png" width="500" alt="" /></p>

<p>从上面可以看出不管是从A到B还是从B返回A,A的componentWillReceiveProps都会被调用! A的更新流程都会先走一遍！</p>

<p><img src="/myimg/java/life4.png" width="600" alt="" /></p>

<pre><code>configureScene 属性用来配置场景动画。
configureScene={(route, routeStack) =&gt; {
                return Navigator.SceneConfigs.PushFromRight;
              }}
</code></pre>

<pre><code>在/node_modules/react-native/Libraries/CustomComponents/Navigator/NavigatorSceneConfigs 中预设了很多转场动画。
PushFromRight
PushFromLeft
FloatFromRight // We will want to customize this soon
FloatFromLeft
FloatFromBottom
FloatFromBottomAndroid
FadeAndroid
HorizontalSwipeJump
HorizontalSwipeJumpFromRight
HorizontalSwipeJumpFromLeft
VerticalUpSwipeJump
VerticalDownSwipeJump
</code></pre>

<h4>其他方法</h4>

<pre><code>getCurrentRoutes() - 获取当前栈里的所有路由
jumpBack() - 跳回之前的路由，还保留现在的，还可以再跳回来，会保留原样
jumpForward() - 与上一个方法对应
jumpTo(route) - 跳转到已有的场景并且不卸载
push(route) - 跳转到新的场景，并且将场景入栈
pop() - 跳转回去并且卸载掉当前场景
replace(route) - 用一个新的路由替换掉当前场景
replaceAtIndex(route, index) - 替换掉指定序列的路由场景
replacePrevious(route) - 替换掉之前的场景
resetTo(route) - 跳转到新的场景，并且重置整个路由栈
immediatelyResetRouteStack(routeStack) - 用新的路由数组来重置路由栈
popToRoute(route) - pop到路由指定的场景，在整个路由栈中，处于指定场景之后的场景将会被卸载
popToTop() - pop到栈中的第一个场景，卸载掉所有的其他场景
</code></pre>

<h4>index.ios.js</h4>

<pre><code>import React, {Component} from 'react';
import {View,Navigator,AppRegistry} from 'react-native';
import FirstView from './FirstView';

   var logName = 'Index:--------';

   export default class BaseNavigator extends Component {
     constructor(props){
          console.log(logName + 'constructor');
          super(props);
      }
      componentWillMount(){
          console.log(logName + 'componentWillMount');
      }
       render() {
         console.log(logName+'render')
        return (
        &lt;Navigator
          //把下面一行的/都去掉，因为Markdown转化不了所以加的
          initialRoute=/{/{params: /{/},view: FirstView /}/}
          renderScene={(route, navigator) =&gt; {
            let ShowedView = route.view;
            return &lt;ShowedView {...route.params} nav={navigator} /&gt;
          }} /&gt;
        );
       }

       componentDidMount() {
           console.log(logName + 'componentDidMount');
       }

       componentWillReceiveProps(nextprops){
              console.log(logName + 'componentWillReceiveProps');
        }
        shouldComponentUpdate(nextProps,nextState){
              console.log(logName + 'shouldComponentUpdate');
            return true;
        }
        componentWillUpdate(nextProps,nextState){
              console.log(logName + 'componentWillUpdate');
        }
        componentDidUpdate(prevProps,prevState){
            console.log(logName + 'componentDidUpdate');
        }
        componentWillUnmount(){
            console.log(logName + 'componentWillUnmount');
        }
   }
AppRegistry.registerComponent('MyReact', () =&gt; BaseNavigator);
</code></pre>

<h4>FirstView.js</h4>

<pre><code>import React,{Component} from 'react';
import {View,StyleSheet,Text} from 'react-native';
import SecondView from './SecondView';

var logName = 'FirstView:--------';
export default class FirstView extends Component { 
  constructor(props) {
    console.log(logName + 'constructor');
        super(props);
        this.state = {
            callBackMsg: '',
        };
    }
   componentWillMount(){
       console.log(logName + 'componentWillMount');
   }

    render() {
      console.log(logName+'render')
        return (
            &lt;View style={styles.backView}&gt;
                  &lt;Text style={styles.tapView}  onPress={this.pressedFun.bind(this)}&gt;点击跳转&lt;/Text&gt;
                  &lt;Text style={styles.msgView}&gt;
                    {this.state.callBackMsg}
                  &lt;/Text&gt;
            &lt;/View&gt;
        );
    }
    componentDidMount() {
        console.log(logName + 'componentDidMount');
    }

    componentWillReceiveProps(nextprops){
           console.log(logName + 'componentWillReceiveProps');
     }
     shouldComponentUpdate(nextProps,nextState){
           console.log(logName + 'shouldComponentUpdate');
         return true;
     }
     componentWillUpdate(nextProps,nextState){
           console.log(logName + 'componentWillUpdate');
     }
     componentDidUpdate(prevProps,prevState){
         console.log(logName + 'componentDidUpdate');
     }
     componentWillUnmount(){
         console.log(logName + 'componentWillUnmount');
     }
//-------个人方法--------
    pressedFun() {
        let nav = this.props.nav;
        let tmpThis = this;
            nav.push({
                view: SecondView,
                params:{
                  userId: 123,
                  userName: 'andy',
                  callBackFun: function(newMsg){
                      tmpThis.setState({
                        callBackMsg: newMsg,
                      })
                  },
                },
            });
          }
}

const styles = StyleSheet.create({
  backView:{
    flex: 1,
    justifyContent: 'center',
    backgroundColor: 'azure',
  },
  tapView:{
    fontSize: 20,
    alignSelf: 'center',
    textAlign: 'center',
    width: 130,
    height: 50,
    lineHeight: 50,
    color: 'yellow',
    borderColor: 'yellow',
    borderWidth: 2,
    borderRadius: 25,
    backgroundColor: 'blue',
    overflow: 'hidden',//不然边角会有背景色
  },
  msgView:{
    fontSize: 16,
    marginTop: 30,
    textAlign: 'center',
  },
});
</code></pre>

<h4>SecondView.js</h4>

<pre><code>import React,{Component} from 'react';
import {View,Navigator,StyleSheet,TouchableWithoutFeedback,Image,Text,} from 'react-native';

var logName = 'SecondView:--------';
export default class SecondView extends Component {
  static defaultProps = {
      // testProp: 'testProp默认值',
  }
  static propTypes = {
      // testProp: React.PropTypes.string.isRequired,
  }
  constructor(props) {
        console.log(logName + 'constructor');
        super(props);
        this.state = {};
    }
    componentWillMount(){
        console.log(logName + 'componentWillMount');
    }
    render() {
      console.log(logName+'render')
       return (
            &lt;View style={styles.backView}&gt;
              &lt;View style={styles.titleBackView}&gt;
              &lt;TouchableWithoutFeedback onPress={this.backPressed.bind(this)}&gt;
                 &lt;Image style={styles.backImage} source= {require('./images/backImage.png')}/&gt;
              &lt;/TouchableWithoutFeedback&gt;
                &lt;Text style={styles.titleView}&gt;标题&lt;/Text&gt;
              &lt;/View&gt;
                &lt;Text&gt;上个页面传来的参数userId: {this.props.userId}&lt;/Text&gt;
                &lt;Text&gt;上个页面传来的参数userName: {this.props.userName}&lt;/Text&gt;
            &lt;/View&gt;
        );
    }
    componentDidMount() {
        console.log(logName + 'componentDidMount');
    }

    componentWillReceiveProps(nextprops){
           console.log(logName + 'componentWillReceiveProps');
     }
     shouldComponentUpdate(nextProps,nextState){
           console.log(logName + 'shouldComponentUpdate');
         return true;
     }
     componentWillUpdate(nextProps,nextState){
           console.log(logName + 'componentWillUpdate');
     }
     componentDidUpdate(prevProps,prevState){
         console.log(logName + 'componentDidUpdate');
     }
     componentWillUnmount(){
         console.log(logName + 'componentWillUnmount');
     }

//------个人方法--------
     backPressed() {
         let nav = this.props.nav;
             this.props.callBackFun('这是消失的页面通过回调方法传来的数据！');
             nav.pop();
     }
}
const styles = StyleSheet.create({
  backView:{
    flex: 1,
    backgroundColor: 'bisque',
  },
  titleBackView:{
    height: 65,
    backgroundColor: 'darkkhaki',
    flexDirection: 'row'
  },
  titleView:{
    height:45,
    lineHeight:45,
    marginTop:20,
    color: 'white',
    fontSize: 18,
    textAlign: 'center',
    alignSelf: 'center',
    flex: 1,
    marginRight:20,
  },
  backImage:{
    marginTop:35,
    marginLeft:10,
    width: 10,
    height: 20,
  },
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 组件生命周期]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/30/react-native-life/"/>
    <updated>2016-11-30T11:08:59+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/30/react-native-life</id>
    <content type="html"><![CDATA[<p>生命周期就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期是开发的基础。<a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5语法和ES6语法有所变化</a>。</p>

<p><img src="/myimg/java/life2.png" alt="" /></p>

<h4>可以把组件生命周期大致分为三个阶段：</h4>

<pre><code>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；
第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互接收事件更新界面；
第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。
</code></pre>

<p><strong>constructor(props) :</strong>这个方法会在组件创建的时候调用一次。 这个方法中可以通过this.state初始化状态参数，ES5是通过getInitialState()方法初始化的。</p>

<p><strong>getDefaultProps() :</strong>在组件类创建的时候调用一次，然后返回值被缓存下来。全局调用一次，所有实例共享。</p>

<p><strong>getInitialState() :</strong>在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。</p>

<p><strong>componentWillMount() :</strong>在组件创建并初始化了状态之后，在第一次 render() 之前。可以在这里做一些初始化操作。这个函数在整个生命周期中只被调用一次。</p>

<p><strong>render() :</strong>这个方法是必须的，对视图进行渲染，也可以返回 null 或者 false 来表明不需要渲染任何东西.</p>

<p><strong>componentDidMount() :</strong>在组件第一次绘制之后，会调用该方法通知组件已经加载完成。这个方法调用的时候，其虚拟 DOM 已经构建完成，可以在这个函数里获取其中的元素或者子组件。框架是先调用子组件的该方法，然后再调用父组件的。可以在这里发起网络请求等。</p>

<p><strong>componentWillReceiveProps(nextProps) :</strong> 父组件改变子组件的属性的时候会调用该方法,初次渲染时不会调用该方法。参数nextProps是即将被设置的属性，旧的属性还是可以通过 this.props 来获取。</p>

<p><strong>shouldComponentUpdate(nextProps,nextState) :</strong>当组件接收到新的属性或状态改变的话会调用该方法。参数 nextProps 和上面的方法一样。nextState 表示组件即将更新的状态值。这个方法的返回值决定是否需要更新组件，默认返回true。可以重载这个函数来决定组件是否需要更新。</p>

<p><strong>componentWillUpdate(nextProps,nextState) :</strong>如果组件状态改变，并且上面的方法返回为true，就会开始准更新组件。这里可以做一些在更新组件之前要做的事情。<strong>在这个方法里面不能再调用 this.setState 来修改状态</strong>。这个方法调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着就会调用 render() 来更新组件了。</p>

<p><strong>componentDidUpdate(prevProps,prevState) :</strong>在调用了 render() 更新组件同步到 DOM 中之后立刻调用该方法。因为到这里已经完成了属性和状态的更新了，此方法的参数变成了 prevProps 和 prevState。</p>

<p><strong>componentWillUnmount() :</strong>当组件从 DOM 中移除的时候就会调用该方法。可以这个方法中做一些资源清理工作。</p>

<p><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5 ES6写法对照表</a></p>

<p><a href="http://blog.kdchang.cc/2016/04/04/react-react-native-es5-es6-cheat-sheet/">ES5 ES6区别</a></p>

<p><a href="https://babeljs.io/blog/2015/06/07/react-on-es6-plus">React on ES6</a></p>

<p><a href="http://egorsmirnov.me/2015/06/14/react-and-es6-part2.html">React and ES6</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flexbox 布局]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/30/css-flex-box/"/>
    <updated>2016-11-30T08:56:06+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/30/css-flex-box</id>
    <content type="html"><![CDATA[<p>弹性盒子布局由弹性容器和弹性子item组成。容器默认存在两根轴：水平的主轴和垂直的交叉轴。主轴的开始位置叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。item默认沿主轴排列。item占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size
<img src="/myimg/java/flexbox.png" width="600" alt="" /></p>

<p><strong>用在容器上的属性：</strong>
<code>
flex-direction :决定item的排列方向。(row,row-reverse,column,column-reverse)
flex-wrap :决定item如何换行。(nowrap,wrap,wrap-reverse)
justify-content :决定itme在主轴上的对齐方式。(flex-start,flex-end,center,space-between,space-around)
align-items :决定item在交叉轴上的对齐方式。(stretch,flex-start,flex-end,center,baseline:item第一行文字基线对齐)
align-content :决定多条交叉轴线的对齐方式。(flex-start,flex-end,center,space-between,space-around,stretch)
</code>
align-content:</p>

<p><img src="/myimg/java/flex1.png" width="400" alt="" /></p>

<p><strong>用在Item上的属性</strong></p>

<pre><code>order :定义item的排列顺序。数值越小，排列越靠前，默认为0。
flex-grow :定义item的放大比例。默认为0，即如果存在剩余空间也不放大。有多个的话按比例均分。
flex-shrink :定义item的缩小比例。默认为1，即如果空间不足，该项目将缩小。0则不缩小。
flex-basis :定义了在分配多余空间之前，item占据的主轴空间,默认auto,即本来大小。
flex : flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。
align-self :设置item自身在交叉轴上的对齐方式。可覆盖align-items属性。
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
(auto,flex-start,flex-end,center,baseline,stretch)
</code></pre>

<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，也有些差异:flexDirection的默认值是column而不是row，alignItems的默认值是stretch而不是flex-start。使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求。</p>

<p><code>flexDirection</code>: 决定布局的主轴。子元素是沿着水平轴方向排列，还是沿着竖直轴方向排列。</p>

<p><code>justifyContent</code>: 决定子元素沿着主轴的排列方式。有flex-start、center、flex-end、space-around 和 space-between。</p>

<p><code>alignItems</code>: 决定其子元素沿着交叉轴的排列方式。有flex-start、center、flex-end以及stretch。<strong>注意：要使stretch选项生效的话，子元素在次轴方向上不能固定尺寸。</strong></p>

<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Fexbox布局实例</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 样式属性]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/29/rn-style/"/>
    <updated>2016-11-29T22:27:51+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/29/rn-style</id>
    <content type="html"><![CDATA[<p>React Native 采用CSS样式来布局，也会有继承和覆盖作用。只要在样式表中书写一个不存在的样式，就会报错，提示该样式不存在，然后提供所有可用的样式：
<img src="/myimg/java/style.png" alt="" /></p>

<pre><code>//边框
borderBottomWidth 
borderLeftWidth 
borderRightWidth 
borderTopWidth 
borderWidth 
</code></pre>

<pre><code>//边框颜色
borderBottomColor
borderLeftColor
borderRightColor
borderTopColor
borderColor
</code></pre>

<pre><code>//外边距
marginTop
marginBottom
marginLeft
marginRight
marginVertical //相当于marginTop 和 marginBottom
marginHorizontal //相当于 marginLeft 和 marginRight
margin
</code></pre>

<pre><code>//内边距  
paddingTop  
paddingBottom
paddingLeft  
paddingRight  
paddingVertical //相当于 paddingTop 和 paddingBottom
paddingHorizontal  //相当于 paddingLeft 和 paddingRight
padding 
</code></pre>

<pre><code>//边框圆角
borderTopLeftRadius
borderTopRightRadius
borderBottomLeftRadius
borderBottomRightRadius
borderRadius
</code></pre>

<pre><code>//flex 布局
flex number 
flexDirection enum('row', 'column') 
flexWrap enum('wrap', 'nowrap') 
alignItems enum('flex-start', 'flex-end', 'center', 'stretch') 
alignSelf enum('auto', 'flex-start', 'flex-end', 'center', 'stretch') 
justifyContent enum('flex-start', 'flex-end', 'center', 'space-between', 'space-around') 
position属性值为absolute和relative，当使用绝对布局时，定位根据屏幕来进行。
</code></pre>

<pre><code>//字体相关属性
color 字体颜色
fontFamily 字体族
fontSize 字体大小
fontStyle 字体样式，正常，倾斜等，值为enum('normal', 'italic')
fontWeight 字体粗细，值为enum("normal", 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900')
letterSpacing 字符间隔
lineHeight 行高
textAlign 字体对齐方式，值为enum("auto", 'left', 'right', 'center', 'justify')
textDecorationLine 上划线，下划线，删除线，无修饰，值为enum("none", 'underline', 'line-through', 'underline line-through')
textDecorationStyle 修饰的线的类型 enum("solid", 'double', 'dotted', 'dashed')
textDecorationColor 修饰的线的颜色
writingDirection enum("auto", 'ltr', 'rtl') 书写方向，从左往右写还是从右往左写
</code></pre>

<pre><code>//图片相关属性
resizeMode enum('cover', 'contain', 'stretch')
overflow enum('visible', 'hidden') 超出部分是否显示，hidden为隐藏
tintColor 着色，rgb字符串类型
opacity 透明度
scaleX:水平方向缩放
scaleY:垂直方向缩放
rotation:旋转
translateX:水平方向平移
translateY:水平方向平移
//阴影,默认透明的，要设置shadowOpacity大于0才有效果
shadowColor
shadowOffset
shadowOpacity
shadowRadius
</code></pre>
]]></content>
  </entry>
  
</feed>
