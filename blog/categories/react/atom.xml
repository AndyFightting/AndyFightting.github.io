<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: React | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/react/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-12-09T18:40:01+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Node.js]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/03/node-js/"/>
    <updated>2016-12-03T10:24:36+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/03/node-js</id>
    <content type="html"><![CDATA[<p>Node.js 是运行在服务端的 JavaScript。Node.js 应用是由几部分组成的：</p>

<pre><code>1. 引入 require 模块：可以使用 require 指令来载入 Node.js 模块。
2. 创建服务器：服务器可以监听客户端的请求
3. 接收请求与响应请求: 可以使用浏览器或客户端发送 HTTP 请求，服务器接收请求后返回响应数据。
</code></pre>

<h4>Hello World</h4>

<p>创建一个test.js文件，里面输入如下内容。终端进入文件所在文件夹，执行<code>node test.js</code>,浏览器地址栏输入<code>http://127.0.0.1:8888/</code>就可以看到Hello World了。</p>

<pre><code>//引用http模块
var http = require('http');
http.createServer(function (request, response) {
    // 发送 HTTP 头部 
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, {'Content-Type': 'text/plain'});
    // 发送响应数据 "Hello World"
    response.end('Hello World！\n');
}).listen(8888);
</code></pre>

<p><img src="/myimg/react/nodeHello.png" width="400" alt="" /></p>

<h4>NPM</h4>

<p>npm 是js包管理工具，像 CocoaPods 似的可以下载被人编写的第三方包，也可以把自己写的包上传的npm服务器。</p>

<p><code>npm install 包名</code> 本地安装,将安装包放在 ./node_modules 下，如果没有 node_modules 文件夹，会在当前执行 npm 命令的目录下生成 node_modules 文件夹。然后就可以通过require(包名) 来引入本地安装的包。</p>

<p><code>npm install 包名字 -g</code> 全局安装，将安装包放在 /usr/local 下或者 node 的安装目录。</p>

<p><code>npm uninstall 包名</code> 卸载包</p>

<p><code>npm update 包名</code> 更新包</p>

<p><code>npm search 包名</code> 搜索包</p>

<h4>package.json</h4>

<p>package.json 用于表示需要安装的包的属性，如名字，版本，依赖等。package.json 文件是必不可少的。可通过<code>npm init</code>创建该文件。</p>

<pre><code>//Package.json 属性说明
name - 包名。
version - 包的版本号。
description - 包的描述。
homepage - 包的官网 url 。
author - 包的作者姓名。
contributors - 包的其他贡献者姓名。
dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。
repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。
main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require("express")。
keywords - 关键字
</code></pre>

<h4>回调函数</h4>

<p>Node.js 异步编程的直接体现就是回调。Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>

<pre><code>//顺序执行
var fs = require("fs");
var data = fs.readFileSync('input.txt');
console.log(data.toString());
console.log("程序执行结束!");

//异步回调
var fs = require("fs");
fs.readFile('input.txt', function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});
console.log("程序执行结束!");
</code></pre>

<h4>事件驱动</h4>

<p>Node.js 每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用并处理并发。基本上所有的事件机制都是用观察者模式实现。当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。
当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p>

<p><img src="/myimg/react/reactevent.png" width="400" alt="" /></p>

<p>在 Node 应用程序中，执行异步操作将回调函数作为最后一个参数， 回调函数里接收错误的对象作为回调函数的第一个参数。</p>

<pre><code>//回调函数是readFile的最后一个参数，err是回调函数的第一个参数
var fs = require("fs");
fs.readFile('input.txt', function (err, data) {
   if (err){
      console.log(err.stack);
      return;
   }
   console.log(data.toString());
});
console.log("程序执行完毕");
</code></pre>

<p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。许多对象都会分发事件，如一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是基于 events.EventEmitter 的实例。</p>

<p>events 模块只提供了一个对象： events.EventEmitter(事件分发器)。EventEmitter 的核心就是事件触发与事件监听器功能的封装。
可以通过require(&ldquo;events&rdquo;);来访问该模块。EventEmitter 对象如果在实例化时发生错误，会触发 &lsquo;error&rsquo; 事件。当添加新的监听器时，'newListener' 事件会触发，当监听器被移除时，'removeListener' 事件被触发。EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>

<pre><code>var events = require('events'); 
var emitter = new events.EventEmitter(); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener1', arg1, arg2); 
}); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener2', arg1, arg2); 
}); 
emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); 

//打印出
//listener1 arg1 参数 arg2 参数
//listener2 arg1 参数 arg2 参数
</code></pre>

<h4>EventEmitter 方法</h4>

<pre><code>addListener(eventName, listenerFun): 为指定事件添加一个监听器到监听器数组的尾部。
on(eventName, listenerFun):为指定事件注册一个监听器，接受一个字符串 eventName 和一个回调函数。
once(eventName, listenerFun): 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。
removeListener(eventName, listenerFun):移除指定事件的某个监听器，监听器 必须是该事件已经注册过的监听器。
removeAllListeners([eventName]):移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。
setMaxListeners(n)：默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。
listeners(eventName)：返回指定事件的监听器数组。
emit(eventName, [arg1], [arg2], [...]):按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。
listenerCount(emitter, eventName):类方法，返回指定事件的监听器数量。
</code></pre>

<p>实例：</p>

<pre><code>var events = require('events');
var eventEmitter = new events.EventEmitter();

// 监听器1   
var listener1 = function listener1() {
   console.log('监听器 listener1 执行。');
}

// 监听器2       
var listener2 = function listener2() {
  console.log('监听器 listener2 执行。');
}

// 绑定 connection 事件，处理函数为 listener1 
eventEmitter.addListener('connection', listener1);

// 绑定 connection 事件，处理函数为 listener2
eventEmitter.on('connection', listener2);

var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');
console.log(eventListeners + " 个监听器监听连接事件。");

// 处理 connection 事件 
eventEmitter.emit('connection');

// 移除监绑定的 listener1 函数
eventEmitter.removeListener('connection', listener1);
console.log("listener1 不再受监听。");

// 触发连接事件
eventEmitter.emit('connection');

eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');
console.log(eventListeners + " 个监听器监听连接事件。");

console.log("程序执行完毕。");

//打印结果
//2 个监听器监听连接事件。
//监听器 listener1 执行。
//监听器 listener2 执行。
//listener1 不再受监听。
//监听器 listener2 执行。
//1 个监听器监听连接事件。
//程序执行完毕
</code></pre>

<h5>error 事件</h5>

<p>EventEmitter 定义了一个特殊的事件<code>error</code>，它包含了错误的语义，在遇到异常的时候通常会触发 error 事件。
当 error 被触发时，如果没有对应的监听器就会把它当作异常，退出程序并输出错误信息。
所以要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。</p>

<p>大多数时候不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，
只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>

<h4>Buffer 类</h4>

<p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理文件流时，必须使用到二进制数据。
所以在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。可以让 Node.js 处理二进制数据，
每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。
一个 Buffer 类似于一个整数数组，utf-8 是默认的编码方式。</p>

<pre><code>//写数据
buf.write(string, offset, length, encoding)；
string - 写入缓冲区的字符串。
offset - 缓冲区开始写入的索引值，默认为 0 。
length - 写入的字节数，默认为 buffer.length。
encoding - 使用的编码。默认为 'utf8' 。
返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。

//读数据
buf.toString(encoding, start, end)；
encoding - 使用的编码。默认为 'utf8' 。
start - 指定开始读取的索引位置，默认为 0。
end - 结束位置，默认为缓冲区的末尾。
返回值是用指定的编码返回字符串。
</code></pre>

<h5>常用方法</h5>

<pre><code>new Buffer(size)：配一个新的 size 大小单位为8位字节的 buffer。
new Buffer(buffer)：拷贝参数 buffer 的数据到 Buffer 实例。
new Buffer(str, encoding)分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 'utf8'。
buf.length: 返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。
buf.write(string[, offset[, length]][, encoding]):写入数据。
buf.toJSON()：将 Buffer 实例转换为 JSON 对象。
buf.equals(otherBuffer)：比较两个缓冲区是否相等。
buf.compare(otherBuffer):比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。
buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]):buffer 拷贝，源和目标可以相同。 
targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。
</code></pre>

<h4>Stream 流</h4>

<p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。
<strong>所有的 Stream 对象都是 EventEmitter 的实例</strong></p>

<pre><code>Stream 有四种流类型：
1. Readable - 可读操作。
2. Writable - 可写操作。
3. Duplex - 可读可写操作.
4. Transform - 操作被写入数据，然后读出结果。

所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：
data - 当有数据可读时触发。
end - 没有更多的数据可读时触发。
error - 在接收和写入过程中发生错误时触发。
finish - 所有数据已被写入到底层系统时触发。
</code></pre>

<p>读取文件例子：</p>

<pre><code>var fs = require("fs");
var data = '';

// 创建可读流
var readerStream = fs.createReadStream('input.txt');

// 设置编码为 utf8。
readerStream.setEncoding('UTF8');

// 处理流事件 --&gt; data, end, and error
readerStream.on('data', function(chunk) {
   data += chunk;
});

readerStream.on('end',function(){
   console.log(data);
});

readerStream.on('error', function(err){
   console.log(err.stack);
});

console.log("程序执行完毕");
</code></pre>

<h4>模块系统</h4>

<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。一个 Node.js 文件就是一个模块，这个文件可能是JavaScript、JSON 或者编译过的C/C++ 扩展等。
Node.js 提供了<code>exports</code> 和 <code>require</code> 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p>

<p>require方法中的文件查找策略：</p>

<p><img src="/myimg/react/require.png" width="400" alt="" /></p>

<h4>函数</h4>

<p>在JavaScript中，一个函数可以作为另一个函数的参数。可以先定义一个函数变量，然后传递，也可以在传递参数的地方直接定义函数(不要名字的函数，匿名函数)。</p>

<pre><code>function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, "Hello");

//也可以直接传递匿名函数

function execute(someFunction, value) {
  someFunction(value);
}

execute(function(word){ console.log(word) }, "Hello");
</code></pre>

<h4>全局对象</h4>

<p>JavaScript 中有一个特殊的对象，称为全局对象，它及其所有属性都可以在程序的任何地方访问，即全局变量。
在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。
在 Node.js 可以直接访问到 global 对象的属性，而不需要在应用中包含它。<strong>注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。</strong></p>

<pre><code>满足以下条 件的变量是全局变量：
1.在最外层定义的变量；
2.全局对象的属性；
3.隐式定义的变量（未定义直接赋值的变量）。
</code></pre>

<p><strong>__filename ：</strong>表示当前正在执行的文件名,输出文件的绝对路径。</p>

<p><strong>__dirname ：</strong>表示当前正在执行的文件目录。</p>

<p><strong>setTimeout(cb, ms) :</strong> 全局函数,在指定的毫秒(ms)数后执行指定函数(cb)。只执行一次指定函数。返回一个代表定时器的句柄值。</p>

<p><strong>clearTimeout(t) :</strong> 全局函数,用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。</p>

<p><strong>setInterval(cb, ms) :</strong>setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。
返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。
setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</p>

<p><strong>console :</strong> 全局对象，常用方法有<code>console.log()</code>,<code>console.info()</code>,<code>console.warn()</code>,<code>console.error()</code></p>

<p><strong>process :</strong>全局变量，即 global 对象的属性。便于我们更好的控制系统的交互,很多属性和方法。<code>process.stdout</code>,<code>process.exet()</code>&hellip;</p>

<p><a href="https://nodejs.org/dist/latest-v7.x/docs/api/">Node.js API</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 基础组件]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/02/react-base-view/"/>
    <updated>2016-12-02T09:12:24+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/02/react-base-view</id>
    <content type="html"><![CDATA[<p>这里主要记录看 <a href="https://github.com/facebook/react-native">React Native 官方例子</a> 的基础组件过程中，记录一些比较特殊或需要注意的地方。
<img src="/myimg/react/view0.png" width="800" alt="" /></p>

<h4>View</h4>

<pre><code>//宽度自适应,需要在Text的父控件上设置alignSelf属性！
必须把文字放在&lt;Text&gt;组件内。不能直接在&lt;View&gt;下放置一段文字。
值为flex-start,center,flex-end都会自适应！而auto,stretch则不会！
&lt;View style=&gt;
    &lt;Text&gt;这里的文字会自适应宽度！&lt;/Text&gt;
&lt;/View&gt;

//背景色和圆角问题
当设置了背景色又设置了圆角时，需要设置 overflow: 'hidden' ，否则四个角会有背景色！前提是这个View里有子组件，
因为像css似的背景色会继承到子组件中！四个角显示的是子组件的背景色。
所以不用overflow,把子组件背景色设置透明transparent也可以。 

//overflow:(visible,hidden,scroll),设置子组件超出父组件的话该如何显示。
visible:默认值。内容不会被修剪，会呈现在元素框之外。
hidden:内容会被修剪，并且其余内容是不可见的。
scroll:内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。

//不透明opacity:(0~1),1不透明，0透明。

//zIndex是从屏幕指向外的z轴。

//一般用TouchableWithoutFeedback onPress 来接收点击事件。  
</code></pre>

<h4>Image</h4>

<pre><code>//Image里也可以嵌套。也可以显示gif

//capInsets {top, left, bottom, right} ,9-patch图片效果。

//tintColor: 为所有非透明的像素指定一个颜色.(tint:染，给...着色)

//resizeMode: 图片如何显示
Image.resizeMode.cover(按比例充满),(默认值)
Image.resizeMode.contain(按比例包含),
Image.resizeMode.stretch(拉伸充满),
Image.resizeMode.center(按比例居中),
Image.resizeMode.repeat(原比例重复显示)

 //如果 source 或者 uri 属性值有http前缀的话，会自动下载图片。

  //加载网络图片的一些回调方法，不论成功失败都会调用onLoadEnd
  &lt;Image
     style=/{/{width:300,height:100/}/} //把/去掉
     defaultSource={require('./images/msg.png')}
     onLoadStart={() =&gt; { console.log('Image:-----onLoadStart') }}
     onProgress={() =&gt; { console.log('Image:-----onProgress')  }}
     onLoad={() =&gt; { console.log('Image:-----onLoad')  }}//成功
     onError={() =&gt; { console.log('Image:-----onError')  }}//失败
     onLoadEnd={() =&gt; { console.log('Image:-----onLoadEnd')  }}//不论成功失败都会被调用
     source=/{/{uri:'https:xxx.png'/}/} //把/都去掉
    /&gt;
</code></pre>

<h4>图片加载成功</h4>

<p><img src="/myimg/react/images.png" width="400" alt="" /></p>

<h4>图片加载失败</h4>

<p><img src="/myimg/react/imagee.png" width="400" alt="" /></p>

<h4>Text</h4>

<pre><code>//Text里也可以嵌套其他组件。嵌套的空间是span样式而不是div块。

//文字居中除了要设置textAlign='center'，外还需设置lineHeight = height,因为textAlign只是水平对齐方式。

//Text本身设置alignSelf为flex-start,center,flex-end也会宽度自适应。

//fontStyle: (italic,normal,oblique).

//textDecorationLine:(none,underline,line-through,underline line-through)

//textDecorationStyle: (dashed,dotted,double,solid)

//letterSpacing: 字符间距

//Text有onPress，onLongPress.样式属性值可以通过state动态改变。

//ellipsizeMode: (clip,head,middle,tail,wordWrapping) wordWrapping:三个点都不显示

//adjustsFontSizeToFit: iOS的自动调整字体大小
</code></pre>

<h4>Button</h4>

<pre><code>//color: iOS是设置文字颜色，而Android是设置背景色.title 和 onPress两个属性是必须的。
Button可以属性很少啊，style样式都没用...一般用TouchableOpacity或TouchableNativeFeedback嵌套Text来自定义按钮。
</code></pre>

<h4>ScrollView</h4>

<p>ScrollView适合用来显示数量不多的滚动元素。放置在ScollView中的所有组件都会被渲染，哪怕有些组件因为内容太长被挤出了屏幕外。如果需要显示较长的滚动列表，应该使用ListView组件。代码在<code>/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js</code>。</p>

<p>发现一个奇怪的地方，如果ScrollView的父View设置了flex=1的话，再设置ScrollView的height就没效果了，ScrollView还是会充满父View ！</p>

<pre><code>//常用属性
ref //暴露一个引用
contentContainerStyle //内容容器样式，所以子控件都在内容容器里
automaticallyAdjustContentInsets //iOS的顶部是否留有空间，一般都设false，不知道干啥要弄出个这属性。
horizontal //true/false,水平排列还是垂直排列
keyboardDismissMode //none,interactive,onDrag.滚动时是否隐藏键盘，none不，onDrag开始拖动就隐藏，interactive:iOS的键盘位置同步变化。
keyboardShouldPersistTaps //true/false: 默认false:点击输入框外部会收起键盘。true:点击输入框外部不会自动收起键盘，scroll不会受到点击事件，但子控件可以收到。
onContentSizeChange //scroll的content size 变化是回调该方法。参数是contentWidth, contentHeight。
onScroll //滚动时实时调用，频率可以通过scrollEventThrottle属性设置。
pagingEnabled //是否分页
refreshControl //一个RefreshControl组件，用于下拉刷新。
removeClippedSubviews //是否移除scroll屏幕外的子视图，可以提高scroll性能，默认true。
scrollEnabled //是否能滚动，默认当然true。
showsHorizontalScrollIndicator //是否显示水平滚动条。
showsVerticalScrollIndicator //是否显示垂直滚动条
alwaysBounceHorizontal,alwaysBounceVertical //当内容小于size时，是否还bounce.
bounces //是否可以bounces，优先级高于上面的两个。
centerContent //当内容小于size时，是否居中。
contentInset = //inset
contentOffset= //offset
</code></pre>

<h4>ListView</h4>

<h4>TabBar</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native Navigator]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/01/react-navigator/"/>
    <updated>2016-12-01T09:27:30+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/01/react-navigator</id>
    <content type="html"><![CDATA[<p>这里主要记录一下Navigator的基本使用，页面间的传参，回调，以及在push,pop过程中生命周期方法的调用顺序。</p>

<p>React 的“页面”的概念和Android或iOS有点不一样，不像Android有个Activity作为页面容器，iOS有Controller作为页面容器。React 的“页面”本身就是一个组件集合，和Text,Image等基础组件是一个级别的东西。只不过是把多个组件拼起来充满屏幕，就组成一个“页面”了。</p>

<p>通过在Navigator的route里放置一个params参数，params里面放key-value传参。注意，方法也是对象，也可以当做value传递，这样就可回调了。就像Android的接口回调或iOS的block似的，在A页面实现方法，然后传递给B页面，在B页面使用方法，这样数据就从B回传给A了。数据从方法使用的地方传到方法实现的地方。</p>

<h4>在Index.js里初始化Navigator并且显示第一个页面FirstView:</h4>

<p><img src="/myimg/java/lift0.png" width="500" alt="" /></p>

<h4>从FirstView push 到SecondView</h4>

<p><img src="/myimg/java/lift1.png" width="500" alt="" /></p>

<h4>不调用FirstView的回调方法直接pop。</h4>

<p><img src="/myimg/java/life3.png" width="500" alt="" /></p>

<h4>如果在SecondView里点击返回的时候，先掉用FirstView的回调方法, 在回调方法里调用 setState() 刷新FirstView，然后 pop 。</h4>

<p><img src="/myimg/java/lift2.png" width="500" alt="" /></p>

<p>从上面可以看出不管是从A到B还是从B返回A,A的componentWillReceiveProps都会被调用! A的更新流程都会先走一遍！</p>

<p><img src="/myimg/java/life4.png" width="600" alt="" /></p>

<pre><code>configureScene 属性用来配置场景动画。
configureScene={(route, routeStack) =&gt; {
                return Navigator.SceneConfigs.PushFromRight;
              }}
</code></pre>

<pre><code>在/node_modules/react-native/Libraries/CustomComponents/Navigator/NavigatorSceneConfigs 中预设了很多转场动画。
PushFromRight
PushFromLeft
FloatFromRight // We will want to customize this soon
FloatFromLeft
FloatFromBottom
FloatFromBottomAndroid
FadeAndroid
HorizontalSwipeJump
HorizontalSwipeJumpFromRight
HorizontalSwipeJumpFromLeft
VerticalUpSwipeJump
VerticalDownSwipeJump
</code></pre>

<h4>其他方法</h4>

<pre><code>getCurrentRoutes() - 获取当前栈里的所有路由
jumpBack() - 跳回之前的路由，还保留现在的，还可以再跳回来，会保留原样
jumpForward() - 与上一个方法对应
jumpTo(route) - 跳转到已有的场景并且不卸载
push(route) - 跳转到新的场景，并且将场景入栈
pop() - 跳转回去并且卸载掉当前场景
replace(route) - 用一个新的路由替换掉当前场景
replaceAtIndex(route, index) - 替换掉指定序列的路由场景
replacePrevious(route) - 替换掉之前的场景
resetTo(route) - 跳转到新的场景，并且重置整个路由栈
immediatelyResetRouteStack(routeStack) - 用新的路由数组来重置路由栈
popToRoute(route) - pop到路由指定的场景，在整个路由栈中，处于指定场景之后的场景将会被卸载
popToTop() - pop到栈中的第一个场景，卸载掉所有的其他场景
</code></pre>

<h4>index.ios.js</h4>

<pre><code>import React, {Component} from 'react';
import {View,Navigator,AppRegistry} from 'react-native';
import FirstView from './FirstView';

   var logName = 'Index:--------';

   export default class BaseNavigator extends Component {
     constructor(props){
          console.log(logName + 'constructor');
          super(props);
      }
      componentWillMount(){
          console.log(logName + 'componentWillMount');
      }
       render() {
         console.log(logName+'render')
        return (
        &lt;Navigator
          //把下面一行的/都去掉，因为Markdown转化不了所以加的
          initialRoute=/{/{params: /{/},view: FirstView /}/}
          renderScene={(route, navigator) =&gt; {
            let ShowedView = route.view;
            return &lt;ShowedView {...route.params} nav={navigator} /&gt;
          }} /&gt;
        );
       }

       componentDidMount() {
           console.log(logName + 'componentDidMount');
       }

       componentWillReceiveProps(nextprops){
              console.log(logName + 'componentWillReceiveProps');
        }
        shouldComponentUpdate(nextProps,nextState){
              console.log(logName + 'shouldComponentUpdate');
            return true;
        }
        componentWillUpdate(nextProps,nextState){
              console.log(logName + 'componentWillUpdate');
        }
        componentDidUpdate(prevProps,prevState){
            console.log(logName + 'componentDidUpdate');
        }
        componentWillUnmount(){
            console.log(logName + 'componentWillUnmount');
        }
   }
AppRegistry.registerComponent('MyReact', () =&gt; BaseNavigator);
</code></pre>

<h4>FirstView.js</h4>

<pre><code>import React,{Component} from 'react';
import {View,StyleSheet,Text} from 'react-native';
import SecondView from './SecondView';

var logName = 'FirstView:--------';
export default class FirstView extends Component { 
  constructor(props) {
    console.log(logName + 'constructor');
        super(props);
        this.state = {
            callBackMsg: '',
        };
    }
   componentWillMount(){
       console.log(logName + 'componentWillMount');
   }

    render() {
      console.log(logName+'render')
        return (
            &lt;View style={styles.backView}&gt;
                  &lt;Text style={styles.tapView}  onPress={this.pressedFun.bind(this)}&gt;点击跳转&lt;/Text&gt;
                  &lt;Text style={styles.msgView}&gt;
                    {this.state.callBackMsg}
                  &lt;/Text&gt;
            &lt;/View&gt;
        );
    }
    componentDidMount() {
        console.log(logName + 'componentDidMount');
    }

    componentWillReceiveProps(nextprops){
           console.log(logName + 'componentWillReceiveProps');
     }
     shouldComponentUpdate(nextProps,nextState){
           console.log(logName + 'shouldComponentUpdate');
         return true;
     }
     componentWillUpdate(nextProps,nextState){
           console.log(logName + 'componentWillUpdate');
     }
     componentDidUpdate(prevProps,prevState){
         console.log(logName + 'componentDidUpdate');
     }
     componentWillUnmount(){
         console.log(logName + 'componentWillUnmount');
     }
//-------个人方法--------
    pressedFun() {
        let nav = this.props.nav;
        let tmpThis = this;
            nav.push({
                view: SecondView,
                params:{
                  userId: 123,
                  userName: 'andy',
                  callBackFun: function(newMsg){
                      tmpThis.setState({
                        callBackMsg: newMsg,
                      })
                  },
                },
            });
          }
}

const styles = StyleSheet.create({
  backView:{
    flex: 1,
    justifyContent: 'center',
    backgroundColor: 'azure',
  },
  tapView:{
    fontSize: 20,
    alignSelf: 'center',
    textAlign: 'center',
    width: 130,
    height: 50,
    lineHeight: 50,
    color: 'yellow',
    borderColor: 'yellow',
    borderWidth: 2,
    borderRadius: 25,
    backgroundColor: 'blue',
    overflow: 'hidden',//不然边角会有背景色
  },
  msgView:{
    fontSize: 16,
    marginTop: 30,
    textAlign: 'center',
  },
});
</code></pre>

<h4>SecondView.js</h4>

<pre><code>import React,{Component} from 'react';
import {View,Navigator,StyleSheet,TouchableWithoutFeedback,Image,Text,} from 'react-native';

var logName = 'SecondView:--------';
export default class SecondView extends Component {
  static defaultProps = {
      // testProp: 'testProp默认值',
  }
  static propTypes = {
      // testProp: React.PropTypes.string.isRequired,
  }
  constructor(props) {
        console.log(logName + 'constructor');
        super(props);
        this.state = {};
    }
    componentWillMount(){
        console.log(logName + 'componentWillMount');
    }
    render() {
      console.log(logName+'render')
       return (
            &lt;View style={styles.backView}&gt;
              &lt;View style={styles.titleBackView}&gt;
              &lt;TouchableWithoutFeedback onPress={this.backPressed.bind(this)}&gt;
                 &lt;Image style={styles.backImage} source= {require('./images/backImage.png')}/&gt;
              &lt;/TouchableWithoutFeedback&gt;
                &lt;Text style={styles.titleView}&gt;标题&lt;/Text&gt;
              &lt;/View&gt;
                &lt;Text&gt;上个页面传来的参数userId: {this.props.userId}&lt;/Text&gt;
                &lt;Text&gt;上个页面传来的参数userName: {this.props.userName}&lt;/Text&gt;
            &lt;/View&gt;
        );
    }
    componentDidMount() {
        console.log(logName + 'componentDidMount');
    }

    componentWillReceiveProps(nextprops){
           console.log(logName + 'componentWillReceiveProps');
     }
     shouldComponentUpdate(nextProps,nextState){
           console.log(logName + 'shouldComponentUpdate');
         return true;
     }
     componentWillUpdate(nextProps,nextState){
           console.log(logName + 'componentWillUpdate');
     }
     componentDidUpdate(prevProps,prevState){
         console.log(logName + 'componentDidUpdate');
     }
     componentWillUnmount(){
         console.log(logName + 'componentWillUnmount');
     }

//------个人方法--------
     backPressed() {
         let nav = this.props.nav;
             this.props.callBackFun('这是消失的页面通过回调方法传来的数据！');
             nav.pop();
     }
}
const styles = StyleSheet.create({
  backView:{
    flex: 1,
    backgroundColor: 'bisque',
  },
  titleBackView:{
    height: 65,
    backgroundColor: 'darkkhaki',
    flexDirection: 'row'
  },
  titleView:{
    height:45,
    lineHeight:45,
    marginTop:20,
    color: 'white',
    fontSize: 18,
    textAlign: 'center',
    alignSelf: 'center',
    flex: 1,
    marginRight:20,
  },
  backImage:{
    marginTop:35,
    marginLeft:10,
    width: 10,
    height: 20,
  },
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 组件生命周期]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/30/react-native-life/"/>
    <updated>2016-11-30T11:08:59+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/30/react-native-life</id>
    <content type="html"><![CDATA[<p>生命周期就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期是开发的基础。<a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5语法和ES6语法有所变化</a>。</p>

<p><img src="/myimg/java/life2.png" alt="" /></p>

<h4>可以把组件生命周期大致分为三个阶段：</h4>

<pre><code>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；
第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互接收事件更新界面；
第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。
</code></pre>

<p><strong>constructor(props) :</strong>这个方法会在组件创建的时候调用一次。 这个方法中可以通过this.state初始化状态参数，ES5是通过getInitialState()方法初始化的。</p>

<p><strong>getDefaultProps() :</strong>在组件类创建的时候调用一次，然后返回值被缓存下来。全局调用一次，所有实例共享。</p>

<p><strong>getInitialState() :</strong>在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。</p>

<p><strong>componentWillMount() :</strong>在组件创建并初始化了状态之后，在第一次 render() 之前。可以在这里做一些初始化操作。这个函数在整个生命周期中只被调用一次。</p>

<p><strong>render() :</strong>这个方法是必须的，对视图进行渲染，也可以返回 null 或者 false 来表明不需要渲染任何东西.</p>

<p><strong>componentDidMount() :</strong>在组件第一次绘制之后，会调用该方法通知组件已经加载完成。这个方法调用的时候，其虚拟 DOM 已经构建完成，可以在这个函数里获取其中的元素或者子组件。框架是先调用子组件的该方法，然后再调用父组件的。可以在这里发起网络请求等。</p>

<p><strong>componentWillReceiveProps(nextProps) :</strong> 父组件改变子组件的属性的时候会调用该方法,初次渲染时不会调用该方法。参数nextProps是即将被设置的属性，旧的属性还是可以通过 this.props 来获取。</p>

<p><strong>shouldComponentUpdate(nextProps,nextState) :</strong>当组件接收到新的属性或状态改变的话会调用该方法。参数 nextProps 和上面的方法一样。nextState 表示组件即将更新的状态值。这个方法的返回值决定是否需要更新组件，默认返回true。可以重载这个函数来决定组件是否需要更新。</p>

<p><strong>componentWillUpdate(nextProps,nextState) :</strong>如果组件状态改变，并且上面的方法返回为true，就会开始准更新组件。这里可以做一些在更新组件之前要做的事情。<strong>在这个方法里面不能再调用 this.setState 来修改状态</strong>。这个方法调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着就会调用 render() 来更新组件了。</p>

<p><strong>componentDidUpdate(prevProps,prevState) :</strong>在调用了 render() 更新组件同步到 DOM 中之后立刻调用该方法。因为到这里已经完成了属性和状态的更新了，此方法的参数变成了 prevProps 和 prevState。</p>

<p><strong>componentWillUnmount() :</strong>当组件从 DOM 中移除的时候就会调用该方法。可以这个方法中做一些资源清理工作。</p>

<p><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5 ES6写法对照表</a></p>

<p><a href="http://blog.kdchang.cc/2016/04/04/react-react-native-es5-es6-cheat-sheet/">ES5 ES6区别</a></p>

<p><a href="https://babeljs.io/blog/2015/06/07/react-on-es6-plus">React on ES6</a></p>

<p><a href="http://egorsmirnov.me/2015/06/14/react-and-es6-part2.html">React and ES6</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flexbox 布局]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/30/css-flex-box/"/>
    <updated>2016-11-30T08:56:06+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/30/css-flex-box</id>
    <content type="html"><![CDATA[<p>弹性盒子布局由弹性容器和弹性子item组成。容器默认存在两根轴：水平的主轴和垂直的交叉轴。主轴的开始位置叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。item默认沿主轴排列。item占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size
<img src="/myimg/java/flexbox.png" width="600" alt="" /></p>

<p><strong>用在容器上的属性：</strong>
<code>
flex-direction :决定item的排列方向。(row,row-reverse,column,column-reverse)
flex-wrap :决定item如何换行。(nowrap,wrap,wrap-reverse)
justify-content :决定itme在主轴上的对齐方式。(flex-start,flex-end,center,space-between,space-around)
align-items :决定item在交叉轴上的对齐方式。(stretch,flex-start,flex-end,center,baseline:item第一行文字基线对齐)
align-content :决定多条交叉轴线的对齐方式。(flex-start,flex-end,center,space-between,space-around,stretch)
</code>
align-content:</p>

<p><img src="/myimg/java/flex1.png" width="400" alt="" /></p>

<p><strong>用在Item上的属性</strong></p>

<pre><code>order :定义item的排列顺序。数值越小，排列越靠前，默认为0。
flex-grow :定义item的放大比例。默认为0，即如果存在剩余空间也不放大。有多个的话按比例均分。
flex-shrink :定义item的缩小比例。默认为1，即如果空间不足，该项目将缩小。0则不缩小。
flex-basis :定义了在分配多余空间之前，item占据的主轴空间,默认auto,即本来大小。
flex : flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。
align-self :设置item自身在交叉轴上的对齐方式。可覆盖align-items属性。
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
(auto,flex-start,flex-end,center,baseline,stretch)
</code></pre>

<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，也有些差异:flexDirection的默认值是column而不是row，alignItems的默认值是stretch而不是flex-start。使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求。</p>

<p><code>flexDirection</code>: 决定布局的主轴。子元素是沿着水平轴方向排列，还是沿着竖直轴方向排列。</p>

<p><code>justifyContent</code>: 决定子元素沿着主轴的排列方式。有flex-start、center、flex-end、space-around 和 space-between。</p>

<p><code>alignItems</code>: 决定其子元素沿着交叉轴的排列方式。有flex-start、center、flex-end以及stretch。<strong>注意：要使stretch选项生效的话，子元素在次轴方向上不能固定尺寸。</strong></p>

<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Fexbox布局实例</a></p>
]]></content>
  </entry>
  
</feed>
