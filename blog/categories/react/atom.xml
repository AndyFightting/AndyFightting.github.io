<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: React | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/react/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-11-28T17:16:29+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native 基础知识]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/26/react-native-basic/"/>
    <updated>2016-11-26T11:16:25+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/26/react-native-basic</id>
    <content type="html"><![CDATA[<h4>属性</h4>

<h4>布局</h4>

<h4>事件</h4>

<h4>网络</h4>

<h4>存储</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 问题汇总]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/25/react-native-run-bug/"/>
    <updated>2016-11-25T18:46:09+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/25/react-native-run-bug</id>
    <content type="html"><![CDATA[<p>Android 设备:小米 red note MUI 8.0, iOS 设备:iPhone 6Plus 8.3</p>

<h5>1.运行不起来</h5>

<p>按照<a href="https://facebook.github.io/react-native/docs/getting-started.html#content">官网</a>的步骤一步一步下来运行报：</p>

<pre><code>com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Failed to establish session
</code></pre>

<p><a href="https://github.com/facebook/react-native/issues/6499">这里</a>说小米系列的手机都这样，我们平时用Android Studio调试运行不是会弹出个弹出框问是否安装吗？这是用USB链接的，所以没问题，但是用命令就掉动不起来那弹出框&hellip;
<img src="/myimg/java/react_error_xm0.png" alt="" /></p>

<p>解决办法如下，关键是第4步，关闭小米的优化
<img src="/myimg/java/react_error_xm1.png" alt="" /></p>

<h5>2.运行不起来</h5>

<p>报错：</p>

<pre><code>com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Unable to upload some APKs
</code></pre>

<p>解决：把 /项目/android/build.gradle 文件里的 <code>classpath 'com.android.tools.build:gradle:1.3.1'</code> 改成 <code>classpath 'com.android.tools.build:gradle:1.2.3'</code>就可以了&hellip;.why? yeah,why?</p>

<h5>3.白屏</h5>

<p>运行起来了，等啊等，怎么还是白屏？不是有东西的吗？摇啊摇不是有弹出框的吗？弹出框呢？？</p>

<p>解决：进系统设置，应用管理，找到这个应用，点击应用详情里的权限管理，开启显示悬浮框。刷新一下再摇一摇就有弹出框了。</p>

<h5>4.Could not connect to development server</h5>

<p>摇啊摇弹出框后，点击最后的 <code>Dev Settings</code> ，然后设置 <code>Debug server host &amp; port for device</code> 为<code>本机IP:8081</code>后返回刷新出现如下错误:</p>

<p><img src="/myimg/java/react_error2.png" alt="" /></p>

<p>解决：命令行进入项目文件夹，运行如下命令：</p>

<pre><code>react-native start &gt; /dev/null 2&gt;&amp;1 &amp; curl "http://localhost:8081/index.android.bundle?platform=android" -o "android/app/src/main/assets/index.android.bundle"
</code></pre>

<p>如果提示没有 assets 文件夹，则先手动建一个再运行。之后就能真机运行起来了：</p>

<p><img src="/myimg/java/react_android.png" alt="" /></p>

<h5>iOS模拟器Cmd+R不刷新，Cmd+D也没弹出框</h5>

<p>解决：要开启模拟器的键盘链接。模拟器菜单<code>Hardware</code>-><code>Keyboard</code> 选中 <code>Connect Hardware Keyboard</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React 基础知识]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/24/react-javascript/"/>
    <updated>2016-11-24T14:31:57+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/24/react-javascript</id>
    <content type="html"><![CDATA[<h4>React 的核心思想是：封装组件!React 应用都是构建在组件之上，各个组件维护自己的状态和 UI，当状态变更，自动重新渲染自身组件。组件的第一个字母必须大写,组件只能包含一个顶层标签。</h4>

<h4>Declarative</h4>

<p><a href="https://facebook.github.io/react/">React</a> 可以很好的创建交互式组件，设计不同状态下的组件，并且React可以根据组件的不同参数高效的刷新渲染。这样的组件可以让你的代码更加的可预测并且更方便调试。</p>

<h4>Component-Based</h4>

<p>基于组件，封装一个组件，让它们管理自己的状态，然后用它们去组成更加复杂的UI。由于组件的逻辑是写在JavaScript里的而不是模板里，这样你可以很轻松的让它穿梭于复杂的数据之间，并且在DOM外保持自己的状态。</p>

<h4>Learn Once, Write Anywhere</h4>

<p>我们不假定你现在的技术栈是怎样的，所以你可以不用重写已存在的代码来用React开放新的功能。React也可以在服务器端渲染，也可以用React Native创建强大的移动应用。</p>

<h4>A Simple Component</h4>

<p>React 组件调用 <code>render()</code> 方法来输入参数然后返回要显示的样子。这个例子用一个类似XML语言的我们称之为JSX，通过<code>this.props</code>输入数据传到组件内部可以被<code>render()</code>方法获取。使用React的话，JSX是可选的，不是必须要使用的。试着点击<code>Complied JS</code>去看看通过JSX编译器产生的原生的JavaScript 代码。</p>

<h4>A Stateful Component</h4>

<p>除了通过<code>this.props</code>来传入参数，组件可以通过<code>this.state</code>来维护自己内部状态的数据。当组件的状态数据改变时，渲染器就会重新调用<code>render()</code>方法来刷新。</p>

<h4>An Application</h4>

<p>使用<code>props</code>和<code>state</code>我们可以收集一个小型的代办事项申请。这个例子用<code>state</code>来跟踪当前列表和用户输入的数据。虽然事件处理程序似乎是呈现内联,他们会通过事件代理被收集和使用。</p>

<h4>A Component Using External Plugins</h4>

<p>React 是灵活的，并且提供了一个钩子来和库或框架进行链接。这个例子使用<code>remarkable</code>,一个外部的 Markdown 库，来实时转化文本内容。</p>

<p>哎呀~ 自己翻译果然别扭&hellip;😞  React 是什么呢？React 是Facebook 封装的一组JS代码库：</p>

<p><img src="/myimg/java/react.png" alt="" /></p>

<p>按它规则可封装一个一个模块组件，这个模块组件有自己的状态，自己的逻辑等，它是一个独立的东西，然后把这样的组件一个一个组合起来。我理解的这不就是iOS或者Android自定义View 模块化吗？按照React 的规则可以混合着写JavaScript和HTML,这样的一个组件就是一个独立的模块化的View。添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。</p>

<p>React 还封装了一个自己的虚拟的DOM，通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。因为如果大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个虚拟 DOM，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 <a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">diff</a> 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性。给组件设置一个 <code>ref</code> 属性，然后用 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点对象。</p>

<h4>Hello World</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;

    &lt;script type="text/babel"&gt;
    var MyComponent = React.createClass({
      render: function() {
        return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;
      }
    });

    ReactDOM.render(&lt;MyComponent name="World !" /&gt;,
                    document.getElementById('example') );
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>上面的代码中用React的语法自定义了一个组件叫<code>MyComponent</code>,这个组件返回一个块区间，里面显示 Hello + 这个组件的<code>name</code>属性值。注意script 的type 要声明为<code>text/babel</code>。这样就可以在其他地方使用这个自定义的组件了。可以把 <code>props</code> 看作是组件的配置属性，在组件内部是不变的，只是在调用这个组件的时候传入不同的属性值来定制显示这个组件。当组件状态 <code>state</code> 有更改的时候，React 会自动调用组件的 <code>render()</code> 方法重新渲染整个组件的 UI。<code>this.props</code> 对象的属性与组件的属性一一对应，<code>this.props.children</code> 表示组件的所有子节点。需要注意， <code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 <code>this.props.children</code> 的时候要小心。上面的代码把 HTML 直接嵌入了 JS 代码里面了，这就是 React 提出的一种叫 JSX 的语法。把原来网页设计的代码分离，现在又融合了！</p>

<p><img src="/myimg/java/react_hello.png" alt="" /></p>

<p>Hello World 运行起来了！嗯~ 我已经成功了一半！😆</p>

<h4>组件组合</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;

    &lt;script type="text/babel"&gt;

    var Avatar = React.createClass({
        render: function() {
            return (
                &lt;div&gt;
                    &lt;ProfilePic username={this.props.username} /&gt;
                    &lt;ProfileName username={this.props.username} /&gt;
                &lt;/div&gt;
            );
        }
       });

    var ProfilePic = React.createClass({
        render: function() {
            return (
                &lt;img src={'https://gss0.bdstatic.com/70cFsj3f_gcX8t7mm9GUKT-xh_/avatar/100/r6s1g6.gif'} /&gt;
            );
        }
    });

    var ProfileName = React.createClass({
        render: function() {
            return (
              &lt;div&gt;
                &lt;a href={'http://guimingsu.com'}&gt;
                    {this.props.username}
                &lt;/a&gt;
              &lt;/div&gt;
            );
        }
    });

    ReactDOM.render(
        &lt;Avatar username="hello world " /&gt;,
        document.getElementById('example')
      );

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这里显示了一个Avatar 组件，这个Avatar 组件是由两个更小的组件ProfilePic和ProfileName组合而成的。父组件和子组件间可以通过<code>props</code>一层一层的传值。Remember: React is all about one-way data flow down the component hierarchy.</p>

<p><img src="/myimg/java/react_hello0.png" alt="" /></p>

<h4>状态变化</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;
    &lt;script type="text/babel"&gt;

     var LikeButton = React.createClass({
      getInitialState: function() {
        return {liked: false};
      },

      handleClick: function(event) {
        this.setState({liked: !this.state.liked});
      },

      render: function() {
        var text = this.state.liked ? 'like' : 'haven\'t liked';
        return (
          &lt;p onClick={this.handleClick}&gt;
            You {text} this. Click to toggle.
          &lt;/p&gt;
        );
      }
    });

    ReactDOM.render(
      &lt;LikeButton /&gt;,
      document.getElementById('example')
    );

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>上面代码是一个 <code>LikeButton</code> 组件，它的 <code>getInitialState</code> 方法用于定义初始状态，也就是一个对象，这个对象可以通过 <code>this.state</code> 属性读取。当用户点击组件，导致状态变化，<code>this.setState</code> 方法就修改状态值，每次修改以后，自动调用 <code>this.render</code> 方法，再次渲染组件。
由于 <code>this.props</code> 和 <code>this.state</code> 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，<code>this.props</code> 表示那些一旦定义，就不再改变的特性，而 <code>this.state</code> 是会随着用户互动而产生变化的特性。即把要跟随某个参数实时变化的代码写在 <code>render: function() {};</code>里，然后在用户调用的方法里调用<code>this.setState({ });</code>方法来改变参数就可以了，因为他们触发<code>render</code>方法。这样就可以根据不同参数值自动显示不同内容。</p>

<h4>生命周期</h4>

<p>组件的生命周期分成三个状态：</p>

<ol>
<li>Mounting：已插入真实 DOM</li>
<li>Updating：正在被重新渲染</li>
<li>Unmounting：已移出真实 DOM</li>
</ol>


<p>React 为每个状态都提供了两种处理函数，<code>will</code> 函数在进入状态之前调用，<code>did</code> 函数在进入状态之后调用，三种状态共计五种处理函数。</p>

<ol>
<li>componentWillMount()</li>
<li>componentDidMount()</li>
<li>componentWillUpdate(object nextProps, object nextState)</li>
<li>componentDidUpdate(object prevProps, object prevState)</li>
<li>componentWillUnmount()</li>
</ol>


<p>此外，React 还提供两种特殊状态的处理函数:</p>

<ol>
<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</li>
<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用</li>
</ol>


<p><img src="/myimg/java/react_life.png" alt="" /></p>

<p>把这个<a href="https://facebook.github.io/react/docs/thinking-in-react.html">官方例子</a>看完就能收获不少了。主要在于思考，拿到设计图如何拆分模块，如何组建，如何选取放置状态参数，如何看懂别人写好的代码等。<a href="/mysrc/java/reactPriceDemo.zip">下载</a></p>

<h5>链接</h5>

<ol>
<li><a href="http://www.cnblogs.com/sakurayeah/category/868210.html">React入门</a></li>
<li><a href="https://babeljs.io/docs/learn-es2015/">ECMAScript 2015</a></li>
<li><a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a></li>
<li><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5和ES6的写法对照表</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Atom]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/24/atom-edit/"/>
    <updated>2016-11-24T14:31:17+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/24/atom-edit</id>
    <content type="html"><![CDATA[<p><a href="https://atom.io/">Atom</a>是由GitHub开发的一款免费开源的编辑器，通过给它安装不同的插件包，就可以变成一款智能的IDE了。这里主要记录一下为了开发<a href="https://facebook.github.io/react-native/">React Native</a>所安装的插件包及基本使用。</p>

<p><a href="https://nuclide.io/">Nuclide</a>是官方推荐的开发React Native的基于Atom的工具。Nuclide 安装好后进入设置，选中<code>Install Recommented Packages on Startup</code>选项，下次启动的时候就会安装Nuclide所建议安装的插件了。</p>

<h4>插件</h4>

<p><strong>atom-react-native-autocomplete :</strong>React Native自动提示。</p>

<p><strong>atom-beautify :</strong> 文件排版格式化。ctrl-alt-b，可以进它的设置里选中 Beauty on Save 自动格式化。</p>

<p><strong>atom-html-preview :</strong> html预览。 ctrl-shift-h
<img src="/myimg/java/atom-html-preview.png" width="700" alt="" /></p>

<p><strong>autocomplete-paths :</strong> 文件路径提示</p>

<p><img src="/myimg/java/autocomplete-paths.png" width="500" alt="" /></p>

<p><strong>color-picker :</strong>颜色选取器，点击色块即可弹出，或者右键选择 Color Picker.</p>

<p><img src="/myimg/java/color-picker.png" width="500" alt="" /></p>

<p><strong>docblockr :</strong> 快捷文档注释</p>

<p><strong>emmet :</strong>web开发神器</p>

<p><strong>file-icons :</strong>给文件加icon</p>

<p><img src="/myimg/java/file-icons.png" width="200" alt="" /></p>

<p><strong>highlight-selected :</strong>选中相同的字符串高亮
<img src="/myimg/java/highlight-selected.png" width="500" alt="" /></p>

<p><strong>js-hyperclick :</strong> js对象 cmd-点击 跳转</p>

<p><strong>merge-conflicts :</strong>解决版本冲突</p>

<p><strong>minimap :</strong>右边位置小地图
<img src="/myimg/java/minimap.png" width="700" alt="" /></p>

<p><strong>pigments :</strong> 显示颜色。 快捷面板里搜 Pigments: Show Palette 可以打开调色板🎨。</p>

<p><img src="/myimg/java/pigment.png" width="400" alt="" /></p>

<p><strong>pretty-json :</strong> Json 格式化。Packages->PrettyJson->Prettify</p>

<p><strong>react-snippets :</strong> React代码块快捷输入
<img src="/myimg/java/react-snippets.png" width="700" alt="" /></p>

<p><strong>sort-lines :</strong>把列按字母排序。功能键 f5(电脑，设置，键盘里要开启功能选项) 或者 Edit->Lines->Sort</p>

<p><strong>tool-bar :</strong>上面显示工具栏，ctrl-alt-t 开/关
<img src="/myimg/java/tool-bar.png" width="500" alt="" /></p>

<p>安装后的插件包不在Atom应用文件夹里，在 <code>/Users/用户名/.atom/packages/</code> 文件夹里。且 <code>.atom</code> 文件夹默认是隐藏的。在命令窗口输入显示文件夹命令。
<code>
//显示隐藏文件
defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder
//隐藏文件
defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder
</code>
<img src="/myimg/java/packages.png" width="300" alt="" /></p>

<h4>包的默认值修改</h4>

<p>可以直接点击<code>View Code</code>打开包的代码修改。也可以像上面先显示文件夹，找到对应的包，然后修改里面的默认配置。在Settings -> Open Config Folder 也可以打开所有插件包的配置。
<img src="/myimg/java/package_change.png" width="700" alt="" /></p>

<h4>快捷键</h4>

<p>ctrl-space : 补全提示 (Mac要把设置->键盘->快捷键->Spotlight 里对应的快捷键取消掉! 不然电脑的优先级更高)</p>

<p>ctrl-alt-b : atom-beautify插件 代码格式化，为什么JSX格式化后有点乱&hellip;</p>

<p>cmd-shift-p : 打开快捷面板</p>

<p>cmd-f : 文件里搜索</p>

<p>cmd-shift-f : 项目里搜索</p>

<p>cmd-alt-[ : 折叠代码</p>

<p>cmd-alt-] : 展开代码</p>

<p>cmd-alt-shift-{ : 折叠所有代码</p>

<p>cmd-alt-shift-} : 展开所有代码</p>

<p>ctrl-[ : 左移动</p>

<p>ctrl-] : 右移动</p>

<p>ctrl-g : 跳转到某行</p>

<p>cmd-\ : 左边目录显示或隐藏</p>

<p>cmd-shift-o : 打开文件夹</p>

<p>cmd-b : 在打开的文件间切换</p>

<p>cmd-delete : 删除光标左边的</p>

<p>ctrl-shift-l : 删除一整行</p>

<p>ctrl-shift-&ldquo;+&rdquo; : 增大字体</p>

<p>ctrl-shift-&ldquo;-&rdquo; : 缩小字体</p>

<p><a href="https://github.com/kompasim/atom-plugins">92款插件推荐</a></p>
]]></content>
  </entry>
  
</feed>
