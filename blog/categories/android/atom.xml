<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-12-05T09:30:16+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 一行代码选取图片]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/11/android-select-photo/"/>
    <updated>2016-11-11T19:31:33+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/11/android-select-photo</id>
    <content type="html"><![CDATA[<p>一行代码模仿iOS的选取图片效果。思路主要是把相机和相册的回调放在一个透明的Activity里，然后在这个透明的Activity中弹出自定义的ActionSheet选择框，选取调相机还是相册。相机比较简单，直接调系统的。相册就不用系统的了，不同手机差别太大，效果也不好。自己遍历本地图片文件然后显示。这样即时在不同手机上也能展示相同的效果了。封装后使用就简单了，一行代码调用就可以，不会和业务Activity耦合了！</p>

<h4>使用:</h4>

<p>1.选取一张正方形图片</p>

<pre><code>   SelectPhotoSheet.showCropImageSheet(this, new AlbumResultListener() {
            @Override
            public void complete(View tapedView, List&lt;String&gt; pathList) {
                cache.displayBmp(headImageView, pathList.get(0), new Point(100, 100));
            }
        });
</code></pre>

<p>2.选取限制数量的全尺寸图片</p>

<pre><code>SelectPhotoSheet.showFullImageSheet(this, 8, new AlbumResultListener() {
            @Override
            public void complete(View tapedView, List&lt;String&gt; pathList) {
                localPathList.clear();
                localPathList.addAll(pathList);
                adapter.notifyDataSetChanged();
            }
        });
</code></pre>

<p><img src="/myimg/android/one_select.png" alt="" /></p>

<h4>实现</h4>

<p>1.自定义ActionSheet，弄一个Sheet的工具类 BaseSheetActivity。</p>

<pre><code>//用作弹出 action sheet 效果的 base activity
public class BaseSheetActivity extends Activity {
    protected int activityCloseEnterAnimation;
    protected int activityCloseExitAnimation;

public static ItemTapListener itemTapListener;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);

    TypedArray activityStyle = getTheme().obtainStyledAttributes(new int[] {android.R.attr.windowAnimationStyle});
    int windowAnimationStyleResId = activityStyle.getResourceId(0, 0);
    activityStyle.recycle();

    activityStyle = getTheme().obtainStyledAttributes(windowAnimationStyleResId, new int[] {android.R.attr.activityCloseEnterAnimation, android.R.attr.activityCloseExitAnimation});
    activityCloseEnterAnimation = activityStyle.getResourceId(0, 0);
    activityCloseExitAnimation = activityStyle.getResourceId(1, 0);
    activityStyle.recycle();
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    dismiss();
    if (itemTapListener != null){
        itemTapListener.itemTap(new View(this),"");
    }
    return super.onTouchEvent(event);
}

@Override
public void finish() {
    dismiss();
}

public void dismiss(){
    super.finish();
    overridePendingTransition(activityCloseEnterAnimation, activityCloseExitAnimation);
}

public static void show(Context context, Class showedActivityClass, ItemTapListener itemTapListener){
    BaseSheetActivity.itemTapListener = itemTapListener;
    Intent intent = new Intent(context,showedActivityClass);
    context.startActivity(intent);
}
}
</code></pre>

<p>  要使用ActionSheet的效果话就是继承它，然后theme选择ActionSheetTheme。然后把界面的布局从bottom开始布局。</p>

<pre><code>  public class PhotoSheet extends BaseSheetActivity {

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.action_photo_sheet); //action_photo_sheet的布局从bottom开始

}

public void itemTap(View view){
    dismiss();
    if (itemTapListener != null){
        itemTapListener.itemTap(view,"");
    }
}

@Override
public void onBackPressed() {
    dismiss();
    if (itemTapListener != null){
        itemTapListener.itemTap(new View(this),"");
    }
}
}

   //设置为自定义的样式
 &lt;activity
        android:name=".photo_lib.photo.PhotoSheet"
        android:theme="@style/ActionSheetTheme" /&gt;
</code></pre>

<p>2.读图片文件路径，不单单是相册里的图片</p>

<pre><code>public void getLocalImages() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                Uri mImageUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
                ContentResolver mContentResolver = AlbumDirActivity.this.getContentResolver();

            Cursor mCursor = mContentResolver.query(
                    mImageUri,
                    null,
                    MediaStore.Images.Media.MIME_TYPE + "=? or " + MediaStore.Images.Media.MIME_TYPE + "=? or " + MediaStore.Images.Media.MIME_TYPE + "=?",
                    new String[]{"image/jpeg", "image/png", "image/jpg"},
                    MediaStore.Images.Media.DATE_MODIFIED);

            while (mCursor.moveToNext()) {
                String path = mCursor.getString(mCursor.getColumnIndex(MediaStore.Images.Media.DATA));
                String parentName = new File(path).getParentFile().getName();

                if (!dirMap.containsKey(parentName)) {
                    List&lt;String&gt; chileList = new ArrayList&lt;&gt;();
                    chileList.add(path);
                    dirMap.put(parentName, chileList);
                } else {
                    dirMap.get(parentName).add(path);
                }
            }
            mCursor.close();
            mHandler.sendEmptyMessage(SCAN_OK);
        }
    }).start();
}
</code></pre>

<p>3.用LruCache缓存显示压缩后的图片</p>

<pre><code>public class LocalImageCache {

private static LocalImageCache mInstance;

private Handler mHander = new Handler();
private LruCache&lt;String, Bitmap&gt; mMemoryCache;
private CacheImageCallBack mCallBack;
private ExecutorService mImageThreadPool = Executors.newFixedThreadPool(5);

private LocalImageCache() {
    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
    final int cacheSize = maxMemory / 5;

    mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {
        @Override
        protected int sizeOf(String key, Bitmap bitmap) {
            return bitmap.getByteCount()/1024;
        }
    };

    mCallBack = new CacheImageCallBack() {
        @Override
        public void onImageLoader(ImageView imageView, Bitmap bitmap) {
            if (bitmap != null &amp;&amp; imageView != null) {
                imageView.setImageBitmap(bitmap);
            }
        }
    };
}

public static LocalImageCache getInstance() {
    synchronized (LocalImageCache.class) {
        if (mInstance == null) {
            mInstance = new LocalImageCache();
        }
        return mInstance;
    }
}

public static void clearCache() {
    LocalImageCache cache = getInstance();
    cache.mMemoryCache.evictAll();
}

public void displayBmp(final ImageView imageView, final String path, final Point mPoint) {
    if (TextUtils.isEmpty(path) || imageView == null) {
        return;
    }

    Bitmap bitmap = getBitmapFromMemCache(path);
    if (bitmap == null) {
        imageView.setImageBitmap(null);

        mImageThreadPool.execute(new Runnable() {
            Bitmap mBitmap;

            @Override
            public void run() {
                mBitmap = decodeThumbBitmapForFile(path, mPoint == null ? 0 : mPoint.x, mPoint == null ? 0 : mPoint.y);
                mHander.post(new Runnable() {
                    @Override
                    public void run() {
                        mCallBack.onImageLoader(imageView, mBitmap);
                    }
                });
                addBitmapToMemoryCache(path, mBitmap);
            }
        });
    } else {
        imageView.setImageBitmap(bitmap);
    }
}

private void addBitmapToMemoryCache(String key, Bitmap bitmap) {
    if (getBitmapFromMemCache(key) == null &amp;&amp; bitmap != null) {
        mMemoryCache.put(key, bitmap);
    }
}

private Bitmap getBitmapFromMemCache(String key) {
    return mMemoryCache.get(key);
}

private Bitmap decodeThumbBitmapForFile(String path, int viewWidth, int viewHeight) {
    BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeFile(path, options);
    options.inSampleSize = computeScale(options, viewWidth, viewHeight);
    options.inJustDecodeBounds = false;

    return BitmapFactory.decodeFile(path, options);
}

private int computeScale(BitmapFactory.Options options, int viewWidth, int viewHeight) {
    int inSampleSize = 1;
    if (viewWidth == 0 || viewHeight == 0) {
        return inSampleSize;
    }
    int bitmapWidth = options.outWidth;
    int bitmapHeight = options.outHeight;

    if (bitmapWidth &gt; viewWidth || bitmapHeight &gt; viewHeight) {
        int widthScale = Math.round((float) bitmapWidth / (float) viewWidth);
        int heightScale = Math.round((float) bitmapHeight / (float) viewHeight);

        inSampleSize = (widthScale+heightScale)/2;
    }
    return inSampleSize;
}


private interface CacheImageCallBack {
    void onImageLoader(ImageView imageView, Bitmap bitmap);
}
}
</code></pre>

<p>4.用DrawerLayout封装了一个手势返回的基础类</p>

<pre><code>public class BaseSwipeActivity extends AppCompatActivity {

private LinearLayout containerLayout;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    initSwipeView();
}

@Override
protected void onDestroy() {
    super.onDestroy();
}

private void initSwipeView() {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    setContentView(R.layout.activity_base_swipe);

    containerLayout = (LinearLayout) findViewById(R.id.container_layout);

    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.base_drawer_layout);
    drawer.openDrawer(GravityCompat.END);
    ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawer, R.string.navigation_drawer_open, R.string.navigation_drawer_close) {
        @Override
        public void onDrawerClosed(View drawerView) {
            super.onDrawerClosed(drawerView);
            finish();
        }
    };
    drawer.addDrawerListener(toggle);
}

//子类要手势返回就用setMainView!!!!
public void setMainView(int viewId) {
    LayoutInflater inflater = LayoutInflater.from(this);
    View tmpView = inflater.inflate(viewId, null);

    if (tmpView instanceof LinearLayout) {
        LinearLayout.LayoutParams linearLayoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(linearLayoutParams);
    } else if (tmpView instanceof RelativeLayout) {
        RelativeLayout.LayoutParams relativeLayoutParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(relativeLayoutParams);
    }
    containerLayout.removeAllViews();
    containerLayout.addView(tmpView);
}

public void backViewTap(View v) {

}

public void backImageTap(View v) {
    finish();
}
}
</code></pre>

<p>其他Activity需要手势返回的话就继承它，然后使用setMainView()替代setContentView()设置界面布局，其他什么都不用管啦！</p>

<h4>注意</h4>

<p>要在使用的Activity的onDestroy()方法中调用 FileUtil.deleteAllFile(); 清除选取的临时缓存图片！！！</p>

<p><a href="https://github.com/AndyFightting/SelectPhoto_Android">下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OkHttp and Retrofit]]></title>
    <link href="http://andyfightting.github.io/blog/2016/09/08/okhttp-retrofit/"/>
    <updated>2016-09-08T14:57:19+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/09/08/okhttp-retrofit</id>
    <content type="html"><![CDATA[<p><a href="http://square.github.io/okhttp/">OkHttp</a>和<a href="http://square.github.io/retrofit/">Retrofit</a>都是<a href="http://square.github.io/">Square</a>公司开源出来的网络请求框架。Retrofit是对OkHttp的封装，使其可以用注解的方式调用。</p>

<h4>OkHttp</h4>

<pre><code>//-----okhttp 网络请求 工具类-----

//异步请求结果放在主线程回调。
private static final Handler mainHandler = new Handler(Looper.getMainLooper()); 

private static final OkHttpClient client = new OkHttpClient.Builder()
        .connectTimeout(10, TimeUnit.SECONDS)
        .writeTimeout(10, TimeUnit.SECONDS)
        .readTimeout(10, TimeUnit.SECONDS)
        .build();

public static void getRequest(String url, final OkHttpListener listener) {
    Request request = new Request.Builder()
            .header("token", getUserToken())
            .header("client", "Android")
            .header("versionCode", getVersionCode())
            .header("versionName", getVersionName())
            .url(url)
            .build();
    beginRequest(request, listener);
}

//这样就不会有中文乱码问题
public static void postRequest(String url, final Map&lt;String, String&gt; params, final OkHttpListener listener) {
    StringBuilder stringBuilder = new StringBuilder("");
    if (params != null) {
        Set&lt;String&gt; keys = params.keySet();
        for (String key : keys) {
            String value = params.get(key);
            stringBuilder.append(key + "=" + value + "&amp;");
        }
    }

    MediaType mediaType = MediaType.parse("application/x-www-form-urlencoded;charset=utf-8");
    RequestBody body = RequestBody.create(mediaType, stringBuilder.toString());

    Request request = new Request.Builder()
            .header("token", getUserToken())
            .header("client", "Android")
            .header("versionCode", getVersionCode())
            .header("versionName", getVersionName())
            .url(url)
            .post(body)
            .build();

    beginRequest(request, listener);
}

//可添加图片文件
public static void postMutibleRequest(String url, final Map&lt;String, Object&gt; params, final OkHttpListener listener) {
    MultipartBody.Builder multipleBuilder = new MultipartBody.Builder();
    multipleBuilder.setType(MultipartBody.FORM);

    if (params != null) {
        Set&lt;String&gt; keys = params.keySet();
        for (String key : keys) {
            Object obj = params.get(key);

            if (obj instanceof File) {
                File tmpFile = (File) obj;
                multipleBuilder.addFormDataPart(key, tmpFile.getName(), MultipartBody.create(MediaType.parse("image/jpg"), tmpFile));
            } else {
                multipleBuilder.addPart(Headers.of("Content-Disposition", "form-data; name=\"" + key + "\""), RequestBody.create(null, (String) obj));
            }
        }
    }

    RequestBody multipleBody = multipleBuilder.build();
    Request request = new Request.Builder()
            .header("token", getUserToken())
            .header("client", "Android")
            .header("versionCode", getVersionCode())
            .header("versionName", getVersionName())
            .url(url)
            .post(multipleBody)
            .build();

    beginRequest(request, listener);
}

//保存网络图片到相册,返回本地存储路径
public static void downloadImageToSysPhoto(String imageUrl, final OkHttpListener listener) {
    Request request = new Request.Builder().url(imageUrl).build();
    Call call = client.newCall(request);
    call.enqueue(new Callback() {
        @Override
        public void onResponse(Call call, Response response) throws IOException {
            try {
                //系统相册路径
                final String localPath = "/storage/emulated/0/DCIM/Camera/" + CommonUtil.getUniqueString(10) + ".jpg";

                InputStream is = response.body().byteStream();
                FileOutputStream fos = new FileOutputStream(localPath);
                byte[] buffer = new byte[1024];

                int len;
                while ((len = is.read(buffer)) != -1) {
                    fos.write(buffer, 0, len);
                }
                is.close();
                fos.close();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.success(localPath);
                        }
                    }
                });
            } catch (Exception e) {
                e.printStackTrace();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.fail(0, "");
                        }
                    }
                });
            }
        }

        @Override
        public void onFailure(Call call, IOException e) {
            mainHandler.post(new Runnable() {
                @Override
                public void run() {
                    if (listener != null) {
                        listener.fail(0, "");
                    }
                }
            });
        }
    });
}

private static void beginRequest(Request request, final OkHttpListener listener) {
    Call call = client.newCall(request);

    call.enqueue(new Callback() {//enqueue是异步请求
        @Override
        public void onResponse(Call call, Response response) throws IOException {
            final String responseString = response.body().string();
            final int code = response.code();

            if (response.isSuccessful()) {
                CommonUtil.logJson(responseString);

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.success(responseString);
                        }
                    }
                });
            } else {
                //请求失败：    400  ---------   {"code":100004,"msg":"手机号已注册"}
                CommonUtil.logString("请求失败：" + code + "---------" + responseString);
                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.fail(code, responseString);
                        }
                    }
                });
            }
        }

        @Override
        public void onFailure(Call call, IOException e) {
            e.printStackTrace();
            CommonUtil.logString("请求错误");
            mainHandler.post(new Runnable() {
                @Override
                public void run() {
                    if (listener != null) {
                        listener.fail(0, "请求失败");
                    }
                }
            });
        }
    });
}

public static String getFailedMsg(String response) {
    try {
        JSONObject jsonObject = new JSONObject(response);
        return jsonObject.getString("msg");
    } catch (Exception e) {
        e.printStackTrace();
    }
    return "请求失败";
}

public static String getUserToken() {
    UserModel userModel = UserModel.getUser();
    if (userModel != null) {
        return userModel.getToken();
    }
    return "";
}

public static String getVersionCode() {
    try {
        PackageInfo pi = application.getPackageManager().getPackageInfo(application.getPackageName(), 0);
        return pi.versionCode + "";
    } catch (Exception e) {
        e.printStackTrace();
    }
    return "";
}

public static String getVersionName() {
    try {
        PackageInfo pi = application.getPackageManager().getPackageInfo(application.getPackageName(), 0);
        return pi.versionName;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return "";
}

//下载apk安装包，HUD是自定义的等待进度条
private static int apkProgress;
public static void downloadAPK(final Context context, String apkUrl) {
    HUD.show(context, "下载中...");
    HUD.setCancelable(false);

    Request request = new Request.Builder().url(apkUrl).build();
    Call call = client.newCall(request);
    call.enqueue(new Callback() {
        @Override
        public void onResponse(Call call, Response response) throws IOException {
            try {
                FileUtil.createDir();//创建  ~/paiqi/ 文件夹
                final String apkLocalPath = FileUtil.DIR_PATH + "paiqi.apk";

                InputStream is = response.body().byteStream();
                FileOutputStream fos = new FileOutputStream(apkLocalPath);
                int readNum;
                byte[] buffer = new byte[1024];

                int progressCount = 0;
                long totalLength = response.body().contentLength();

                while ((readNum = is.read(buffer)) != -1) {
                    progressCount += readNum;
                    apkProgress = (int) (((float) progressCount / totalLength) * 100);

                    mainHandler.post(new Runnable() {
                        @Override
                        public void run() {
                            HUD.setMessage("下载中 " + apkProgress + "%");
                        }
                    });

                    fos.write(buffer, 0, readNum);
                }
                is.close();
                fos.close();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        HUD.dismiss();
                        installAPK(context, apkLocalPath);
                    }
                });
            } catch (Exception e) {
                e.printStackTrace();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        HUD.dismiss();
                        CommonUtil.showToast("下载失败");
                    }
                });
            }
        }

        @Override
        public void onFailure(Call call, IOException e) {
            mainHandler.post(new Runnable() {
                @Override
                public void run() {
                    HUD.dismiss();
                    CommonUtil.showToast("下载失败");
                }
            });
        }
    });
}

//安装apk
private static void installAPK(Context context, String apkPath) {
    File apkFile = new File(apkPath);
    if (!apkFile.exists()) {
        CommonUtil.showToast("安装失败");
        return;
    }
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setDataAndType(Uri.parse("file://" + apkFile.toString()), "application/vnd.android.package-archive");
    context.startActivity(intent);
} 

//请求回调接口定义
public interface OkHttpListener {
   void success(String response);
   void fail(int code,String response);
}
</code></pre>

<p>要注意的是enqueue方法是异步请求，所以要把结果回调放在主线程中进行。</p>

<pre><code> mainHandler.post(new Runnable() {
                        @Override
                        public void run() {
                            if (listener != null) {
                                listener.success(responseString);
                            }
                        }
                    });
</code></pre>

<p>之前看过一个同事的网络库封装，把网络回调接口放在BaseActivity里，然后在子Activity里重写回调方法！这样导致的结果就是，Fragment里的请求都要通过Activity来重写方法，然后再转发给Fragment&hellip;简直想骂街啊有木有！下面这样调用是不是很简单呢~!</p>

<pre><code>//get异步请求,回调都已放在主线程中
 OkHttpHelper.getRequest(ulr, new OkHttpListener() {
        @Override
        public void success(String response) {

        }

        @Override
        public void fail() {

        }
    });

   //post异步请求，回调都已放在主线程中，也可以用于提交File
    Map&lt;String, Object&gt; paramter = new HashMap&lt;&gt;();
    paramter.put("name", "阿贵");
    paramter.put("file", new File("filePath"));//提交图片文件

    OkHttpHelper.postRequest(url, paramter, new OkHttpListener() {
        @Override
        public void success(String response) {

        }

        @Override
        public void fail() {

        }
    });
</code></pre>

<p>还有很多人喜欢把网络请求和结果解析写在一起，比如通过请求结果直接得到对应的Bean。这样导致的结果就是网球请求结果类型不统一，返回各种Bean。个人不太喜欢这样，可以对结果解析进行简单封装一下，这样网络返回的结果也会统一，数据解析也就一行代码。</p>

<pre><code>//使用: getBean(json, User.class);
public static &lt;T&gt; T getBean(String json, Class&lt;T&gt; clazz) {
    T bean = null;
    try {
        Gson gson = new Gson();
        bean = gson.fromJson(json, clazz);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return bean;
}

   //使用：getBeanList(json, User[].class);
    public static &lt;T&gt; List&lt;T&gt; getBeanList(String json, Class&lt;T[]&gt; type) {
        try{
            T[] list = new Gson().fromJson(json, type);
            return Arrays.asList(list);
        }catch (Exception e){
            e.printStackTrace();
            return null;
        }
    }
</code></pre>

<h4>Retrofit</h4>

<p><a href="http://square.github.io/retrofit/">Retrofit官网</a>上的例子中返回结果是Bean，但又没说添加了GsonConverterFactory，所以会报 Could not locate ResponseBody converter for XXBean 错误！所以要引入GsonConverterFactory转化库<code>compile 'com.squareup.retrofit2:converter-gson:2.0.2'</code>, 然后在Retrofit初始化的时候添加该库！官网后面说了 By default, Retrofit can only deserialize HTTP bodies into OkHttp&rsquo;s ResponseBody type and it can only accept its RequestBody type for @Body. 默认只会返回ResponseBody！并且只有ResponseBody才可以使用@Body注解！我个人还是不喜欢直接在这里得到Bean, 我还是喜欢先通过得到response.body().string()，然后再转化成Bean，各司其职。注意是<code>response.body().string()</code>，不是<code>response.body().toString()</code>!!</p>

<pre><code>    Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://api.github.com/")
                .addConverterFactory(GsonConverterFactory.create()) //添加Bean转化库
                .build();

    ServiceInterface service = retrofit.create(ServiceInterface.class);

    Call&lt;TestBean&gt; requestCall = service.getUserInfo();

    requestCall.enqueue(new Callback&lt;TestBean&gt;() {
        @Override
        public void onResponse(Call&lt;TestBean&gt; call, Response&lt;TestBean&gt; response) {

                TestBean b = response.body();
        }

        @Override
        public void onFailure(Call&lt;TestBean&gt; call, Throwable t) {

        }
    });

 public interface ServiceInterface {
    @GET("users/andyfightting")
    Call&lt;TestBean&gt; getUserInfo();

    //这里继续添加其他接口

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中的AsyncTask]]></title>
    <link href="http://andyfightting.github.io/blog/2016/09/07/asynctask/"/>
    <updated>2016-09-07T10:15:12+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/09/07/asynctask</id>
    <content type="html"><![CDATA[<p>Android和iOS一样，对UI的操作只能放在主线程中进行，即UI线程。如果在UI线程中执行比较耗时的方法，就会造成界面卡顿假死无反应，所以应该把耗时操作放在<code>非UI线程</code>中处理，处理完成后再在<code>UI线程</code>中更新界面。</p>

<p>在没有AsyncTask类的时候，是通过在子线程处理，然后sendMessage(Message msg)给主线程中创建的Handler,然后在主线程中实现handleMessage(Message msg)处理相应信息。而这些工作AsyncTask帮我们做了，AsyncTask就是对Thread和Handler的封装。</p>

<h4>AsyncTask使用</h4>

<p>AsyncTask是一个抽象类，所以必须创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个参数类型,这三个类型会影响重写方法对应的参数类型。</p>

<ol>
<li>Params: 在execute()启动任务时需要传入的参数</li>
<li>Progress: 后台任务执行过程中，需要实时反馈出来的信息，比如执行进度什么的</li>
<li>Result: 后台任务执行完毕后，如果需要对结果进行返回，则返回该类型</li>
</ol>


<pre><code>    //on开通的方法都是在UI线程中执行的
    class MyAsyncTask extends AsyncTask&lt;Void,Integer,Boolean&gt;{
        @Override
        protected void onPreExecute() {//在执行实际的后台的doInBackground方法前
            super.onPreExecute();
        }

        @Override
        protected Boolean doInBackground(Void... params) {//在onPreExecute 方法执行后马上执行，该方法运行在后台线程中
            for (int i = 0; i &lt;= 100; i++) {
                publishProgress(i);//调用onProgressUpdate
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return true;//可以判断是否顺利执行完了啊
        }

        @Override
        protected void onProgressUpdate(Integer... values) {//这个函数在doInBackground调用publishProgress时被调用后
            super.onProgressUpdate(values);
            //比如实时更新进度条
        }

        @Override
        protected void onPostExecute(Boolean aBoolean) {
            super.onPostExecute(aBoolean);
            //后台顺利执行完后要干啥呢
        }

        @Override
        protected void onCancelled() {
            super.onCancelled();
        }
    }
</code></pre>

<ol>
<li>Task的实例必须在UI 线程中创建</li>
<li>execute方法必须在UI 线程中调用</li>
<li>不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params&hellip;)等方法</li>
<li>该task只能被执行一次，否则多次调用时将会抛出异常</li>
</ol>


<h4>AsyncTask源码</h4>

<p>AsyncTask有个handler内部类，用它来处理在主线程中实时更新和任务完成后的回调</p>

<pre><code>    private static InternalHandler sHandler;

    private static Handler getHandler() {
        synchronized (AsyncTask.class) {
            if (sHandler == null) {
                sHandler = new InternalHandler();
            }
            return sHandler;
        }
    }

    private static class InternalHandler extends Handler {
        public InternalHandler() {
            super(Looper.getMainLooper());
        }

        @SuppressWarnings({"unchecked", "RawUseOfParameterizedType"})
        @Override
        public void handleMessage(Message msg) {
            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;
            switch (msg.what) {
                case MESSAGE_POST_RESULT:
                    // There is only one result
                    result.mTask.finish(result.mData[0]);
                    break;
                case MESSAGE_POST_PROGRESS:
                    result.mTask.onProgressUpdate(result.mData);
                    break;
            }
        }
    }
</code></pre>

<p>当我们调用publishProgress方法时，就是得到handler单列然后发消息</p>

<pre><code>   protected final void publishProgress(Progress... values) {
        if (!isCancelled()) {
            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,
                    new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();
        }
    }

   private static class AsyncTaskResult&lt;Data&gt; {
        final AsyncTask mTask;
        final Data[] mData;

     AsyncTaskResult(AsyncTask task, Data... data) {
            mTask = task;
            mData = data;
        }
    }
</code></pre>

<p>当执行execute()方法时，会在后台任务doInBackground(mParams)开始执行前调用onPreExecute方法。从下面可以看出，当task已经在运行或者已经结束的时候不可以再调用execute()方法，否则会报错。</p>

<pre><code> public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {
        return executeOnExecutor(sDefaultExecutor, params);
    }

  public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
            Params... params) {
        if (mStatus != Status.PENDING) {
            switch (mStatus) {
                case RUNNING:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task is already running.");
                case FINISHED:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task has already been executed "
                            + "(a task can be executed only once)");
            }
        }

        mStatus = Status.RUNNING;

        onPreExecute(); //后台任务开始前执行

        mWorker.mParams = params;
        exec.execute(mFuture);

        return this;
    }

     mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
            public Result call() throws Exception {
                mTaskInvoked.set(true);

                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                //noinspection unchecked
                Result result = doInBackground(mParams);   //这里开始执行后台任务！！！
                Binder.flushPendingCommands();
                return postResult(result);
            }
        };

        mFuture = new FutureTask&lt;Result&gt;(mWorker) {
            @Override
            protected void done() {
                try {
                    postResultIfNotInvoked(get());    //后台任务执行完毕！！！
                } catch (InterruptedException e) {
                    android.util.Log.w(LOG_TAG, e);
                } catch (ExecutionException e) {
                    throw new RuntimeException("An error occurred while executing doInBackground()",
                            e.getCause());
                } catch (CancellationException e) {
                    postResultIfNotInvoked(null);
                }
            }
        };
</code></pre>

<p>后台任务执行完毕时，也是通过handler发消息，然后判断是不是取消状态来调用相应的方法</p>

<pre><code> mFuture = new FutureTask&lt;Result&gt;(mWorker) {
            @Override
            protected void done() {
                try {
                    postResultIfNotInvoked(get());   //后台任务执行完毕！！！
                } catch (InterruptedException e) {
                    android.util.Log.w(LOG_TAG, e);
                } catch (ExecutionException e) {
                    throw new RuntimeException("An error occurred while executing doInBackground()",
                            e.getCause());
                } catch (CancellationException e) {
                    postResultIfNotInvoked(null);
                }
            }
        };

   private void postResultIfNotInvoked(Result result) {
        final boolean wasTaskInvoked = mTaskInvoked.get();
        if (!wasTaskInvoked) {
            postResult(result);
        }
    }

   private Result postResult(Result result) {
        @SuppressWarnings("unchecked")
        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,
                new AsyncTaskResult&lt;Result&gt;(this, result));
        message.sendToTarget();
        return result;
    }

 private void finish(Result result) {
        if (isCancelled()) {
            onCancelled(result);
        } else {
            onPostExecute(result);
        }
        mStatus = Status.FINISHED;
    }
</code></pre>

<p>从下面的代码可以看出，ThreadPoolExecutor是类变量，所以不管创建多少个AsyncTask子类的对象，他们都共用一个线程池。默认线程池可维护的线程数和最大数量，与可用的CUP处理器个数有关。线程池中超过corePoolSize数目的空闲线程最大存活时间1，单位SECONDS。如果线程池的线程数量小于CORE_POOL_SIZE，这个时候新添加一个异步任务则会新建一个线程；如果线程池的数量大于等于CORE_POOL_SIZE，这个时候新建一个异步任务这个任务会被放入缓存队列中等待执行。缓存队列大小为128，并且SerialExecutor是异步顺序执行任务的。</p>

<pre><code>private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE = 1;

private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);

public static final Executor THREAD_POOL_EXECUTOR
        = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);


private static class SerialExecutor implements Executor {
    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        mTasks.offer(new Runnable() {
            public void run() {
                try {
                    r.run();
                } finally {
                    scheduleNext();
                }
            }
        });
        if (mActive == null) {
            scheduleNext();
        }
    }

    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}
</code></pre>

<h4>问题</h4>

<p>AsyncTask处理任务的时候，一般都是习惯在onPreExecute显示进度条，在数据处理完成之后的onPostExecute关闭进度条。但是当横竖屏切换或者内存重启导致Activity重新启动时，假设你还在onPostExecute写了一些其他逻辑，这个时候的AsyncTask已经与之前的Activity没有关联了，会导致onPostExecute无效问题。</p>

<p>解决办法是在onPostExecute方法里用EventBus,Otto类库或者自己写通知，把结果发送给Activity去处理！！</p>

<pre><code>@Override
    protected void onPostExecute(String result) {
        EventBus.getDefault().post(new AsyncTaskResultEvent(result));
    }
</code></pre>

<h4>个人看法</h4>

<p>觉得Android很喜欢造这种中型轮子啊！好像没什么必要再造个AsyncTask这样的轮子放在SDK里啊? 像AsyncTask这种任务不应该是开发者去完成的吗？还有比如NavigationView，真的有必要吗？这不是应该让开发者来自定义的View吗？反正我不是很理解，这可能也是Android为什么如此碎片化的原因之一吧！&mdash;- 喜欢造中型轮子！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[反编译Android的APK]]></title>
    <link href="http://andyfightting.github.io/blog/2016/09/02/apk-decode/"/>
    <updated>2016-09-02T09:55:10+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/09/02/apk-decode</id>
    <content type="html"><![CDATA[<p>本人用的环境是Mac 10.11.5, 需要用到的工具有：<a href="https://ibotpeaches.github.io/Apktool/">apktool</a>, <a href="https://sourceforge.net/projects/dex2jar/">dex2jar</a>, <a href="http://jd.benow.ca/">JD-GUI</a>。</p>

<p>下面用淘宝2.2.1版本和微信2.3版本为例子来反编译。为什么用这么老的版本？因为可能老版本没有做代码混淆，反编译后会更好看一点。可以用<a href="http://www.anzhi.com/">安智市场</a>来下载历史版本，推荐用安智市场的手机APP来下载，会看到所有的历史版本，而电脑网站只能看到最近的几个历史版本。
<img src="/myimg/android/az_taobao.png" alt="image" /></p>

<h4>1.apktool</h4>

<p>需要至少Java 7环境，通过<code>java -version</code>查看
<img src="/myimg/android/javaVersion.png" alt="image" /></p>

<p>配置apktool
<img src="/myimg/android/apktool.png" alt="image" /></p>

<p>输入apktool如下所示就成功了
<img src="/myimg/android/apktool_result.png" alt="imag" /></p>

<p>用apktool工具处理后就可以查看xml文件了。在桌面建一个文件夹test, 把apk文件放进去，进入该文件夹，然后执行<code>apktool d apk名称.apk</code>。就会在test文件夹里出现一个<code>apk名称</code>的文件夹。里面的资源文件和xml文件就可以打开查看了。
<img src="/myimg/android/apktool1.png" alt="imag" />
<img src="/myimg/android/apktool2.png" alt="imag" />
<img src="/myimg/android/apktool3.png" alt="imag" /></p>

<h4>2.dex2jar</h4>

<p>dex2jar工具可以吧dex或者apk文件转成jar文件。dex2jar下载好后进入文件夹，执行<code>chmod a+x *.sh</code>命令启用.sh文件。</p>

<h6>方式一</h6>

<p>把apk文件的后缀名改为zip，然后解压得到classes.dex文件，把classes.dex文件放到dex2jar文件夹中，进入该文件夹，执行<code>sh d2j-dex2jar.sh classes.dex</code>命令，就会得到对应的jar文件。</p>

<h6>方式二</h6>

<p>直接把apk文件放入dex2jar文件夹中，执行<code>sh d2j-dex2jar.sh apk名称.apk</code>也会得到对应的jar文件。</p>

<h4>3.JD-GUI</h4>

<p>把JD-GUI下载下来，打开上面生成的jar文件就可查看了。
<img src="/myimg/android/taobao211.png" alt="image" /></p>

<p>下面是微信2.3处理后的结果
<img src="/myimg/android/wx1.png" alt="image" />
<img src="/myimg/android/wx2.png" alt="image" />
<img src="/myimg/android/wx3.png" alt="image" />
剩下的就看细心、耐心、和好奇心了&hellip;下面说说我是怎么查看QQ2.0的。</p>

<h3>我的查看流程</h3>

<p>找一个页面的特殊字符，如下面的"我的个人资料"
<img src="/myimg/android/find00.jpg" alt="image" /></p>

<p>然后Finder搜索，找到strings.xml文件，在里面找到"我的个人资料"对应的key &ndash; &ldquo;info_info"。
<img src="/myimg/android/find0.png" alt="image" />
<img src="/myimg/android/find1.png" alt="image" /></p>

<p>然后搜"info_info"，找到对应的布局文件"info_self.xml"
<img src="/myimg/android/find2.png" alt="image" /></p>

<p>然后通过"info_self"布局文件名搜索，找到对应的smali文件
<img src="/myimg/android/find3.png" alt="image" /></p>

<p>然后通过smali文件名"InfoActivity"在JD-GUI的Search功能搜索，不是Find!找到对应的Activity，这样想看的东西应该都能找到了。
<img src="/myimg/android/find4.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中的Fragment]]></title>
    <link href="http://andyfightting.github.io/blog/2016/09/01/fragment/"/>
    <updated>2016-09-01T11:38:27+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/09/01/fragment</id>
    <content type="html"><![CDATA[<p>在 Android 3.0（API 11 级）中引入了Fragment，主要是为了给大屏幕上更加动态和灵活的 UI 设计提供支持。由于平板电脑的屏幕比手机屏幕大得多，因此可用于组合和交换 UI 组件的空间更大。利用Fragment实现此类设计时，无需管理对视图层次结构的复杂更改。它具有自己的生命周期，能接收自己的输入事件，并且可以在 Activity 运行时添加或删除Fragment，有点像可以在不同 Activity 中重复使用的"子 Activity"。 通过将 Activity 布局分成Fragment，可以在运行时修改 Activity 的外观，并在由 Activity 管理的返回栈中保留这些更改。Fragment必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。当 Activity 暂停时，其中的所有Fragment也会暂停；当 Activity 被销毁时，所有Fragment也会被销毁。</p>

<p>下面是Android官网上的<a href="https://developer.android.com/guide/components/activities.html">Activity</a>和<a href="https://developer.android.com/guide/components/fragments.html">Fragment</a>的生命周期图。</p>

<p><img src="/myimg/android/activity_lifecycle.png" alt="imga" /> <img src="/myimg/android/fragment_lifecycle.png" alt="imga" /></p>

<p>下面是网友整理的详细的<a href="https://github.com/xxv/android-lifecycle">周期图比较</a>。</p>

<p><img src="/myimg/android/fragment.png" alt="image" /></p>

<h4>用Fragment可能会遇到的问题</h4>

<h5>getActivity()空指针</h5>

<p>可能遇到过getActivity()返回null，或者平时运行完好的代码，在“内存重启”之后，调用getActivity()的地方却返回null，报了空指针异常。大多数情况下的原因：在调用了getActivity()时，当前的Fragment已经onDetach()了宿主Activity。比如在pop了Fragment之后，该Fragment的异步任务仍然在执行，并且在执行完成后调用了getActivity()方法，这样就会空指针。</p>

<p>可以在Fragment基类里设置一个Activity mActivity的全局变量，在onAttach(Activity activity)里赋值，使用mActivity代替getActivity()，保证Fragment即使在onDetach后，仍持有Activity的引用。</p>

<h5>Fragment重叠问题</h5>

<p>如果add()了几个Fragment，然后使用show()、hide()方法控制，比如微信、QQ的底部tab等情景。如果你什么都不做的话，在“内存重启”后回，Tab的这几个Fragment界面会重叠。(手机横竖屏切换就可以模拟“内存重启”)。原因是FragmentManager帮我们管理Fragment，当发生“内存重启”，他会从栈底向栈顶的顺序恢复Fragment，但是因为没有保存Fragment的hidden属性，默认为false，所以所有Fragment都是以show的形式恢复，界面就重叠了。</p>

<h5>解决方法一</h5>

<p>不用add()的方式处理tab的Fragment，直接在Activity的布局文件中添加需要的Fragment,然后在Activity中通过getFragmentManager().findFragmentById()的方式得到Fragment，然后处理对应的hide,show。</p>

<pre><code>    &lt;fragment
        android:id="@+id/fragment0"
        android:name="com.suguiming.myandroid.tab0.Fragment0"
        android:layout_above="@+id/tab_line"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:layout="@layout/fragment_container"/&gt;
    &lt;fragment
        android:id="@+id/fragment1"
        android:name="com.suguiming.myandroid.tab1.Fragment1"
        android:layout_above="@+id/tab_line"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:layout="@layout/fragment_container"/&gt;
</code></pre>

<h5>解决方法二</h5>

<p>在用add()或者replace()时为Fragment绑定一个tag，一般用fragment的类名作为tag，然后在发生“内存重启”时，即savedInstanceState!=null 时，通过getFragmentManager().findFragmentByTag()找到对应的Fragment，然后hide、show 对应的Fragment。</p>

<pre><code>protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity);

TargetFragment targetFragment;
HideFragment hideFragment;

if (savedInstanceState != null) {  // “内存重启”时调用
    targetFragment = getSupportFragmentManager().findFragmentByTag(TargetFragment.class.getName);
    hideFragment = getSupportFragmentManager().findFragmentByTag(HideFragment.class.getName);
    // 解决重叠问题
    getFragmentManager().beginTransaction()
            .show(targetFragment)
            .hide(hideFragment)
            .commit();
}else{  // 正常时
    targetFragment = TargetFragment.newInstance();
    hideFragment = HideFragment.newInstance();

    getFragmentManager().beginTransaction()
            .add(R.id.container, targetFragment, targetFragment.getClass().getName())
            .add(R.id,container,hideFragment,hideFragment.getClass().getName())
            .hide(hideFragment)
            .commit();
}
}
</code></pre>

<h5>解决方法三</h5>

<p>由于造成重叠的原因是因为Fragment不会保存hide的状态，那我们可以在BaseFragment中手动保存然后处理啊！</p>

<pre><code>private static final String FRAGMENT_IS_HIDDEN = "FRAGMENT_IS_HIDDEN";

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    //解决重叠问题
    if (savedInstanceState != null) {
        boolean isHidden = savedInstanceState.getBoolean(FRAGMENT_IS_HIDDEN);
        FragmentTransaction ft = getFragmentManager().beginTransaction();
        if (isHidden) {
            ft.hide(this);
        } else {
            ft.show(this);
        }
        ft.commit();
    }
}

@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    outState.putBoolean(FRAGMENT_IS_HIDDEN, isHidden());//保持fragment是否隐藏的状态
}
</code></pre>

<p>在使用时还是要注意判断savedInstanceState是否为null，只有在为空时才add()。在不为空时就可以不用处理了，交由BaseFragment处理了。</p>
]]></content>
  </entry>
  
</feed>
