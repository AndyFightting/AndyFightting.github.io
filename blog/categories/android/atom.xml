<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-09-02T13:23:22+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[反编译Android的APK]]></title>
    <link href="http://andyfightting.github.io/blog/2016/09/02/apk-decode/"/>
    <updated>2016-09-02T09:55:10+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/09/02/apk-decode</id>
    <content type="html"><![CDATA[<p>本人用的环境是Mac 10.11.5, 需要用到的工具有：<a href="https://ibotpeaches.github.io/Apktool/">apktool</a>, <a href="https://sourceforge.net/projects/dex2jar/">dex2jar</a>, <a href="http://jd.benow.ca/">JD-GUI</a>。</p>

<p>下面用淘宝2.2.1版本和微信2.3版本为例子来反编译。为什么用这么老的版本？因为可能老版本没有做代码混淆，反编译后会更好看一点。可以用<a href="http://www.anzhi.com/">安智市场</a>来下载历史版本，推荐用安智市场的手机APP来下载，会看到所有的历史版本，而电脑网站只能看到最近的几个历史版本。
<img src="/myimg/android/az_taobao.png" alt="image" /></p>

<h4>1.apktool</h4>

<p>需要至少Java 7环境，通过<code>java -version</code>查看
<img src="/myimg/android/javaVersion.png" alt="image" /></p>

<p>配置apktool
<img src="/myimg/android/apktool.png" alt="image" /></p>

<p>输入apktool如下所示就成功了
<img src="/myimg/android/apktool_result.png" alt="imag" /></p>

<p>用apktool工具处理后就可以查看xml文件了。在桌面建一个文件夹test, 把apk文件放进去，进入该文件夹，然后执行<code>apktool d apk名称.apk</code>。就会在test文件夹里出现一个<code>apk名称</code>的文件夹。里面的资源文件和xml文件就可以打开查看了。
<img src="/myimg/android/apktool1.png" alt="imag" />
<img src="/myimg/android/apktool2.png" alt="imag" />
<img src="/myimg/android/apktool3.png" alt="imag" /></p>

<h4>2.dex2jar</h4>

<p>dex2jar工具可以吧dex或者apk文件转成jar文件。dex2jar下载好后进入文件夹，执行<code>chmod a+x *.sh</code>命令启用.sh文件。</p>

<h6>方式一</h6>

<p>把apk文件的后缀名改为zip，然后解压得到classes.dex文件，把classes.dex文件放到dex2jar文件夹中，进入该文件夹，执行<code>sh d2j-dex2jar.sh classes.dex</code>命令，就会得到对应的jar文件。</p>

<h6>方式二</h6>

<p>直接把apk文件放入dex2jar文件夹中，执行<code>sh d2j-dex2jar.sh apk名称.apk</code>也会得到对应的jar文件。</p>

<h4>3.JD-GUI</h4>

<p>把JD-GUI下载下来，打开上面生成的jar文件就可查看了。
<img src="/myimg/android/taobao211.png" alt="image" /></p>

<p>下面是微信2.3处理后的结果
<img src="/myimg/android/wx1.png" alt="image" />
<img src="/myimg/android/wx2.png" alt="image" />
<img src="/myimg/android/wx3.png" alt="image" />
剩下的就看细心、耐心、和好奇心了&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android中的Fragment]]></title>
    <link href="http://andyfightting.github.io/blog/2016/09/01/fragment/"/>
    <updated>2016-09-01T11:38:27+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/09/01/fragment</id>
    <content type="html"><![CDATA[<p>在 Android 3.0（API 11 级）中引入了Fragment，主要是为了给大屏幕上更加动态和灵活的 UI 设计提供支持。由于平板电脑的屏幕比手机屏幕大得多，因此可用于组合和交换 UI 组件的空间更大。利用Fragment实现此类设计时，无需管理对视图层次结构的复杂更改。它具有自己的生命周期，能接收自己的输入事件，并且可以在 Activity 运行时添加或删除Fragment，有点像可以在不同 Activity 中重复使用的"子 Activity"。 通过将 Activity 布局分成Fragment，可以在运行时修改 Activity 的外观，并在由 Activity 管理的返回栈中保留这些更改。Fragment必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。当 Activity 暂停时，其中的所有Fragment也会暂停；当 Activity 被销毁时，所有Fragment也会被销毁。</p>

<p>下面是Android官网上的<a href="https://developer.android.com/guide/components/activities.html">Activity</a>和<a href="https://developer.android.com/guide/components/fragments.html">Fragment</a>的生命周期图。</p>

<p><img src="/myimg/android/activity_lifecycle.png" alt="imga" /> <img src="/myimg/android/fragment_lifecycle.png" alt="imga" /></p>

<p>下面是网友整理的详细的<a href="https://github.com/xxv/android-lifecycle">周期图比较</a>。</p>

<p><img src="/myimg/android/fragment.png" alt="image" /></p>

<h4>用Fragment可能会遇到的问题</h4>

<h5>getActivity()空指针</h5>

<p>可能遇到过getActivity()返回null，或者平时运行完好的代码，在“内存重启”之后，调用getActivity()的地方却返回null，报了空指针异常。大多数情况下的原因：在调用了getActivity()时，当前的Fragment已经onDetach()了宿主Activity。比如在pop了Fragment之后，该Fragment的异步任务仍然在执行，并且在执行完成后调用了getActivity()方法，这样就会空指针。</p>

<p>可以在Fragment基类里设置一个Activity mActivity的全局变量，在onAttach(Activity activity)里赋值，使用mActivity代替getActivity()，保证Fragment即使在onDetach后，仍持有Activity的引用。</p>

<h5>Fragment重叠问题</h5>

<p>如果add()了几个Fragment，然后使用show()、hide()方法控制，比如微信、QQ的底部tab等情景。如果你什么都不做的话，在“内存重启”后回，Tab的这几个Fragment界面会重叠。(手机横竖屏切换就可以模拟“内存重启”)。原因是FragmentManager帮我们管理Fragment，当发生“内存重启”，他会从栈底向栈顶的顺序恢复Fragment，但是因为没有保存Fragment的hidden属性，默认为false，所以所有Fragment都是以show的形式恢复，界面就重叠了。</p>

<h5>解决方法一</h5>

<p>不用add()的方式处理tab的Fragment，直接在Activity的布局文件中添加需要的Fragment,然后在Activity中通过getFragmentManager().findFragmentById()的方式得到Fragment，然后处理对应的hide,show。</p>

<pre><code>    &lt;fragment
        android:id="@+id/fragment0"
        android:name="com.suguiming.myandroid.tab0.Fragment0"
        android:layout_above="@+id/tab_line"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:layout="@layout/fragment_container"/&gt;
    &lt;fragment
        android:id="@+id/fragment1"
        android:name="com.suguiming.myandroid.tab1.Fragment1"
        android:layout_above="@+id/tab_line"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:layout="@layout/fragment_container"/&gt;
</code></pre>

<h5>解决方法二</h5>

<p>在用add()或者replace()时为Fragment绑定一个tag，一般用fragment的类名作为tag，然后在发生“内存重启”时，即savedInstanceState!=null 时，通过getFragmentManager().findFragmentByTag()找到对应的Fragment，然后hide、show 对应的Fragment。</p>

<pre><code>protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity);

TargetFragment targetFragment;
HideFragment hideFragment;

if (savedInstanceState != null) {  // “内存重启”时调用
    targetFragment = getSupportFragmentManager().findFragmentByTag(TargetFragment.class.getName);
    hideFragment = getSupportFragmentManager().findFragmentByTag(HideFragment.class.getName);
    // 解决重叠问题
    getFragmentManager().beginTransaction()
            .show(targetFragment)
            .hide(hideFragment)
            .commit();
}else{  // 正常时
    targetFragment = TargetFragment.newInstance();
    hideFragment = HideFragment.newInstance();

    getFragmentManager().beginTransaction()
            .add(R.id.container, targetFragment, targetFragment.getClass().getName())
            .add(R.id,container,hideFragment,hideFragment.getClass().getName())
            .hide(hideFragment)
            .commit();
}
}
</code></pre>

<h5>解决方法三</h5>

<p>由于造成重叠的原因是因为Fragment不会保存hide的状态，那我们可以在BaseFragment中手动保存然后处理啊！</p>

<pre><code>private static final String FRAGMENT_IS_HIDDEN = "FRAGMENT_IS_HIDDEN";

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    //解决重叠问题
    if (savedInstanceState != null) {
        boolean isHidden = savedInstanceState.getBoolean(FRAGMENT_IS_HIDDEN);
        FragmentTransaction ft = getFragmentManager().beginTransaction();
        if (isHidden) {
            ft.hide(this);
        } else {
            ft.show(this);
        }
        ft.commit();
    }
}

@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    outState.putBoolean(FRAGMENT_IS_HIDDEN, isHidden());//保持fragment是否隐藏的状态
}
</code></pre>

<p>在使用时还是要注意判断savedInstanceState是否为null，只有在为空时才add()。在不为空时就可以不用处理了，交由BaseFragment处理了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android手势滑动返回]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/31/android-swipe/"/>
    <updated>2016-08-31T15:16:10+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/31/android-swipe</id>
    <content type="html"><![CDATA[<p>偶然间发现了一个Android自带的抽屉控件<a href="https://developer.android.com/training/implementing-navigation/nav-drawer.html">DrawerLayout</a>,就觉得应该可以用他来封装成手势返回的基础控件。思路就是先设置Activity的跳转动画是从右到左，并且前一个Activity不能动。然后设置DrawerLayout的menu从右边出来，然设置menu全屏，这个menu就相当于子Activity View的容器，默认打开menu,然后设置DrawerLayout容器透明，当DrawerLayout close的时候finish它所在的Activity！还要把状态栏设置成透明，不然DrawerLayout closed 再 finish Activity的时候会有视觉差！复杂的手势控制就交由自带的DrawerLayout处理啦，生命周期还是Activity的生命周期。怎么样，是不是机智如我！！😆</p>

<p>遇到的问题：DrawerLayout的menu即时设置成match_parent也不能全屏！因为源码里设置了margin64dp! 那我们只好再设置回来：android:layout_marginLeft=&ldquo;-64dp"。</p>

<pre><code> private static final int MIN_DRAWER_MARGIN = 64; // dp
</code></pre>

<p>BaseSwipeActivity</p>

<pre><code>package com.suguiming.myandroid.base;
import android.os.Bundle;
import android.support.v4.view.GravityCompat;
import android.support.v4.widget.DrawerLayout;
import android.support.v7.app.ActionBarDrawerToggle;
import android.support.v7.app.AppCompatActivity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.WindowManager;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;

import com.suguiming.myandroid.R;

public class BaseSwipeActivity extends AppCompatActivity {

private DrawerLayout drawer;
private LinearLayout containerLayout;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    setContentView(R.layout.activity_base_swipe);

    containerLayout = (LinearLayout) findViewById(R.id.container_layout);

    drawer = (DrawerLayout) findViewById(R.id.base_drawer_layout);
    drawer.openDrawer(GravityCompat.END);
    ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawer, R.string.navigation_drawer_open, R.string.navigation_drawer_close) {
        @Override
        public void onDrawerClosed(View drawerView) {
            super.onDrawerClosed(drawerView);
            finish();
        }
    };
    drawer.setDrawerListener(toggle);
}

//子类不要用setContentView,用setMainView!!!!
public void setMainView(int viewId) {
    LayoutInflater inflater = LayoutInflater.from(this);
    View tmpView = inflater.inflate(viewId, null);

    if (tmpView instanceof LinearLayout) {
        LinearLayout.LayoutParams linearLayoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(linearLayoutParams);
    } else if (tmpView instanceof RelativeLayout) {
        RelativeLayout.LayoutParams relativeLayoutParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(relativeLayoutParams);
    }
    containerLayout.removeAllViews();
    containerLayout.addView(tmpView);
}

}
</code></pre>

<p>对应的布局文件</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="@android:color/transparent"
    tools:context="com.suguiming.myandroid.base.BaseSwipeActivity"&gt;

&lt;android.support.v4.widget.DrawerLayout
    android:id="@+id/base_drawer_layout"
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/transparent"
    tools:openDrawer="end"&gt;
    &lt;LinearLayout
        android:orientation="vertical"
        android:background="@color/clear"
        android:layout_width="match_parent"
        android:layout_height="match_parent"&gt;
    &lt;/LinearLayout&gt;

    &lt;!---64dp是源码menu的margin,这里设置为65,不然会有一条黑线--&gt;
    &lt;LinearLayout
        android:id="@+id/container_layout"
        android:orientation="vertical"
        android:layout_gravity="end"
        android:layout_marginLeft="-65dp"
        android:background="@color/light_gray"
        android:layout_width="match_parent"
        android:layout_height="match_parent"&gt;
    &lt;/LinearLayout&gt;
&lt;/android.support.v4.widget.DrawerLayout&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p>push 的动画 style</p>

<pre><code>&lt;!--手势返回theme--&gt;
&lt;style name="BackSwipeTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;
    &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt;
    &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt;
    &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="android:backgroundDimEnabled"&gt;false&lt;/item&gt;
    &lt;item name="android:windowAnimationStyle"&gt;@style/ActivitySwipeBackAnimation&lt;/item&gt;
&lt;/style&gt;
&lt;style name="ActivitySwipeBackAnimation" parent="@android:style/Animation.Activity"&gt;
    &lt;item name="android:activityOpenEnterAnimation"&gt;@anim/activity_swipe_in&lt;/item&gt;
    &lt;item name="android:activityOpenExitAnimation"&gt;@anim/activity_swipe_out&lt;/item&gt;
    &lt;item name="android:activityCloseEnterAnimation"&gt;@anim/activity_swipe_in&lt;/item&gt;
    &lt;item name="android:activityCloseExitAnimation"&gt;@anim/activity_swipe_out&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>使用的话就是让Activity继承BaseSwipeActivity，然后设置Activity的Theme为BackSwipeTheme。</p>

<pre><code>public class ActivitySwipeBack extends BaseSwipeActivity {
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    //要用setMainView，不要用setContentView
    setMainView(R.layout.activity_activity_swipe_back);
  }
}

&lt;activity android:name=".tab0.ActivitySwipeBack"
            android:theme="@style/BackSwipeTheme"/&gt;
</code></pre>

<p>完整Demo请查看<a href="https://github.com/AndyFightting/MyAndroid">MyAndroid</a>中的"手势滑动返回"。</p>

<p><img src="/myimg/android/android_swipe.png" alt="imge" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android基本存储]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/23/androidsave/"/>
    <updated>2015-11-23T19:48:52+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/23/androidsave</id>
    <content type="html"><![CDATA[<p>Android数据保存方式有： 文件存储, SharedPreference, Sqlite, SD卡存储。</p>

<h3>* 文件存储</h3>

<p>不对存储数据做任何格式化处理，原封不动的保存到文件中。使用于保存简单的文本数据或者二进制数据。</p>

<p>Context有个<code>openFileOutput()</code>方法接受两个参数，第一个：文件名，<strong>不要包含路径</strong>，第二个：操作方式，有两种，<code>MODE_PRIVATE</code>(覆盖原文件内容),<code>MODE_APPEND</code>(在原文件尾部追加内容)，默认第一种。文件默认保存在：<code>/data/data/packageName/files/</code>这个目录里。</p>

<pre><code> public static void saveText(Context context,String fileName,String text){
    FileOutputStream outputStream ;
    BufferedWriter bufferedWriter = null;
    try {
       outputStream = context.openFileOutput(fileName,Context.MODE_PRIVATE);
        bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write(text);
    }catch (IOException e){
        e.printStackTrace();
    }finally {
        try {
            if (bufferedWriter != null){
                bufferedWriter.close();
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre>

<!--more-->


<p>在我调用 <code>MyTool.saveText(this,"myFile","Hello World!");</code>后出现了如下文件，点画圈圈的地方可以导出到电脑上打开查看。
<img src="/myimg/android/helloSave.png" alt="img" /></p>

<p>读文件</p>

<pre><code>public static String getText(Context context,String fileName){
    FileInputStream inputStream;
    BufferedReader bufferReader = null;
    StringBuilder contentBuilder = new StringBuilder();
    try {
        inputStream = context.openFileInput(fileName);
        bufferReader = new BufferedReader(new InputStreamReader(inputStream));
        String lineText = "";
        while ((lineText = bufferReader.readLine()) != null){
            contentBuilder.append(lineText);
        }
    }catch (IOException e){
        e.printStackTrace();
    }finally {
       if (bufferReader != null){
           try {
               bufferReader.close();
           }catch (IOException e){
               e.printStackTrace();
           }
       }
    }
    return contentBuilder.toString();
}
</code></pre>

<p>删除文件</p>

<pre><code>public static void deleteFile(Context context, String fileName) {
    String filePath = context.getFilesDir()+"/"+fileName;
    File file = new File(filePath);
    if (file.exists()){
        file.delete();
    }
}
</code></pre>

<h3>* SharedPreference</h3>

<p>用key-value键值对的方式保存数据，适用于保存应用配置之类的简单信息。有以下三种方式得到<code>SharedPreferences</code>对象，得到实例后调用实例的<code>edit()</code>方法得到<code>SharedPreferences.Editor</code>对象，用该<code>Editor</code>对象<code>putBoolean("key",value)``putString("key",value)</code>等方法添加数据，然后调用<code>apply()</code>即可。获取数据就调用对应的<code>getBoolean("key")``getString("key")</code>。文件保存在<code>/data/data/packageName/shared_prefs/</code>目录下。</p>

<ol>
<li><p>Context中的<code>getSharedPreferences()</code>方法接收两个参数，一个文件名(不要包含路径)，一个操作模式，有<code>MODE_PRIVATE</code>(覆盖原文件),<code>MODE_MULTI_PROCESS</code>(多个进程对文件进行读写情况)默认第一种。</p></li>
<li><p>Activity中也有个一个类似的方法<code>getSharedPreferences()</code>，它只接收一个操作模式作为参数，<strong>自动将类名作为文件名</strong>。</p></li>
<li><p>PreferenceManager类中的<code>getDefaultSharedPreferences()</code>，这是一个静态方法，接收一个参数<code>Context</code>,自动将应用程序的<code>packageName</code>为前缀的文件名,如我的包名是<code>com.suguiming.myandroid</code>,生成的文件名就是<code>com.suguiming.myandroid_preferences.xml</code>。</p></li>
</ol>


<pre><code>    SharedPreferences sharedPreferences =   PreferenceManager.getDefaultSharedPreferences(context);
      SharedPreferences.Editor editor = sharedPreferences.edit();
        editor.putString("name","guimingsu");
        editor.putInt("age", 18);
        editor.apply();
</code></pre>

<p><img src="/myimg/android/shareP.png" alt="img" />
<img src="/myimg/android/shareV.png" alt="img" /></p>

<p>一般都把它做成一个工具类</p>

<pre><code>public class SharedPreUtil {

public static final String FILE_NAME = "shared_preference";

public static void put(Context context, String key, Object value) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPreferences.edit();

    if (value instanceof String) {
        editor.putString(key, (String) value);
    } else if (value instanceof Integer) {
        editor.putInt(key, (Integer) value);
    } else if (value instanceof Boolean) {
        editor.putBoolean(key, (Boolean) value);
    } else if (value instanceof Float) {
        editor.putFloat(key, (Float) value);
    } else if (value instanceof Long) {
        editor.putLong(key, (Long) value);
    } else {
        editor.putString(key, value.toString());
    }
    editor.apply();
}

public static Object get(Context context, String key, Object defaultValue) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);

    if (defaultValue instanceof String) {
        return sharedPreferences.getString(key, (String) defaultValue);
    } else if (defaultValue instanceof Integer) {
        return sharedPreferences.getInt(key, (Integer) defaultValue);
    } else if (defaultValue instanceof Boolean) {
        return sharedPreferences.getBoolean(key, (Boolean) defaultValue);
    } else if (defaultValue instanceof Float) {
        return sharedPreferences.getFloat(key, (Float) defaultValue);
    } else if (defaultValue instanceof Long) {
        return sharedPreferences.getLong(key, (Long) defaultValue);
    }
    return null;
}

public static void remove(Context context, String key) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPreferences.edit();
    editor.remove(key);
    editor.apply();
}

public static void removeAll(Context context) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPreferences.edit();
    editor.clear();
    editor.apply();
}

}
</code></pre>

<h3>* SQLite</h3>

<p>关系型的轻量级数据库，保存复杂或者大数据用这个，支持标准的SQL语法。</p>

<p>创建数据库：Android提供了一个抽象类<code>SQLiteOpenHelper</code>，我们继承它重写里面的两个方法<code>onCreate()</code>,<code>onUpdate()</code>来创建和更新数据库表结构。创建的数据库会保存在 <code>/data/data/packageName/databases/</code>目录下。通过<code>getReadableDatabase</code>或者<code>getWritableDatabase</code>都可得到可读写的数据库，但如果数据库不可写时(如磁盘已满)，<code>getWritableDatabase</code>会报错，<code>getReadableDatabase</code>不会。</p>

<p>调用<code>MySqliteHelper.getHelper(mainActivity).getReadableDatabase();</code>一下数据库就建好了，下次再调用就不会再创建了。</p>

<pre><code>public class MyDatabaseHelper extends SQLiteOpenHelper {

private static MyDatabaseHelper helper;
private static final String DB_NAME = "myAndroid.db";

public MyDatabaseHelper(Context context){
    super(context, DB_NAME, null, 2);//2 数据库version,修改数据库用
}

@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL(create_dog);
    db.execSQL(create_cat);
}

@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    //更新表才用,这里假设在 版本2 中要添加 cat 表,注意：switch 不要 break !!
    switch (newVersion){
        case 2:
            db.execSQL(create_cat);
        default:
    }
}
//获取 helper 单例
public static synchronized MyDatabaseHelper getHelper(Context context) {
    context = context.getApplicationContext();
    if (helper == null) {
        synchronized (MyDatabaseHelper.class) {
            if (helper == null)
                helper = new MyDatabaseHelper(context);
        }
    }
    return helper;
}

//-------------sql----------------------------
    public static final String create_dog = "create table dog ("
            +"id integer primary key autoincrement,"
            +"name text,"
            +"age integer,"
            +"weight real)";

    public static final String create_cat = "create table cat ("
            +"id integer primary key autoincrement,"
            +"name text,"
            +"age integer,"
            +"weight real)";
}
</code></pre>

<p><img src="/myimg/android/mydb.png" alt="img" />  <br/>
把数据库导出到桌面，用<a href="http://www.sqlitemanager.org/">SQLiteManager</a>打开查看
<img src="/myimg/android/mytable.png" alt="img" /></p>

<p>数据增，删，改，查的最简单的例子</p>

<pre><code>public class DogDao {
private static final String TABLE_NAME = "dog";

public static void add(Context context,Dog dog){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("name",dog.getName());
    values.put("age",dog.getAge());
    values.put("weight",dog.getWeight());
    db.insert(TABLE_NAME, null, values);
}

public static void update(Context context,Dog dog){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("name",dog.getName());
    values.put("age",dog.getAge());
    values.put("weight",dog.getWeight());
    db.update(TABLE_NAME, values, null, null);
}

public static void deleteAll(Context context){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    db.delete(TABLE_NAME, null, null);
}

public static List&lt;Dog&gt; getAll(Context context){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    Cursor cursor = db.query(TABLE_NAME, null, null, null, null, null, null);
    List&lt;Dog&gt; dogList = new ArrayList&lt;&gt;();
    if (cursor.moveToFirst()){
        do {
            Dog dog = new Dog();
            dog.setName(cursor.getString(cursor.getColumnIndex("name")));
            dog.setAge(cursor.getInt(cursor.getColumnIndex("age")));
            dog.setWeight(cursor.getFloat(cursor.getColumnIndex("weight")));
            dogList.add(dog);
        }while (cursor.moveToNext());
    }
    cursor.close();
    return dogList;
}

//事务，要么都成功，要么都失败。
public static void transactionTest(Context context){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    db.beginTransaction();
    try {
        //数据处理....

        db.setTransactionSuccessful();
    }catch (Exception e){
        e.printStackTrace();
    }finally {
        db.endTransaction();
    }
}
}
</code></pre>

<p>也可以用 Android SDK <code>/platform-tools</code>文件夹中自带的<code>adb</code>工具来操作链接在电脑的手机或者模拟器里的数据库。</p>

<p>但要先配置一下，Mac的配置如下，在终端依次输入 <code>cd ~</code> <code>touch .bash_profile</code> <code>open -e .bash_profile</code>这时会打开一个文本文件，在里面添加<code>export PATH=${PATH}:这里是platform-tools文件的路径</code>保存关闭，
然后<code>source .bash-profile</code>刷新，然后输入<code>adb shell</code>就可以开始用了。
<img src="/myimg/android/pzadb.png" alt="img" />
<img src="/myimg/android/pzadb2.png" alt="img" />
如查看数据库<code>cd /data/data/packageName/databases</code> <code>l</code>列出所有数据库
<img src="/myimg/android/adbtable.png" alt="img" /></p>

<h3>* SD卡存储</h3>

<p>SD卡存储和文件存储差不多，只不过是手机外部的存储空间，容量更大，不过在使用的时候要判断SD卡可不可以用。</p>

<pre><code>public class SDCardUtil {

// 默认都保存在这个文件夹下
private static final String DEFAULT_DIR = "ProData/";

public static boolean isEnable() {
    return Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED);
}

public static long getTotalMB() {
    if (!isEnable())
        return 0;
    File path = Environment.getExternalStorageDirectory();
    StatFs stat = new StatFs(path.getPath());
    long blockSize = stat.getBlockSizeLong();
    long availableBlocks = stat.getBlockCountLong();
    return (availableBlocks * blockSize) / 1024 / 1024;
}

public static long getAvailableMB() {
    if (!isEnable())
        return 0;
    File path = Environment.getExternalStorageDirectory();
    StatFs stat = new StatFs(path.getPath());
    long blockSize = stat.getBlockSizeLong();
    long availableBlocks = stat.getAvailableBlocksLong();
    return (availableBlocks * blockSize) / 1024 / 1024;
}

public static long getAvailableByte() {
    if (!isEnable())
        return 0;
    File path = Environment.getExternalStorageDirectory();
    StatFs stat = new StatFs(path.getPath());
    long blockSize = stat.getBlockSizeLong();
    long availableBlocks = stat.getAvailableBlocksLong();
    return availableBlocks * blockSize;
}

// 路径：/storage/sdcard0/
public static String getSDCardPath() {
    if (!isEnable())
        return "";
    return Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator;
}


public static File createDir(String directoryName) {
    //建默认文件夹
    String defaultDir = getSDCardPath() + DEFAULT_DIR;
    File defaultFile = new File(defaultDir);
    if (!defaultFile.exists()) {
        defaultFile.mkdir();
    }

    String dirPath = getFilePath(directoryName);
    File dirFile = new File(dirPath);
    if (!dirFile.exists()) {
        dirFile.mkdir();
    }
    return dirFile;
}

public static File createFile(String fileName) {
    try {
        //建默认文件夹
        String dirPath = getSDCardPath() + DEFAULT_DIR;
        File directory = new File(dirPath);
        if (!directory.exists()) {
            directory.mkdir();
        }

        //再在默认文件夹里建文件
        File file = new File(getFilePath(fileName));
        if (!file.exists()) {
            file.createNewFile();
        }
        return file;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}

public static String getFilePath(String fileName) {
    return getSDCardPath() + DEFAULT_DIR + fileName;
}

public static boolean isFileExist(String fileName) {
    File file = new File(getFilePath(fileName));
    return file.exists();
}

public static boolean saveByte(String fileName, byte[] bytes) {
    if (bytes == null) {
        return false;
    }

    OutputStream output = null;
    try {
        if (bytes.length &lt; getAvailableByte()) {
            File file = createFile(fileName);//这里面已经建了默认文件夹
            output = new BufferedOutputStream(new FileOutputStream(file));
            output.write(bytes);
            output.flush();
            return true;
        }
    } catch (IOException e1) {
        e1.printStackTrace();
    } finally {
        try {
            if (output != null) {
                output.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return false;
}

public static byte[] getByte(String fileName) {
    File file = new File(getFilePath(fileName));
    if (!file.exists()) {
        return null;
    }
    InputStream inputStream = null;
    try {
        inputStream = new BufferedInputStream(new FileInputStream(file));
        byte[] data = new byte[inputStream.available()];
        inputStream.read(data);
        return data;
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (inputStream != null) {
                inputStream.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return null;
}

public static boolean saveBitmap(Bitmap bitmap, String bitmapName) {
    if (bitmap == null) {
        return false;
    }
    //建默认文件夹
    String dirPath = getSDCardPath() + DEFAULT_DIR;
    File directory = new File(dirPath);
    if (!directory.exists()) {
        directory.mkdir();
    }

    File file = new File(getFilePath(bitmapName));
    BufferedOutputStream output = null;
    try {
        output = new BufferedOutputStream(new FileOutputStream(file));
        bitmap.compress(Bitmap.CompressFormat.JPEG, 80, output);
        output.flush();
        output.close();
        return true;
    } catch (IOException e1) {
        e1.printStackTrace();
    } finally {
        try {
            if (output != null) {
                output.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return false;
}

public static Bitmap getBitmap(String bitmapName) {
    String myJpgPath = getFilePath(bitmapName);
    BitmapFactory.Options options = new BitmapFactory.Options();
    return BitmapFactory.decodeFile(myJpgPath, options);
}

public static void removeFile(String fileName) {
    String filePath = getFilePath(fileName);
    File file = new File(filePath);
    if (file.exists()) {
        file.delete();
    }
}

public static void removeFile(File file) {
    if (file.isFile()) {
        file.delete();
        return;
    }
    if (file.isDirectory()) {
        File[] childFiles = file.listFiles();
        if (childFiles == null || childFiles.length == 0) {
            file.delete();
            return;
        }

        for (int i = 0; i &lt; childFiles.length; i++) {
            removeFile(childFiles[i]);
        }
        file.delete();
    }
}

public static void removeAll() {
    String filePath = getSDCardPath() + DEFAULT_DIR;
    File file = new File(filePath);
    if (file.exists()) {
        removeFile(file);
    }

    //再建一个空文件夹
    File directory = new File(filePath);
    if (!directory.exists()) {
        directory.mkdir();
    }
  }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio插件]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/22/studioplugin/"/>
    <updated>2015-11-22T14:10:45+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/22/studioplugin</id>
    <content type="html"><![CDATA[<h3>* Logger</h3>

<p>推荐一款打印工具<a href="https://github.com/orhanobut/logger">Logger</a>,比自带的打印效果更好，主要是json打印是格式化的！Github上写的地址<code>compile 'com.github.orhanobut:logger:1.12'</code>我下载失败，我用的是<code>compile 'com.orhanobut:logger:1.11'</code>。
<img src="/myimg/android/logger.png" alt="img" />
打印颜色可以在preference里设置，要先<code>Save as</code>保存一下，然后把右边的<code>Use inherited attributes</code>取消，然后就可以选择颜色了<!--more-->
<img src="/myimg/android/logColor.png" alt="img" /></p>

<h3>* Sexy Editor</h3>

<p>设置编辑区域背景图的, 这样敲代码也更有力气拉~~哈哈</p>

<p><img src="/myimg/android/screen.png" alt="img" /></p>

<p>怎么添加插件？有如下三种方式<code>install JetBrains plugin</code>,<code>Browse repositories</code>,<code>install plugin from disk</code>。<code>Sexy Editor</code>是用第二种方式添加。</p>

<p><img src="/myimg/android/add_plugin.png" alt="img" /></p>

<p>我的<code>sexy editor</code>设置</p>

<p><img src="/myimg/android/sexy_editor.png" alt="img" /></p>

<h3>* Mac下的快捷键</h3>

<p>Mac中的标识：<code>⌘:command</code>, <code>⌃:control</code>, <code>⇧:shift</code>, <code>⌥:alt/option</code></p>

<p><code>⌘ + ⌥ + L</code>: 代码对齐格式化</p>

<p><code>^ + ⌥ + O</code>: 除去无效的import引用</p>

<p><code>F1</code>: 查看文档</p>

<p><code>F2</code>: 定位到未被使用的成员</p>

<p><code>F3</code>: 添加书签</p>

<p><code>F4</code>: 定位到声明处</p>

<p><code>⇧ + F6</code>: 文件重命名</p>

<p><code>⌘ + F12</code>: 显示内部成员</p>

<p><code>⌘ + ⇧ + F7</code>: 代码高亮</p>

<p><code>⌥ + ⏎</code>: 添加缺少的import</p>

<p><code>⌘ + delete</code>: 删除整行</p>

<p><code>⌘ + N</code>: 生成代码，getter setter 等</p>

<p><code>⌃ + H</code>: 查看类的层级关系</p>

<p><code>⌘ + U</code>: 查看父类的同名方法</p>

<p><code>⌘ + J</code>: 快捷插入常用代码片段</p>

<p><code>⌥ + ⇧ + ↑或↓</code>: 上下移动光标所在的行</p>

<p><code>⌘ + ⇧ + ↑或↓</code>: 上下移动整个方法块</p>

<p><code>⌘ + ⌥ + ⏎</code>: 当前行上面插入一行</p>

<p><code>⌘ + ⇧ + U</code>: 大小写转化</p>

<p><code>⌘ + E</code>: 查看打开过的文件</p>

<p><code>⌃ + T</code>: 重构面板</p>

<p><code>⌃ + O</code>: 选择要重写或者要实现的方法</p>

<p><code>⌘ + O</code>: 快速搜索class</p>

<p><code>⌘ + ⇧ + O</code>: 快速搜索file</p>

<p><code>⌘ + ⇧ + F</code>: 全局搜索</p>

<p><code>⌘ + ⇧ + R</code>: 全局替换</p>

<p><code>⌘ + +或-</code>: 展开或者收起代码块</p>

<p><code>⌘ + /</code>: 注释 //</p>

<p><code>⌘ + ⌥ + /</code>: 注释 /**/</p>

<p><code>⌥ + ⏎</code>: 提示错误解决方法</p>

<p>可能会有人觉得为啥重命名<code>⇧ + F6</code>没反应呢？跟 F1 ~ F12 有关的都没反应&hellip;</p>

<p>因为Mac系统默认没有启用它们&hellip;在系统设置，键盘选项里选中就可以了。</p>

<p><img src="/myimg/android/keyf.png" alt="img" /></p>

<p>当然可以设置自己喜欢的快捷键，我自己把运行和调试改成了<code>⌘ + R</code>和<code>⌘ + D</code></p>

<p><img src="/myimg/android/keymap.png" alt="img" /></p>
]]></content>
  </entry>
  
</feed>
