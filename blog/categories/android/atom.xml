<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2015-11-27T09:44:00+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android基本存储]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/23/androidsave/"/>
    <updated>2015-11-23T19:48:52+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/23/androidsave</id>
    <content type="html"><![CDATA[<p>Android数据保存方式有： 文件存储, SharedPreference, Sqlite, SD卡存储。</p>

<h3>* 文件存储</h3>

<p>不对存储数据做任何格式化处理，原封不动的保存到文件中。使用于保存简单的文本数据或者二进制数据。</p>

<p>Context有个<code>openFileOutput()</code>方法接受两个参数，第一个：文件名，<strong>不要包含路径</strong>，第二个：操作方式，有两种，<code>MODE_PRIVATE</code>(覆盖原文件内容),<code>MODE_APPEND</code>(在原文件尾部追加内容)，默认第一种。文件默认保存在：<code>/data/data/packageName/files/</code>这个目录里。</p>

<pre><code> public static void saveText(Context context,String fileName,String text){
    FileOutputStream outputStream ;
    BufferedWriter bufferedWriter = null;
    try {
       outputStream = context.openFileOutput(fileName,Context.MODE_PRIVATE);
        bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write(text);
    }catch (IOException e){
        e.printStackTrace();
    }finally {
        try {
            if (bufferedWriter != null){
                bufferedWriter.close();
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>在我调用 <code>MyTool.saveText(this,"myFile","Hello World!");</code>后出现了如下文件，点画圈圈的地方可以导出到电脑上打开查看。
<img src="/myimg/android/helloSave.png" alt="img" /></p>

<p>读文件</p>

<pre><code>public static String getText(Context context,String fileName){
    FileInputStream inputStream;
    BufferedReader bufferReader = null;
    StringBuilder contentBuilder = new StringBuilder();
    try {
        inputStream = context.openFileInput(fileName);
        bufferReader = new BufferedReader(new InputStreamReader(inputStream));
        String lineText = "";
        while ((lineText = bufferReader.readLine()) != null){
            contentBuilder.append(lineText);
        }
    }catch (IOException e){
        e.printStackTrace();
    }finally {
       if (bufferReader != null){
           try {
               bufferReader.close();
           }catch (IOException e){
               e.printStackTrace();
           }
       }
    }
    return contentBuilder.toString();
}
</code></pre>

<p>删除文件</p>

<pre><code>public static void deleteFile(Context context, String fileName) {
    String filePath = context.getFilesDir()+"/"+fileName;
    File file = new File(filePath);
    if (file.exists()){
        file.delete();
    }
}
</code></pre>

<h3>* SharedPreference</h3>

<p>用key-value键值对的方式保存数据，适用于保存应用配置之类的简单信息。有以下三种方式得到<code>SharedPreferences</code>对象，得到实例后调用实例的<code>edit()</code>方法得到<code>SharedPreferences.Editor</code>对象，用该<code>Editor</code>对象<code>putBoolean("key",value)``putString("key",value)</code>等方法添加数据，然后调用<code>apply()</code>即可。获取数据就调用对应的<code>getBoolean("key")``getString("key")</code>。文件保存在<code>/data/data/packageName/shared_prefs/</code>目录下。</p>

<ol>
<li><p>Context中的<code>getSharedPreferences()</code>方法接收两个参数，一个文件名(不要包含路径)，一个操作模式，有<code>MODE_PRIVATE</code>(覆盖原文件),<code>MODE_MULTI_PROCESS</code>(多个进程对文件进行读写情况)默认第一种。</p></li>
<li><p>Activity中也有个一个类似的方法<code>getSharedPreferences()</code>，它只接收一个操作模式作为参数，<strong>自动将类名作为文件名</strong>。</p></li>
<li><p>PreferenceManager类中的<code>getDefaultSharedPreferences()</code>，这是一个静态方法，接收一个参数<code>Context</code>,自动将应用程序的<code>packageName</code>为前缀的文件名,如我的包名是<code>com.suguiming.myandroid</code>,生成的文件名就是<code>com.suguiming.myandroid_preferences.xml</code>。</p></li>
</ol>


<pre><code>    SharedPreferences sharedPreferences =   PreferenceManager.getDefaultSharedPreferences(context);
      SharedPreferences.Editor editor = sharedPreferences.edit();
        editor.putString("name","guimingsu");
        editor.putInt("age", 18);
        editor.apply();
</code></pre>

<p><img src="/myimg/android/shareP.png" alt="img" />
<img src="/myimg/android/shareV.png" alt="img" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio插件]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/22/studioplugin/"/>
    <updated>2015-11-22T14:10:45+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/22/studioplugin</id>
    <content type="html"><![CDATA[<h3>* Logger</h3>

<p>推荐一款打印工具<a href="https://github.com/orhanobut/logger">Logger</a>,比自带的打印效果更好，主要是json打印是格式化的！Github上写的地址<code>compile 'com.github.orhanobut:logger:1.12'</code>我下载失败，我用的是<code>compile 'com.orhanobut:logger:1.11'</code>。
<img src="/myimg/android/logger.png" alt="img" />
打印颜色可以在preference里设置，要先<code>Save as</code>保存一下，然后把右边的<code>Use inherited attributes</code>取消，然后就可以选择颜色了<!--more-->
<img src="/myimg/android/logColor.png" alt="img" /></p>

<h3>* Sexy Editor</h3>

<p>设置编辑区域背景图的, 这样敲代码也更有力气拉~~哈哈</p>

<p><img src="/myimg/android/screen.png" alt="img" /></p>

<p>怎么添加插件？有如下三种方式<code>install JetBrains plugin</code>,<code>Browse repositories</code>,<code>install plugin from disk</code>。<code>Sexy Editor</code>是用第二种方式添加。</p>

<p><img src="/myimg/android/add_plugin.png" alt="img" /></p>

<p>我的<code>sexy editor</code>设置</p>

<p><img src="/myimg/android/sexy_editor.png" alt="img" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 基础知识]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/21/androidBase0/"/>
    <updated>2015-11-21T09:26:15+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/21/androidBase0</id>
    <content type="html"><![CDATA[<h3>* Activity启动模式</h3>

<p>在AndroidMainfest.xml里的activity里设置android:launchMode = “xxx”</p>

<p><strong>standard:</strong> 默认模式，每次都会创建一个新的放在栈顶，即使栈里已经有了</p>

<p><strong>singleTop:</strong> 已经在<strong>栈顶</strong>了就不创建，否则还是会创建，即使栈里已经有了</p>

<p><strong>singleTask:</strong> 在活动栈中有了就不创建，直接推到栈顶，<strong>在它之前的全部会被挤出栈</strong>，若活动栈中没有就创建</p>

<p><strong>singleInstance:</strong> 会创建一个<strong>新的活动栈</strong>把自己放进去</p>

<h3>* 随时随地退出程序</h3>

<p>在任何页面都可以被踢下线的实现技巧</p>

<p>创建一个收集Activity的管理类，在BaseActivity的<code>onCreate()</code>方法中添加<code>ActivityManager.addActivity(this)</code>,在<code>onDestroy</code>方法中添加<code>ActivityManager.removeActivity(this)</code>。然后在任何要强退的地方调用<code>ActivityManager.finishAllActivity()</code>。<!--more--></p>

<pre><code>public class ActivityManager {

public static List&lt;Activity&gt; activityList = new ArrayList&lt;&gt;();

public static void addActivity(Activity activity){
    activityList.add(activity);
  }

public static void removeActivity(Activity activity){
    activityList.remove(activity);
  }

public static void finishAllActivity(){
    for (Activity activity : activityList){
        if (!activity.isFinishing()){
            activity.finish();
        }
    }
    activityList.clear();
  }
}
</code></pre>

<h3>* Activity跳转</h3>

<p>一般我们是用如下的方式跳转，需要知道下一个Activity要用哪些参数，多人开发可能有些不便。</p>

<pre><code>Intent intent = new Intent(OneActivity.thi,TwoActivity.class);
intent.putExtra("key","value");
startActivity(intent);
</code></pre>

<p>可以在下一个Activity中把需要的参数暴露出来。</p>

<pre><code>public static void actionStart(Activity activity,String param){
  Intent intent = new Intent(activity,TwoActivity.class);
  intent.putExtra("key","param");
  activity.startActivity(intent);
  activity.finish();
}
</code></pre>

<h3>* ListView的正确使用方式</h3>

<p>实现了item的复用，这样效率最好，ArrayAdapter源码中就是这样弄的。ArrayAdapter把BaseAdapter包装了一遍，实现了<code>getCount</code>,<code>getItem</code>,<code>getItemId</code>，所以这些我们就可以不用再写了，只重写个<code>getView</code>就可以。</p>

<pre><code>public class UserAdapter extends ArrayAdapter&lt;User&gt; {

private int layoutId;
public UserAdapter(Context context, int resourceId, List&lt;User&gt; objects){
      super(context,resourceId,objects);
      layoutId = resourceId;
}

@Override
public View getView(int position, View convertView, ViewGroup parent){

    User user = getItem(position);
    ViewHolder viewHolder;
    View layoutView;

    if (convertView == null){
        layoutView = LayoutInflater.from(getContext()).inflate(layoutId,null);
        viewHolder = new ViewHolder();
        viewHolder.headImage = (ImageView)layoutView.findViewById(R.id.head_img);
        viewHolder.nameTv = (TextView)layoutView.findViewById(R.id.name_tv);
        layoutView.setTag(viewHolder);
    }else {
       layoutView = convertView;
       viewHolder = (ViewHolder)layoutView.getTag();
    }
    //--------在下面赋值 ----------------
    viewHolder.headImage.setImageResource(user.getHeadImgId());
    viewHolder.nameTv.setText(user.getName());

    return layoutView;
}

class ViewHolder{
    ImageView headImage;
    TextView nameTv;
  }
}
</code></pre>

<h3>* px,dpi,dp,density</h3>

<p>Android规定：如果手机一英寸长度上有160个px，那么手机的dpi就是160,此时1dp==1px，即density=1。所以如果一英寸长度上有320个px的话，那么手机的dpi就是320，此时1dp==2px,即density=2。</p>

<p>结论：即相同大小的手机上的dp个数是不变的，如果相同大小的手机像素不同的话，只会影响dip和density的值,所以我们适配手机的时候用的长度单位要用 &mdash;- <code>dp</code></p>

<pre><code>public static int getScreenWidthPx(Context context){
    return  context.getResources().getDisplayMetrics().widthPixels;
}

public static int getScreenHeightPx(Context context){
    return  context.getResources().getDisplayMetrics().heightPixels;
}

public static float getXdpi(Context context){
    return  context.getResources().getDisplayMetrics().xdpi;
}

public static float getYdpi(Context context){
    return  context.getResources().getDisplayMetrics().ydpi;
}

public static float getDensity(Context context){
   return context.getResources().getDisplayMetrics().density;
}
</code></pre>

<h3>* 9-patch图片</h3>

<p>1，在<code>上</code>边绘制的<code>垂直区域</code>会被<code>水平拉伸</code>，在<code>左</code>边绘制的<code>横向区域</code>会被<code>垂直拉伸</code>。</p>

<p>2，在<code>下</code>边和<code>右</code>边绘制的<code>交叉区域</code>是内容放置的区域。</p>

<p><img src="/myimg/android/9patch.jpg" alt="img" /></p>

<h3>* Fragment</h3>

<p>在fragment里可以用<code>getActivity()</code>得到与之关联的Activity。<code>FragmentTransaction</code>的实例可以调用<code>addToBackStack(null)</code>方法把这个事务添加到返回栈中，这样点击返回就是回到事务处理之前的状态,而不是退出Activity。fragment之间的通信可以通过与之共同关联的Activity来转达。</p>

<p>fragment的生命周期与Activity类似，只不过比Activity多了<code>onAttach()</code>,<code>onCreateView()</code>,<code>onActivityCreated()</code>,<code>onDestroyView()</code>,<code>onDetach()</code>。</p>

<p>由生到死依次是：<code>onAttach()</code>, <code>onCreate()</code>,<code>onCreateView()</code>,<code>onActivityCreated()</code>,<code>onStart()</code>,<code>onResume()</code>,<code>onPause()</code>,<code>onStop()</code>,<code>onDestroyView()</code>,<code>onDestroy()</code>,<code>onDetach()</code>。</p>

<p>从返回栈回来后执行的第一个方法是<code>onActivityCreated()</code>,而Activity的轮回后执行的第一个方法是<code>onRestart()</code>,然后再<code>onStart()</code>,<code>onResume()</code>。</p>

<p>同一个Activity怎样让它在不同大小的设备自动加载不同的布局文件呢？用<code>限定符</code>,即在<code>res</code>下建<code>layout-large</code>文件夹或者不同限定符的文件夹，在里面放<code>同名</code>的布局文件。限定符有：<code>small</code>,<code>normal</code>,<code>large</code>,<code>xlarge</code>以及分辨率限定符：<code>ldpi</code>:120dpi以下，<code>mdpi</code>:120-160dpi，<code>hdpi</code>:160-240dpi,<code>xhdpi</code>:240-320dpi，以及方向限定符：<code>land</code>:横屏,<code>port</code>:竖屏。</p>

<p>还有个问题，<code>large</code>，大，到底多大算大呢？可以自己定义这个边界值。如<code>layout-sm600</code>,就是<code>宽度</code>大于600<code>dp</code>的设备叫大，否则叫小。<code>sm</code>的意思是：<code>smallest width</code>。</p>

<h3>* Broadcast 广播</h3>

<p>见名知意，即发一下消息，很多地方都可以收到。广播有两种：异步执行的广播 和 按顺序执行的同步广播。异步广播接收没有先后之分，可看做同时收到，这种广播发出之后不可被拦截。同步广播是按顺序一个一个执行，可以设置接收的优先级(设置<code>IntentFilter</code>的<code>priority</code>值,越大越优先)，这种广播可以被拦截(在<code>onReceive()</code>方法里调用<code>abortBroadcast()</code>废掉这条广播)。</p>

<p>注册接收广播有两种方式：一种是用代码注册，也叫动态注册，动态注册(在<code>onCreate()</code>里调用Activity的方法<code>registerReceiver()</code>)的广播接收一定要在<code>onDestroy</code>中移除注册(调用Activity的<code>unregisterReceiver()</code>)。另一种叫静态注册，是在xml中配置的，这种注册不用移除。</p>

<p>怎么写广播接收器？写个类继承<code>BroadcastReceiver</code>,它是个抽象类，然后重写<code>onReceive()</code>即可，可以通过<code>intent.getAction()</code>来区分不同广播，<strong>在<code>onReceive()</code>方法中不能开启线程</strong>。下面是一个监听网络变化的广播接收器。</p>

<pre><code>class NetWorkChangeReceiver extends BroadcastReceiver{
    @Override
    public void onReceive(Context context,Intent intent){
        ConnectivityManager connectivityManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
        if (networkInfo != null &amp;&amp; networkInfo.isAvailable()){
            Toast.makeText(context,"网络可用",Toast.LENGTH_SHORT).show();
        }else {
            Toast.makeText(context,"网络不可用",Toast.LENGTH_SHORT).show();
        }
    }
}
</code></pre>

<p>用Activity里的方法发送异步广播<code>sendBroadcaset(intent)</code>,和发送同步广播<code>sendOrderedBroadCaset(intent,null)</code>。这样发送的广播都是<code>跨应用</code>的，即A应用发出的广播，B应用也可以收到的！应为这些都是全局广播。</p>

<p>本地广播，即发出的广播只会被<code>本身应用</code>接收到,手机里的其他应用就收不到了。本地广播要用<code>LocalBroadcastManager</code>这个类来管理，即注册和移除的时候不能用<code>Activity</code>的<code>registerReceiver()</code>和<code>unregisterReceiver()</code>方法，而应该用<code>LocalBroadcastManager</code>实例的<code>registerReceiver()</code>和<code>unregisterReceiver()</code>方法，简单吧！<strong>本地广播不会被静态注册的接收器收到！</strong>要接收本地广播，接收器都得用动态注册的方式。</p>
]]></content>
  </entry>
  
</feed>
