<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2017-02-12T20:43:16+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS Not Found for Architecture Arm64]]></title>
    <link href="http://andyfightting.github.io/blog/2016/09/12/link-bug/"/>
    <updated>2016-09-12T10:00:18+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/09/12/link-bug</id>
    <content type="html"><![CDATA[<p>接手维护一个项目，更新一下出现了下面这问题👇
<img src="/myimg/ios/arm64.png" alt="image" /></p>

<p>好像不常见的问题，谷歌一下</p>

<p><a href="http://stackoverflow.com/questions/19213782/undefined-symbols-for-architecture-arm64">Stack Overflow</a>
<img src="/myimg/ios/stackoverflow.png" alt="image" /></p>

<p>说是Architectures设置问题&hellip; 说是Other Linker Flags问题&hellip;说是Target Membership问题&hellip; 改了好像都没用啊，问题还是一动不动的出现在那里&hellip;
<img src="/myimg/ios/targetMap.png" alt="image" /></p>

<p>继续找找找&hellip;用对应的类文件全局搜一下&hellip;诶~ 好像那里不对啊&hellip;路径怎么这样子??怎么和别的不一样~~ 喜出望外，好像知道原因了，果然项目文件夹里看不到该文件，Add Files to &ldquo;XXX"添加文件!
<img src="/myimg/ios/errorLoad.png" alt="image" /></p>

<p>还是不行&hellip;把对应的.h .m文件拖到桌面上，再重新添加到项目里，解决了！！为什么一开始不怀疑是文件索引问题呢？ 因为项目编译没报 XXX.h not found &hellip;以为文件都好好的呢，以为是项目的配置问题&hellip; 所以一开始找问题的方向就跑偏了！其实这问题之前也遇到过，一般是第三方的XXX.a文件出现这问题，只是这次脑袋没长记性&hellip;这问题一般是多人开发项目用SVN更来更去导致的<code>project.pbxproj</code>里对应的文件索引没了。好了，再遇到这问题就不要跑偏了，把对应的文件重新添加就可以了！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/swift-read/"/>
    <updated>2016-08-04T16:23:05+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/swift-read</id>
    <content type="html"><![CDATA[<pre><code>let 声明常量，var 声明变量，会自动进行类型推断(小数推断为Double),一行末尾可不加分号(;)。
值永远不会被隐式转换为其他类型，务必显示强制转换。
if语句的条件不能默认非0为真。 类型后加?号表示可选值，要么有值，要么是nil。
用 if let(或者var) name = optionName 来获取可选值处理。 
`??` 操作符来提供一个默认值。如果`可选值`缺失的话，可以使用默认值来代替。
let nickName: String? = nil
let fullName: String = "John Appleseed"
let informalGreeting = "Hi \(nickName ?? fullName)"
switch支持任意类型的数据以及各种比较操作——不仅仅是整数以及测试相等。
switch的case中自带break，switch要保证全部遍历，否则必须要有default选项。
字典是一个无序的集合，所以他们的键和值以任意顺序迭代结束。
do while --&gt; repeat while.
0&lt;= x &lt;4 等价 0..&lt;4 , 0&lt;= x &lt;=4 等价 0...4 。 
用 func 声明函数，用-&gt;指定返回类型func greet(name: String, day: String) -&gt; String { ... }。 
参数名前用 _ 表示不适用参数标签。参数前面添加字符重新定义适用的参数名。
元组概念，一般用做函数返回值。 -&gt; (min: Int, max: Int, sum: Int) 。
func sumOf(numbers: Int...) -&gt; Int {}，...表示可变个数的参数，这些参数在函数内表现为数组的形式。
函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。
函数是一等类型，像int float一样，可用作参数或者返回值。 
可以使用{}来创建一个匿名闭包。使用in将参数和返回值类型声明与闭包函数体进行分离。
numbers.map({
    (number: Int) -&gt; Int in
    let result = 3 * number
    return result
})
匿名闭包可以有很多种缩写：
let mappedNumbers = numbers.map({ number in 3 * number })
let sortedNumbers = numbers.sort { $0 &gt; $1 }
闭包优化：
利用上下文推断参数和返回值类型
隐式返回单表达式闭包，即单表达式闭包可以省略 return 关键字
参数名称缩写
尾随闭包语法
{ (parameters) -&gt; returnType in
    statements
}
class 声明类,属性都要赋值，要么在声明直接写死，要么在init方法中赋值。 使用deinit创建一个析构函数。
func关键字之前加上关键字static，来指定类方法。还可以用关键字class来允许子类重写父类的方法实现。(static = final + class)(不可重写的类方法)
重写父类方法必须用 override 标记。 属性可以有get set willGet didSet 等方法。 
mutating关键字用来标记一个会修改结构体(属性)的方法。 
extension来为现有的类型添加功能，比如新的方法和计算属性。
泛型(指定类型)就是java中的泛型。 Bool值是true或false。 
typealies name = 类型 给类型起个别名。 
OC中的nil只用在对象上(int不行)，Swift中nil可指任何东西(对象或int)。
使用!来获取一个不存在的可选值会导致错误。隐式解析可选类型(类型!)就是可选类型，但是可以当做非可选类型来使用(不用!解析,没值时会报错)。 
throws do try catch 的使用。Swift的赋值操作不返回任何值。% 浮点数也可以取余运算。 
空合运算符(a ?? b)对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b(b和a要类型相同)。逻辑 &amp;&amp;，|| 都是短路计算的。
条件中的下划线 _ 来忽略对值的访问，case 中的下划线 _ 表示所有可能的值,case中可进行值绑定，case条件可用where语句。 
字典的遍历顺序和插入顺序可能不同(字典无序的)。 
Swift语言的repeat-while循环合其他语言中的do-while循环是类似的。
注意循环中switch中的continue(开始下次)和break(跳到switch}后面继续执行)的差别，switch中的fallthrouth进入下一个case时不会再进行条件判断。
guard(守卫)语句总是有一个else分句。 
调用函数时第一个参数名不要，之后的参数名要，用逗号分开(第一个参数省略其外部参数名，第二个以后的参数使用其本地参数名作为自己的外部参数名。
所有参数需要有不同的本地参数名，但可以共享相同的外部参数名。如果你提供了外部参数名，那么函数在被调用时，必须使用外部参数名。如果你不想为第二个及后续的参数设置参数名，用下划线_代替)。
一个函数最多只能有一个可变参数(...),如果函数同时有默认参数和可变参数要把可变参数放最后。 
函数参数默认是常量，修改会报错，但可以用var声明为变量,修改只在函数体内有效。 
inout参数(只能传入变量)会替换原来的值，使用时在变量名前加&amp;符号。 
原数组不会被sort()方法修改。 闭包就是用{}包起来的函数代码块，用in分开返回值和处理代码，参数不能有默认值。如果需要将闭包作为最后一个参数，可变成尾随闭包。
Array的map方法可返回不同类型。 函数和闭包都是引用类型。
结构体和枚举是值类型，所有的基本类型都是值类型，并且都是以结构体的形式在后台所实现。
默认情况下，值类型的属性不能在它的实例方法中被修改。如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，
然后就可以从其方法内部改变它的属性.并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。
方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。
不能在结构体类型的常量上调用可变方法，因为其属性不能被改变，即使属性是变量属性.
var somePoint = Point(x: 1.0, y: 1.0) //somePoint是var就可以
somePoint.moveByX(2.0, y: 3.0)
let fixedPoint = Point(x: 3.0, y: 3.0)
fixedPoint.moveByX(2.0, y: 3.0)//因为fixedPoint是let 这里将会报告一个错误
类是引用类型。常量实例依然可改变其中的变量属性值。
必须将延迟存储属性声明成变量（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。
如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。
计算属性不直接存储值，而是提供一个 get 和一个可选的 set，来间接获取和设置其他属性或变量的值。
swift指针并不直接指向内存中的某个地址，而且也不要求你使用星号（*）来表明你在创建一个引用。
结构体实例总是通过值传递，类实例总是通过引用传递。
Swift 中字符串（String）,数组（Array）和字典（Dictionary）均以结构体的形式实现的值类型,而在OC中是以类的形式实现的引用类型。
计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。
如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使定义了变量存储属性，由于结构体（struct）属于值类型，当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。
如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行.
这种行为是由于结构体（struct）属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。
引用类型的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。
必须将延迟存储属性声明成变量（使用var关键字），因为属性的初始值可能在实例构造完成之后才会得到。
结构体总是通过被复制的方式在代码中传递，不使用引用计数。
而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。
计算属性不直接存储值，而是提供一个 get和一个可选的set，来间接获取和设置其他属性或变量的值。
必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。
父类的属性在子类的构造器中被赋值时，它在父类中的willSet和didSet观察器会被调用。
全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy特性。局部范围的常量或变量不会延迟计算。
必须给存储类型的类属性指定默认值，因为类型本身无法在初始化过程中使用构造器给类型属性赋值。
结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。
重写类只能扩大范围而不能缩小范围，如把只读属性重写为读写属性，而不能反过来。有setter的话必须也提供getter。重写属性必须写上类型。通过标记final来表示不可被继承或重写。
下标可以定义在类、结构体和枚举中，是访问集合，列表或序列中元素的快捷方式。可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法。
下标允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。语法类似于实例方法语法和计算型属性语法的混合。
与实例方法不同的是，下标可以设定为读写或只读。可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数。
所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。与结构体不同，类实例没有默认的成员逐一构造器。
在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），
都是值类型，并且在底层都是以结构体的形式所实现。值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。
类的实例即时是let也可以改变类里的var属性。
===检测两个类常量或者变量是否引用同一个实例。(值类型不存在引用之说，都是copy)
结构体适用情况：
该数据结构的主要目的是用来封装少量相关简单数据值。
有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。
该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。
该数据结构不需要去继承另一个既有类型的属性或者行为。
一个函数最多只能拥有一个可变参数。函数参数默认是常量。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）。
当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。
函数和闭包都是引用类型。
Swift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。
Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。
类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。
当为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。
可以在构造过程中修改常量属性.只要在构造过程结束时是一个确定的值。可选类型的属性将自动初始化为nil.
结构体的逐一成员构造器：如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。
类没有默认的逐一成员构造器。
如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。
这种限制可以防止你为值类型增加了一个额外的且十分复杂的构造器之后,仍然有人错误的使用自动生成的构造器。
假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（extension）中，而不是写在值类型的原始定义中。
构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。
类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。
类的构造器代理规则：
指定构造器必须调用其直接父类的的指定构造器。
便利构造器(convenience)必须调用同类中定义的其它构造器。
便利构造器必须最终导致一个指定构造器被调用。
(指定构造器必须总是向上代理，便利构造器必须总是横向代理）
两段式构造过程:
第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。
跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。子类不能调用父类的便利构造器。所以在子类中“重写”一个父类便利构造器时，不需要加override前缀。
假设你为子类中引入的所有新属性都提供了默认值,以下 2 个规则适用：
1.如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。
2.如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。
对于规则 2，子类可以将父类的指定构造器实现为便利构造器。
析构器只适用于类，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字deinit来标示。每个类最多只能有一个析构器，而且析构器不带任何参数。析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。
用类型检查操作符（is）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 true，否则返回 false。
某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（as? 或 as!）。
Any 可以表示任何类型，包括函数类型。AnyObject 可以表示任何类的实例。
如果一条catch子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为error的局部常量。
可以使用defer语句在即将离开当前代码块时执行一系列语句。以用defer语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。
defer语句将代码的执行延迟到当前的作用域退出之前。
可选链式调用是一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。
通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。
引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。
如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。
可以通过定义类之间的关系为弱引用或无主引用，以替代强引用，从而解决循环强引用的问题。
弱引用和无主引用允许循环引用中的一个实例引用而另外一个实例不保持强引用。这样实例能够互相引用而不产生循环强引用。
生命周期更长的话用弱引用(如公寓和租客，在公寓对象里的租客属性用弱引用weak)，更短的话用无主引用(客户和银行卡的关系，客户不一定有银行卡，银行卡一定属于某个客户，所以在银行卡对象里的非可选属性客户前用无主引用unowned)。当 ARC 设置弱引用为nil时，属性观察不会被触发。
Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。
Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。
存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。
</code></pre>

<p><img src="/myimg/ios/swift0.png" width="700" alt="" />
<img src="/myimg/ios/swift1.png" width="700" alt="" />
<img src="/myimg/ios/swift2.png" width="700" alt="" />
<code>
无主引用通常都被期望拥有值。不过 ARC 无法在实例被销毁后将无主引用设为nil，因为非可选类型的变量不允许被赋值为nil。
使用无主引用，你必须确保引用始终指向一个未销毁的实例。
如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。
循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如self.someProperty，或者闭包中调用了实例的某个方法，例如self.someMethod()。这两种情况都导致了闭包“捕获”self，从而产生了循环强引用。循环强引用的产生，是因为闭包和类相似，都是引用类型。虽然闭包多次使用了self，它只捕获实例的一个强引用。
在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。
捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。
Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod()（而不只是someProperty或someMethod()）。这提醒你可能会一不小心就捕获了self。
弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。如果被捕获的引用绝对不会变为nil，应该用无主引用，而不是弱引用。
扩展可以为添加新的功能，但是不能重写已有的功能。可以添加计算型属性，不能添加存储属性。也不可以为已有属性添加属性观察器。Swift 的扩展没有名字。
如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。
如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。
实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。
mutating：表示可以在该方法中修改它所属的实例以及实例的任意属性的值。
委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。
标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类遵循，其他类以及结构体和枚举均不能遵循这种协议。
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的动画]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/animation/"/>
    <updated>2016-08-04T16:22:41+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/animation</id>
    <content type="html"><![CDATA[<p>动画是作用的UIView的CALayer上的，UIView是CALayer的代理，给CALayer提供数据参数，CALayer负责渲染和动画。UIView是在UIKit框架中，而CALayer是在QuartzCore框架中。UIView可以响应用户事件，而CALayer不可以响应用户事件。CALayer也可以像UIView一样添加子Layer。
<img src="/myimg/ios/calayer.png" alt="image" /></p>

<h4>CALayer常用属性</h4>

<pre><code>anchorPoint 和中心点position重合的一个点，称为“锚点”，锚点的描述是相对于x、y位置比例而言的默认在图像中心点(0.5,0.5)的位置
backgroundColor 图层背景颜色  
borderColor 边框颜色    
borderWidth 边框宽度    
bounds  图层大小    
contents    图层显示内容，例如可以将图片作为图层内容显示
contentsRect    图层显示内容的大小和位置    
cornerRadius    圆角半径    
doubleSided 图层背面是否显示，默认为YES 
frame   图层大小和位置，不支持隐式动画，所以CALayer中很少使用frame，通常使用bounds和position代替
hidden  是否隐藏    
mask    图层蒙版    
maskToBounds    子图层是否剪切图层边界，默认为NO 
opacity 透明度 ，类似于UIView的alpha    
position    图层中心点位置，类似于UIView的center
shadowColor 阴影颜色    
shadowOffset    阴影偏移量 
shadowOpacity   阴影透明度，注意默认为0，如果设置阴影必须设置此属性
shadowPath  阴影的形状 
shadowRadius    阴影模糊半径  
sublayers   子图层   
sublayerTransform   子图层形变 
transform   图层形变
</code></pre>

<p>要注意position和anchorPoint的区别：<strong>position是layer中的anchorPoint点在superLayer中的位置坐标！position点是相对suerLayer的，anchorPoint点是相对自身layer的！</strong> 所以说position不变，但anchorPoint改变的话，也会改变layer在superLayer中的位置！</p>

<pre><code>layer=[[CALayer alloc]init];
layer.backgroundColor=[UIColor purpleColor].CGColor;
layer.bounds=CGRectMake(0, 0, 100,100);
layer.shadowColor=[UIColor redColor].CGColor;
layer.shadowOffset=CGSizeMake(5, 5);
layer.shadowOpacity=0.7;
layer.borderColor=[UIColor yellowColor].CGColor;
layer.borderWidth=3;
layer.position=CGPointMake(size.width/2, size.height/2);
[self.view.layer addSublayer:layer];

//layer.anchorPoint=CGPointMake(0, 0); //图一
//layer.anchorPoint=CGPointMake(0, 1); //图二
</code></pre>

<p>图中position一样，但anchorPoint不一样，所以图片位置也不一样。  <br/>
<img src="/myimg/ios/layer_position.png" alt="image" />
注意如果要设置圆角，对于图层本身而言可以正常显示，但是对于图层中绘制的图片无法正确显示。如果想要图片正确显示则必须设置masksToBounds=YES，剪切子图层。但设置layer.masksToBounds=YES后，图层的影效果无法和masksToBounds=YES同时使用，因为masksToBounds的目的就是剪切外边框。如果同时要阴影又要圆角的话，就用两个重叠的图层,底部负责绘制阴影，上层负责绘制圆角。</p>

<h4>Core Animation</h4>

<p>iOS的核心动画Core Animation包含在Quartz Core框架中。核心动画分为几类：基础动画、关键帧动画、动画组、转场动画,各个类的关系大致如下：
<img src="/myimg/ios/core_animation.png" alt="image" />
*CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</p>

<p>*CAPropertyAnimation：属性动画的基类，通过属性进行动画设置，不能直接使用。</p>

<p>*CAAnimationGroup：动画组合模式，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</p>

<p>*CATransition：转场动画，主要通过滤镜进行动画效果设置。</p>

<p>*CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</p>

<p>*CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</p>

<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，只需要设置初始值和结束值，中间的过程动画由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的过渡动画由系统自动完成。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的Core Data]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/core-data/"/>
    <updated>2016-08-04T16:22:22+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/core-data</id>
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/library/watchos/documentation/Cocoa/Conceptual/CoreData/index.html">Core Data</a>是一个对sqlite数据库进行封装的ORM(Object Relation Mapping)框架。它主要由以下几部分组成：</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObject_Class/">NSManagedObject</a></h4>

<p>NSManagedObject is a generic class that implements all the basic behavior required of a Core Data model object. It is not possible to use instances of direct subclasses of NSObject (or any other class not inheriting from NSManagedObject) with a managed object context. You may create custom subclasses of NSManagedObject, although this is not always required. If no custom logic is needed, a complete object graph can be formed with NSManagedObject instances.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectModel_Class/">NSManagedObjectModel</a></h4>

<p>An NSManagedObjectModel object describes a schema, a collection of entities (data models) that you use in your application.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/">NSManagedObjectContext</a></h4>

<p>An instance of NSManagedObjectContext represents a single “object space” or scratch pad in an application. Its primary responsibility is to manage a collection of managed objects. These objects form a group of related model objects that represent an internally consistent view of one or more persistent stores. A single managed object instance exists in one and only one context, but multiple copies of an object can exist in different contexts. Thus object uniquing is scoped to a particular context.</p>

<h4><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSPersistentStoreCoordinator_Class/">NSPersistentStoreCoordinator</a></h4>

<p>Instances of NSPersistentStoreCoordinator associate persistent stores (by type) with a model (or more accurately, a configuration of a model) and serve to mediate between the persistent store or stores and the managed object context or contexts. Instances of NSManagedObjectContext use a coordinator to save object graphs to persistent storage and to retrieve model information. A context without a coordinator is not fully functional as it cannot access a model except through a coordinator. The coordinator is designed to present a façade to the managed object contexts such that a group of persistent stores appears as an aggregate store. A managed object context can then create an object graph based on the union of all the data stores the coordinator covers.</p>

<h4><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSFetchRequest_Class/index.html#//apple_ref/occ/cl/NSFetchRequest">NSFetchRequest</a></h4>

<p>An instance of NSFetchRequest describes search criteria used to retrieve data from a persistent store.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSPredicate_Class/">NSPredicate</a></h4>

<p>The NSPredicate class is used to define logical conditions used to constrain a search either for a fetch or for in-memory filtering.</p>

<p><img src="/myimg/ios/cd_orm.png" alt="image" />
<img src="/myimg/ios/cd_table.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的block]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/block/"/>
    <updated>2016-08-04T16:21:41+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/block</id>
    <content type="html"><![CDATA[<p>block就是一个代码块，闭包，会捕获上下文的匿名函数，它可以作为参数或者返回值进行传递。在objc中，根据对象的定义，凡是首地址是*isa的结构体指针，都可以认为是对象(id)，所以block实际上就算是对象，但它的内存管理又和NSObject有点不一样。</p>

<h4>声明:</h4>

<pre><code>*变量：returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};

*属性：@property (nonatomic, copy) returnType (^blockName)(parameterTypes);

*方法：-(void)someMethod:(returnType (^nullability)(parameterTypes))blockName;

*回调：[object  method:^returnType (parameters) {...}];

*定义：typedef returnType (^TypeName)(parameterTypes); --&gt; TypeName blockName = ^returnType(parameters) {...};
</code></pre>

<p>block中的isa指向的是该block的Class,主要有三种类型：</p>

<pre><code>_NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量。
_NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。
_NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。
</code></pre>

<p>当block第一次被创建时，它是存在于该函数的栈上的，其Class是固定的NSConcreteStackBlock。其捕获的变量是会赋值到结构体的成员上，所以当block初始化完成后，捕获到的变量不能更改。当函数返回时，函数的栈被销毁，这个block的内存也会被清除。所以在函数结束后仍然需要这个block时，就必须用Block_copy()方法将它拷贝到堆上，类型变为NSConcreteMallocBlock，向它发送retain，增加block的引用计数。</p>

<p>默认block捕获到的局部变量，都是赋值给block的结构体的，相当于const不可改。为了让block能访问并修改外面的局部变量，需要加上__block修饰词。</p>

<pre><code>void test(){
 __block int i = 3;
  void(^myBlock)(void) = ^{
     i = 5;//局部变量没有__block修饰的话不可修改
  };
 myBlock();
}
</code></pre>

<h4>捕获规则：</h4>

<pre><code>1.静态存储区的变量,例如全局变量、方法中的static变量:
  引用，可修改。

2.block接受的参数传值:
  可修改，和一般函数的参数相同。

3.栈变量(局部变量):
  常量，不可修改，block会对id类型的变量产生强引用。

4.栈变量(有__block前缀的局部变量):
  引用，可以修改。如果是id类型则不会被block retain、如果该类型是C类型变量，该值会被挪动到堆中。
</code></pre>

<p>在ARC中，block被赋值传递的时候会自动拷贝到堆上，堆上的对象就有可能被释放掉，所以要用copy强引用着,以免野指针crash。</p>

<h4>循环引用:</h4>

<p>当block被copy到堆之后，该block对它捕获的对象产生强引用，所以有时需要避免block copy后产生的循环引用。</p>

<p>如self引用了block，block又捕获了self，这样就会有循环引用,因此，需要用weak来声明self。</p>

<pre><code>- (void)test {
    ViewController * __weak weakSelf = self;
    self.block = ^{
        [weakSelf doSomething]; //用弱引用,打破循环引用
    }
}
</code></pre>

<p>如果捕获到的是对象的成员变量对象，也会间接造成对self的循环引用，同样也要避免。</p>

<pre><code>- (void)test {
    id tempPropertyObj = _propertyObj; //用临时变量,避免了循环引用
    self.block = ^{
        [tempPropertyObj doSomething];
    }
}
</code></pre>

<h4>问题</h4>

<pre><code>[UIView animateWithDuration:0.5 animations:^{
        [self doSomething];
    }];
</code></pre>

<p>上面例子并不会造成循环引用，因为block强引用了self,而self并没有强引用block。如果像下面就会循环引用：self &ndash;> _observer &ndash;> block &ndash;> self 这也是一个循环引用。</p>

<pre><code>//_observer 是self的实例变量
    _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"test"
                                                                  object:nil
                                                                   queue:[NSOperationQueue mainQueue]
                                                              usingBlock:^(NSNotification * _Nonnull note) {
                                                                  [self doSomething];
                                                              }];
</code></pre>
]]></content>
  </entry>
  
</feed>
