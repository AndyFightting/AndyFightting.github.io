<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-12-02T20:12:27+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS Not Found for Architecture Arm64]]></title>
    <link href="http://andyfightting.github.io/blog/2016/09/12/link-bug/"/>
    <updated>2016-09-12T10:00:18+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/09/12/link-bug</id>
    <content type="html"><![CDATA[<p>接手维护一个项目，更新一下出现了下面这问题👇
<img src="/myimg/ios/arm64.png" alt="image" /></p>

<p>好像不常见的问题，谷歌一下</p>

<p><a href="http://stackoverflow.com/questions/19213782/undefined-symbols-for-architecture-arm64">Stack Overflow</a>
<img src="/myimg/ios/stackoverflow.png" alt="image" /></p>

<p>说是Architectures设置问题&hellip; 说是Other Linker Flags问题&hellip;说是Target Membership问题&hellip; 改了好像都没用啊，问题还是一动不动的出现在那里&hellip;
<img src="/myimg/ios/targetMap.png" alt="image" /></p>

<p>继续找找找&hellip;用对应的类文件全局搜一下&hellip;诶~ 好像那里不对啊&hellip;路径怎么这样子??怎么和别的不一样~~ 喜出望外，好像知道原因了，果然项目文件夹里看不到该文件，Add Files to &ldquo;XXX"添加文件!
<img src="/myimg/ios/errorLoad.png" alt="image" /></p>

<p>还是不行&hellip;把对应的.h .m文件拖到桌面上，再重新添加到项目里，解决了！！为什么一开始不怀疑是文件索引问题呢？ 因为项目编译没报 XXX.h not found &hellip;以为文件都好好的呢，以为是项目的配置问题&hellip; 所以一开始找问题的方向就跑偏了！其实这问题之前也遇到过，一般是第三方的XXX.a文件出现这问题，只是这次脑袋没长记性&hellip;这问题一般是多人开发项目用SVN更来更去导致的<code>project.pbxproj</code>里对应的文件索引没了。好了，再遇到这问题就不要跑偏了，把对应的文件重新添加就可以了！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift阅读笔记]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/swift-read/"/>
    <updated>2016-08-04T16:23:05+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/swift-read</id>
    <content type="html"><![CDATA[<pre><code>let 声明常量，var 声明变量，会自动进行类型推断(小数推断为Double),一行末尾可不加分号(;)。
值永远不会被隐式转换为其他类型，务必显示强制转换。
if语句的条件不能默认非0为真。 类型后加?号表示可选值，要么有值，要么是nil。
用 if let(或者var) name = optionName 来获取可选值处理。 
switch的case中自带break，switch要保证全部遍历，否则必须要有default选项。
0&lt; x &lt;4 等价 0..&lt;4 , 0&lt; x &lt;=4 等价 0...4 。 
用 func 声明函数，用-&gt;指定返回类型func greet(name: String, day: String) -&gt; String { ... }。 
元组概念，一般用做函数返回值。 
func sumOf(numbers: Int...) -&gt; Int {}，...表示可变个数的参数。 
函数是一等类型，像int float一样，可用作参数或者返回值。 
class 声明类,属性都要赋值，要么在声明直接写死，要么在init方法中赋值。 
重写父类方法必须用 override 标记。 属性可以有get set willGet didSet 等方法。 
mutating关键字用来标记一个会修改结构体(属性)的方法。 
extension来为现有的类型添加功能，比如新的方法和计算属性。
泛型(指定类型)就是java中的泛型。 Bool值是true或false。 
typealies name = 类型 给类型起个别名。 
OC中的nil只用在对象上(int不行)，Swift中nil可指任何东西(对象或int)。
使用!来获取一个不存在的可选值会导致错误。隐式解析可选类型(类型!)就是可选类型，但是可以当做非可选类型来使用(不用!解析,没值时会报错)。 
throws do try catch 的使用。Swift的赋值操作不返回任何值。% 浮点数也可以取余运算。 
空合运算符(a ?? b)对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b(b和a要类型相同)。逻辑 &amp;&amp;，|| 都是短路计算的。
条件中的下划线 _ 来忽略对值的访问，case 中的下划线 _ 表示所有可能的值,case中可进行值绑定，case条件可用where语句。 
字典的遍历顺序和插入顺序可能不同(字典无序的)。 
Swift语言的repeat-while循环合其他语言中的do-while循环是类似的。
注意循环中switch中的continue(开始下次)和break(跳到switch}后面继续执行)的差别，switch中的fallthrouth进入下一个case时不会再进行条件判断。
guard(守卫)语句总是有一个else分句。 
调用函数时第一个参数名不要，之后的参数名要，用逗号分开(第一个参数省略其外部参数名，第二个以后的参数使用其本地参数名作为自己的外部参数名。
所有参数需要有不同的本地参数名，但可以共享相同的外部参数名。如果你提供了外部参数名，那么函数在被调用时，必须使用外部参数名。如果你不想为第二个及后续的参数设置参数名，用下划线_代替)。
一个函数最多只能有一个可变参数(...),如果函数同时有默认参数和可变参数要把可变参数放最后。 
函数参数默认是常量，修改会报错，但可以用var声明为变量,修改只在函数体内有效。 
inout参数(只能传入变量)会替换原来的值，使用时在变量名前加&amp;符号。 
原数组不会被sort()方法修改。 闭包就是用{}包起来的函数代码块，用in分开返回值和处理代码，参数不能有默认值。如果需要将闭包作为最后一个参数，可变成尾随闭包。
Array的map方法可返回不同类型。 函数和闭包都是引用类型。
结构体和枚举是值类型，所有的基本类型都是值类型，并且都是以结构体的形式在后台所实现。
类是引用类型。常量实例依然可改变其中的变量属性值。
swift指针并不直接指向内存中的某个地址，而且也不要求你使用星号（*）来表明你在创建一个引用。
结构体实例总是通过值传递，类实例总是通过引用传递。
Swift 中字符串（String）,数组（Array）和字典（Dictionary）均以结构体的形式实现的值类型,而在OC中是以类的形式实现的引用类型。
计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。
如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使定义了变量存储属性，由于结构体（struct）属于值类型，当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。
必须将延迟存储属性声明成变量（使用var关键字），因为属性的初始值可能在实例构造完成之后才会得到。
而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。
计算属性不直接存储值，而是提供一个 get和一个可选的set，来间接获取和设置其他属性或变量的值。
必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。
父类的属性在子类的构造器中被赋值时，它在父类中的willSet和didSet观察器会被调用。
全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy特性。局部范围的常量或变量不会延迟计算。
必须给存储类型的类属性指定默认值，因为类型本身无法在初始化过程中使用构造器给类型属性赋值。
结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的动画]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/animation/"/>
    <updated>2016-08-04T16:22:41+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/animation</id>
    <content type="html"><![CDATA[<p>动画是作用的UIView的CALayer上的，UIView是CALayer的代理，给CALayer提供数据参数，CALayer负责渲染和动画。UIView是在UIKit框架中，而CALayer是在QuartzCore框架中。UIView可以响应用户事件，而CALayer不可以响应用户事件。CALayer也可以像UIView一样添加子Layer。
<img src="/myimg/ios/calayer.png" alt="image" /></p>

<h4>CALayer常用属性</h4>

<pre><code>anchorPoint 和中心点position重合的一个点，称为“锚点”，锚点的描述是相对于x、y位置比例而言的默认在图像中心点(0.5,0.5)的位置
backgroundColor 图层背景颜色  
borderColor 边框颜色    
borderWidth 边框宽度    
bounds  图层大小    
contents    图层显示内容，例如可以将图片作为图层内容显示
contentsRect    图层显示内容的大小和位置    
cornerRadius    圆角半径    
doubleSided 图层背面是否显示，默认为YES 
frame   图层大小和位置，不支持隐式动画，所以CALayer中很少使用frame，通常使用bounds和position代替
hidden  是否隐藏    
mask    图层蒙版    
maskToBounds    子图层是否剪切图层边界，默认为NO 
opacity 透明度 ，类似于UIView的alpha    
position    图层中心点位置，类似于UIView的center
shadowColor 阴影颜色    
shadowOffset    阴影偏移量 
shadowOpacity   阴影透明度，注意默认为0，如果设置阴影必须设置此属性
shadowPath  阴影的形状 
shadowRadius    阴影模糊半径  
sublayers   子图层   
sublayerTransform   子图层形变 
transform   图层形变
</code></pre>

<p>要注意position和anchorPoint的区别：<strong>position是layer中的anchorPoint点在superLayer中的位置坐标！position点是相对suerLayer的，anchorPoint点是相对自身layer的！</strong> 所以说position不变，但anchorPoint改变的话，也会改变layer在superLayer中的位置！</p>

<pre><code>layer=[[CALayer alloc]init];
layer.backgroundColor=[UIColor purpleColor].CGColor;
layer.bounds=CGRectMake(0, 0, 100,100);
layer.shadowColor=[UIColor redColor].CGColor;
layer.shadowOffset=CGSizeMake(5, 5);
layer.shadowOpacity=0.7;
layer.borderColor=[UIColor yellowColor].CGColor;
layer.borderWidth=3;
layer.position=CGPointMake(size.width/2, size.height/2);
[self.view.layer addSublayer:layer];

//layer.anchorPoint=CGPointMake(0, 0); //图一
//layer.anchorPoint=CGPointMake(0, 1); //图二
</code></pre>

<p>图中position一样，但anchorPoint不一样，所以图片位置也不一样。  <br/>
<img src="/myimg/ios/layer_position.png" alt="image" />
注意如果要设置圆角，对于图层本身而言可以正常显示，但是对于图层中绘制的图片无法正确显示。如果想要图片正确显示则必须设置masksToBounds=YES，剪切子图层。但设置layer.masksToBounds=YES后，图层的影效果无法和masksToBounds=YES同时使用，因为masksToBounds的目的就是剪切外边框。如果同时要阴影又要圆角的话，就用两个重叠的图层,底部负责绘制阴影，上层负责绘制圆角。</p>

<h4>Core Animation</h4>

<p>iOS的核心动画Core Animation包含在Quartz Core框架中。核心动画分为几类：基础动画、关键帧动画、动画组、转场动画,各个类的关系大致如下：
<img src="/myimg/ios/core_animation.png" alt="image" />
*CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</p>

<p>*CAPropertyAnimation：属性动画的基类，通过属性进行动画设置，不能直接使用。</p>

<p>*CAAnimationGroup：动画组合模式，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</p>

<p>*CATransition：转场动画，主要通过滤镜进行动画效果设置。</p>

<p>*CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</p>

<p>*CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</p>

<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，只需要设置初始值和结束值，中间的过程动画由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的过渡动画由系统自动完成。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的Core Data]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/core-data/"/>
    <updated>2016-08-04T16:22:22+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/core-data</id>
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/library/watchos/documentation/Cocoa/Conceptual/CoreData/index.html">Core Data</a>是一个对sqlite数据库进行封装的ORM(Object Relation Mapping)框架。它主要由以下几部分组成：</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObject_Class/">NSManagedObject</a></h4>

<p>NSManagedObject is a generic class that implements all the basic behavior required of a Core Data model object. It is not possible to use instances of direct subclasses of NSObject (or any other class not inheriting from NSManagedObject) with a managed object context. You may create custom subclasses of NSManagedObject, although this is not always required. If no custom logic is needed, a complete object graph can be formed with NSManagedObject instances.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectModel_Class/">NSManagedObjectModel</a></h4>

<p>An NSManagedObjectModel object describes a schema, a collection of entities (data models) that you use in your application.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/">NSManagedObjectContext</a></h4>

<p>An instance of NSManagedObjectContext represents a single “object space” or scratch pad in an application. Its primary responsibility is to manage a collection of managed objects. These objects form a group of related model objects that represent an internally consistent view of one or more persistent stores. A single managed object instance exists in one and only one context, but multiple copies of an object can exist in different contexts. Thus object uniquing is scoped to a particular context.</p>

<h4><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSPersistentStoreCoordinator_Class/">NSPersistentStoreCoordinator</a></h4>

<p>Instances of NSPersistentStoreCoordinator associate persistent stores (by type) with a model (or more accurately, a configuration of a model) and serve to mediate between the persistent store or stores and the managed object context or contexts. Instances of NSManagedObjectContext use a coordinator to save object graphs to persistent storage and to retrieve model information. A context without a coordinator is not fully functional as it cannot access a model except through a coordinator. The coordinator is designed to present a façade to the managed object contexts such that a group of persistent stores appears as an aggregate store. A managed object context can then create an object graph based on the union of all the data stores the coordinator covers.</p>

<h4><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSFetchRequest_Class/index.html#//apple_ref/occ/cl/NSFetchRequest">NSFetchRequest</a></h4>

<p>An instance of NSFetchRequest describes search criteria used to retrieve data from a persistent store.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSPredicate_Class/">NSPredicate</a></h4>

<p>The NSPredicate class is used to define logical conditions used to constrain a search either for a fetch or for in-memory filtering.</p>

<p><img src="/myimg/ios/cd_orm.png" alt="image" />
<img src="/myimg/ios/cd_table.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的NSURLSession]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/session/"/>
    <updated>2016-08-04T16:22:02+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/session</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
