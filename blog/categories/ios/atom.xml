<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 阿贵]]></title>
  <link href="http://andyfightting.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-08-04T15:52:49+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS中的Runloop与Runtime]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/01/runtime/"/>
    <updated>2016-08-01T10:20:14+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/01/runtime</id>
    <content type="html"><![CDATA[<h3><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">Runloop</a></h3>

<p>Runloop与线程息息相关，它是线程的基础架构部分，每个线程都有自己的runloop对象，可以用[NSRunLoop currentRunLoop]来得到它。主线程中的runloop是启动运行状态，而自己创建的线程中的runloop默认是没有启动的，需要的话要手动去启动。Runloop是一个事件处理循环，用来不停的监听输入事件或者定时事件，并将其分配到对应的目标上进行处理。它可以使线程在有工作的时候工作，没有工作的时候休眠。</p>

<p>Runloop同时也负责autorelease pool的创建和释放，每当一个运行循环结束的时候，它都会释放autorelease pool，同时pool中的所有自动释放类型变量都会被释放掉。NSRunloop不是线程安全的，而CFRunLoopRef是线程安全的。RunLoop要指定在特定Mode下Run：</p>

<p>*NSDefaultRunLoopMode：处理大多数的操作，一般情况下用这个。</p>

<p>*NSRunLoopCommonModes：For Cocoa applications, this set includes the default, modal, and event tracking modes by default. Core Foundation includes just the default mode initially.</p>

<p>而且通过scheduleInRunLoop的方式启动的请求，虽然是在主线程中执行！但也会有异步的效果！SDWebImageDownloader 中的 NSURLConnection 就是这样启动请求的！！</p>

<pre><code>- (void)start{
    NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:15];
    self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];
    [connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
    [connection start];
    if (connection){
        self.imageData = [NSMutableData data];
    }else{
        if ([delegate respondsToSelector:@selector(imageDownloader:didFailWithError:)]){
            [delegate performSelector:@selector(imageDownloader:didFailWithError:) withObject:self withObject:nil];
        }
    }
}
</code></pre>

<p>NSURLConnection在代理方法中打印出的线程：
<img src="/myimg/ios/sdrunloop.png" alt="iamge" /></p>

<p>runloop监听用户输入事件和定时事件
<img src="/myimg/ios/runloop.png" alt="image" /><!--more--></p>

<h3><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Runtime</a></h3>

<p>Runtime是个很重要的概念，iOS之所以是动态语言就是因为它。它的核心是一个用C和编译语言写的Runtime库。它是Objective-C面向对象和动态机制的基石。静态语言是在编译的时候就已经绑定好了某个方法名会执行哪段函数地址。而动态语言不是在编译的时候就已经绑定好了，它是在具体要执行的某个方法的时候，才根据方法名去寻找具体执行的方法地址，所以可以在这时候动态的改变它的绑定。可以在<a href="https://opensource.apple.com/tarballs/objc4/">这里</a>下载源码查看。</p>

<p>&ldquo;计算机界，只要再加一层中间层，就没有解决不了的问题。如果有，那再加一层，直到它解决。"这句话不知道是在哪里看到的了&hellip;不过说的挺有道理的。而Runtime库正是Objective-C之所以为动态语言的中间层！</p>

<p>在Objective-C中，类、对象和方法都是一个C的结构体，从objc/objc.h头文件中，我们可以找到他们的定义：</p>

<pre><code>//---NSObject-----
@interface NSObject &lt;NSObject&gt; {
     Class isa 
}

//---Class-----
typedef struct objc_class *Class;

//---objc_class-----
struct objc_class {
    Class isa 
    Class super_class                                        
    const char *name                                         
    long version                                             
    long info                                                
    long instance_size //对象大小                                      
    struct objc_ivar_list *ivars //属性列表                             
    struct objc_method_list **methodLists //方法列表                   
    struct objc_cache *cache  //方法映射缓存                               
    struct objc_protocol_list *protocols   //代理列表                   
};

//---objc_method----
struct objc_method {  
    SEL method_name //方法名
    char *method_types //a string representing argument/return types
    IMP method_imp  //方法地址
};
</code></pre>

<p>Objective-C的函数调用在编译的时候会被翻译为 -objc_msgSend(执行的对象，方法名，参数&hellip;),先通过isa指针找到它的Class,然后在method list里找方法，没有的话就上superClass中找，一旦找到，就去执行，然后把方法名和对应的方法地址映射保存在objc_cache中，下次就直接从这缓存中取。如果都没找到，会在程序报unrecognized selector sent to&hellip;错误之前还有机会补救，就是动态的给它指定一个执行方法！</p>

<p>首先，Objective-C运行时会调用+resolveInstanceMethod:或者+resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回YES，那运行时系统就会重新启动一次消息发送的过程。下面用当我调用test方法的时候，没有test的实现方法，但把它动态绑定给了newTest方法去执行！</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    [self performSelector:@selector(test) withObject:nil afterDelay:0];
}

void newTest(){
    NSLog(@"success !!");
}

+ (BOOL)resolveInstanceMethod:(SEL)aSEL{
    if(aSEL == @selector(test)){
        class_addMethod([self class], aSEL, (IMP)newTest, nil);
        return YES;
    }
    return [super resolveInstanceMethod:aSEL];
}
</code></pre>

<p>如果resolveInstanceMethod：方法返回NO话，就会转到-forwardingTargetForSelector:方法中去执行,让这个方法在其他对象中去执行！如下面把test方法传递给 viewController2 对象去执行，在 viewController2 对象中实现的 test 方法就会被调用！！</p>

<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)aSEL{
    return NO;
}

- (id)forwardingTargetForSelector:(SEL)aSelector{
    if(aSelector == @selector(test)){
        return viewController2;//传递给viewController2对象去执行 test方法
    }
    return [super forwardingTargetForSelector:aSelector];
}
</code></pre>

<p>如果forwardingTargetForSelector：方法返回nil或者self的时候，就会进入- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector:方法中去执行，如果这方法返回了一个NSMethodSignature对象，这会进入-forwardInvocation:方法中，把消息传给对应的对象去执行！如下将会在viewController2中执行test方法！！</p>

<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)aSEL{
    return NO;
}

- (id)forwardingTargetForSelector:(SEL)aSelector{
    return self;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    NSMethodSignature* signature = [super methodSignatureForSelector:aSelector];
    if (signature==nil) {
        signature = [viewController2 methodSignatureForSelector:aSelector];
    }
    return signature;
}

- (void)forwardInvocation:(NSInvocation *)invocation{
    SEL sel = invocation.selector;
    if([viewController2 respondsToSelector:sel]) {
        [invocation invokeWithTarget:viewController2];
    }else {
        [self doesNotRecognizeSelector:sel];
    }
}
</code></pre>

<p>如果这三个过程下来都没绑定具体的执行方法，则会进入- (void)doesNotRecognizeSelector:(SEL)aSelector方法，然后程序奔溃!!</p>

<p>Method Swizzling,下面的例子中，当调用test1方法的时候，具体执行是跑到test2方法中的！！</p>

<pre><code>@implementation ViewController
+ (void)load {
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    Class class = [self class];

    SEL originalSelector = @selector(test1);
    SEL swizzledSelector = @selector(test2);

    Method originalMethod = class_getInstanceMethod(class, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);

    BOOL didAddMethod =
    class_addMethod(class,
                    originalSelector,
                    method_getImplementation(swizzledMethod),
                    method_getTypeEncoding(swizzledMethod));

    if (didAddMethod) {
        class_replaceMethod(class,
                            swizzledSelector,
                            method_getImplementation(originalMethod),
                            method_getTypeEncoding(originalMethod));
    } else {
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
});
}

- (void)viewDidLoad {
    [super viewDidLoad];
    [self test1];
}
-(void)test1{
    NSLog(@"开始1");
}
-(void)test2{
    NSLog(@"开始2");
}
</code></pre>

<p>Swizzling应该总是在+load中执行,在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。</p>

<p>这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>

<p>Swizzling应该总是在dispatch_once中执行, 因为swizzling会改变全局状态，所以我们需要它确保代码只被执行一次，不管有多少个线程，而GCD的dispatch_once可以确保这种行为。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的CoreText]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/26/core-text/"/>
    <updated>2015-12-26T15:16:23+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/26/core-text</id>
    <content type="html"><![CDATA[<p>CoreText进行图文混排的核心思想是把需要摆放图片的位置用空字符替换原来的字符，并且实现CTRunDelegate，用于动态设置空字符的高度和宽度（代表图片的大小），并且对这些空字符设置一个属性名来区别于其他CTRun，之后进行图片渲染的时候就能通过该属性来区分哪些空字符是代表图片的占位符，哪些是普通的空字符。使用CoreText处理点击事件的关键是判断点击的位置是本文内容中的第几个字符，然后通过判断该字符是否在需要处理点击事件的字符串范围内。</p>

<p><img src="/myimg/ios/text2.png" alt="image" /><!--more-->
<img src="/myimg/ios/coreText.png" alt="image" /></p>

<pre><code>
#import "CoreTextView.h"
#import &lt;CoreText/CoreText.h&gt;

@implementation CoreTextView{
    CTFrameRef ctFrame;
}

- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        // Initialization code
    }
    return self;
}

- (void)drawRect:(CGRect)rect
{
    //得到当前用于绘制画布的上下文，用于后续将内容绘制在画布上
    CGContextRef context = UIGraphicsGetCurrentContext();

    //翻转当前的坐标系, 因为对于底层绘制引擎来说，屏幕左下角为（0，0)
    CGContextSetTextMatrix(context, CGAffineTransformIdentity);
    CGContextTranslateCTM(context, 0, self.bounds.size.height);
    CGContextScaleCTM(context, 1.0, -1.0);

    //要绘制的文字
    NSMutableAttributedString* attributedString = [[NSMutableAttributedString alloc] initWithString:@"少年不识愁滋味，爱上层楼。爱上层楼。为赋新词强说愁。而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。"];
    //为所有文本设置字体
    [attributedString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:10] range:NSMakeRange(0, [attributedString length])];
    //设置某些字体更大
    [attributedString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(10, 10)];
    //index 从0开始的2个字符 字体颜色 设置为蓝色
    [attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(0, 2)];
    //index 从2开始的3个字符 字体颜色 设置为红色
    [attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(2, 3)];
    //设置行间距 50
    CGFloat lineSpacing = 50;
    CTParagraphStyleSetting theSettings[3] = {
        {kCTParagraphStyleSpecifierLineSpacingAdjustment, sizeof(CGFloat), &amp;lineSpacing},
        {kCTParagraphStyleSpecifierMaximumLineSpacing, sizeof(CGFloat), &amp;lineSpacing},
        {kCTParagraphStyleSpecifierMinimumLineSpacing, sizeof(CGFloat), &amp;lineSpacing}
    };
    CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, 3);
    [attributedString addAttribute:(id)kCTParagraphStyleAttributeName value:(__bridge id)theParagraphRef range:NSMakeRange(0, attributedString.length)];
    CFRelease(theParagraphRef);

    //要插入的图片
    NSString *imageName = @"testImage.png";

    //为图片设置CTRunDelegate 计算留给图片的空间大小
    CTRunDelegateCallbacks imageCallbacks;
    imageCallbacks.version = kCTRunDelegateVersion1;
    imageCallbacks.getAscent = GetAscentCallback;
    imageCallbacks.getDescent = GetDescentCallback;
    imageCallbacks.getWidth = GetWidthCallback;

    //设置图片位置，大小
    CTRunDelegateRef runDelegate = CTRunDelegateCreate(&amp;imageCallbacks, imageName);
    NSMutableAttributedString *imageAttributedString = [[NSMutableAttributedString alloc] initWithString:@" "];//空格用于给图片留位置
    [imageAttributedString addAttribute:(NSString *)kCTRunDelegateAttributeName value:(id)runDelegate range:NSMakeRange(0, 1)];//用代理设置图片
    CFRelease(runDelegate);

    //把图片插入到字符串中
    [imageAttributedString addAttribute:@"imageAttribute" value:imageName range:NSMakeRange(0, 1)];
    [attributedString insertAttributedString:imageAttributedString atIndex:1];//图片插入位置，不能越界
    [attributedString insertAttributedString:imageAttributedString atIndex:3];//图片插入位置，不能越界
    [attributedString insertAttributedString:imageAttributedString atIndex:5];//图片插入位置，不能越界

    //根据attributedString生成CTFramesetterRef
    CTFramesetterRef ctFramesetter = CTFramesetterCreateWithAttributedString((CFMutableAttributedStringRef)attributedString);
    CGMutablePathRef path = CGPathCreateMutable();
    CGRect bounds = CGRectMake(0.0, 0.0, self.bounds.size.width, self.bounds.size.height);
    CGPathAddRect(path, NULL, bounds);

    //绘制文字
    ctFrame = CTFramesetterCreateFrame(ctFramesetter,CFRangeMake(0, [attributedString length ]), path, NULL);
    CTFrameDraw(ctFrame, context);

    //下面都是为了绘制图片
    CFArrayRef lines = CTFrameGetLines(ctFrame);
    CGPoint lineOrigins[CFArrayGetCount(lines)];
    CTFrameGetLineOrigins(ctFrame, CFRangeMake(0, 0), lineOrigins);

    //遍历每个CTLine
    for (int i = 0; i &lt; CFArrayGetCount(lines); i++) {
        CTLineRef line = CFArrayGetValueAtIndex(lines, i);
        CGFloat lineAscent;
        CGFloat lineDescent;
        CGFloat lineLeading;
        CTLineGetTypographicBounds(line, &amp;lineAscent, &amp;lineDescent, &amp;lineLeading);

        CFArrayRef runs = CTLineGetGlyphRuns(line);
        for (int j = 0; j &lt; CFArrayGetCount(runs); j++) {
            CGFloat runAscent;
            CGFloat runDescent;
            CGPoint lineOrigin = lineOrigins[i];
            CTRunRef run = CFArrayGetValueAtIndex(runs, j);
            NSDictionary* attributes = (NSDictionary*)CTRunGetAttributes(run);

            CGRect runRect;
            runRect.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0,0), &amp;runAscent, &amp;runDescent, NULL);
            runRect=CGRectMake(lineOrigin.x + CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL), lineOrigin.y - runDescent, runRect.size.width, runAscent + runDescent);

            NSString *isImage = [attributes objectForKey:@"imageAttribute"];
            //图片渲染逻辑
            if (isImage) {
                UIImage *image = [UIImage imageNamed:imageName];
                if (image) {
                    CGRect imageDrawRect;
                    imageDrawRect.size = image.size;
                    imageDrawRect.origin.x = runRect.origin.x + lineOrigin.x;
                    imageDrawRect.origin.y = lineOrigin.y;
                    CGContextDrawImage(context, imageDrawRect, image.CGImage);
                }
            }
        }
    }
    //释放资源
    //    CFRelease(ctFrame); //因为点击要用ctFrame，所以放dealloc里释放
    CFRelease(path);
    CFRelease(ctFramesetter);
}

//接受触摸事件
-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    UITouch *touch = [touches anyObject];
    CGPoint location = [touch locationInView:self];

    //获取每一行
    CFArrayRef lines = CTFrameGetLines(ctFrame);
    CGPoint origins[CFArrayGetCount(lines)];
    //获取每行的原点坐标
    CTFrameGetLineOrigins(ctFrame, CFRangeMake(0, 0), origins);
    CTLineRef line = NULL;
    CGPoint lineOrigin = CGPointZero;
    for (int i= 0; i &lt; CFArrayGetCount(lines); i++){
        CGPoint origin = origins[i];
        CGPathRef path = CTFrameGetPath(ctFrame);
        //获取整个CTFrame的大小
        CGRect rect = CGPathGetBoundingBox(path);
        //坐标转换，把每行的原点坐标转换为uiview的坐标体系
        CGFloat y = rect.origin.y + rect.size.height - origin.y;
        //判断点击的位置处于那一行范围内
        if ((location.y &lt;= y) &amp;&amp; (location.x &gt;= origin.x)){
            line = CFArrayGetValueAtIndex(lines, i);
            lineOrigin = origin;
            break;
        }
    }

    location.x -= lineOrigin.x;
    //获取点击位置所处的字符位置，就是相当于点击了第几个字符
    CFIndex index = CTLineGetStringIndexForPosition(line, location)-1;//index从0开始
    UIAlertView* alert = [[UIAlertView alloc]initWithTitle:@"提示" message:[NSString stringWithFormat:@"点击了第 %d 个字符！！",(int)index] delegate:self cancelButtonTitle:@"ok" otherButtonTitles:nil, nil];
    [alert show];
}

-(void)dealloc{
    [super dealloc];
    CFRelease(ctFrame);
}

#pragma mark CTRunDelegate Callbacks
CGFloat GetAscentCallback( void *refCon ){
    NSString *imageName = (NSString *)refCon;
    return [UIImage imageNamed:imageName].size.height;
}
CGFloat GetDescentCallback(void *refCon){
    return 0;
}
CGFloat GetWidthCallback(void *refCon){
    NSString *imageName = (NSString *)refCon;
    return [UIImage imageNamed:imageName].size.width;
}
@end
</code></pre>

<p>运行结果
<img src="/myimg/ios/coreResult.png" alt="image" /></p>

<h3>*TextKit</h3>

<p>由于用CoreText是用绘图方式实现图文混排，复杂难用。所以在iOS7新推出了新的文字排版技术 &ndash; TextKit。使用TextKit可以很方便的实现富文本、表情混排和图文混排等效果。它是UIKit framework中定义的一组用于提供高性能的排版、布局和展示文字的类和协议，比如展示特别的字间距、行间距、断行规则。从上面图2可知，它是基于CoreText的，且UILabel,UITextField,UITextView又都是基于TextKit的。</p>

<pre><code>UILabel* label = [[UILabel alloc]initWithFrame:self.view.bounds];
label.text = @"少年不识愁滋味，爱上层楼。爱上层楼。为赋新词强说愁。而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。";
label.numberOfLines = 0;
label.userInteractionEnabled = YES;
[self.view addSubview:label];

NSMutableAttributedString * attributeString = [label.attributedText mutableCopy];
[attributeString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, 10)];//设置颜色
[attributeString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:25] range:NSMakeRange(0, 5)];//设置字体
[attributeString addAttribute:NSUnderlineStyleAttributeName value:@(NSUnderlineStyleSingle) range:NSMakeRange(0, 15)];//设置下划线
[attributeString addAttribute:NSStrokeWidthAttributeName value:@(2) range:NSMakeRange(0, 3)];//设置空心字

//插入图片1
UIImage * image1 = [UIImage imageNamed:@"fengye.png"];
NSTextAttachment * attachment1 = [[NSTextAttachment alloc] init];
attachment1.bounds = CGRectMake(0, 0, 60, 60);
attachment1.image = image1;
NSAttributedString * attachStr1 = [NSAttributedString attributedStringWithAttachment:attachment1];
[attributeString insertAttributedString:attachStr1 atIndex:1];

//插入图片2
UIImage * image2 = [UIImage imageNamed:@"fengye.png"];
NSTextAttachment * attachment2 = [[NSTextAttachment alloc] init];
attachment2.bounds = CGRectMake(0, 0, 30, 30);
attachment2.image = image2;
NSAttributedString * attachStr2 = [NSAttributedString attributedStringWithAttachment:attachment2];
[attributeString insertAttributedString:attachStr2 atIndex:5];

label.attributedText = [attributeString copy];

//    TextView 通过如下可以设置环绕图片的文字
//    UIBezierPath * path = [UIBezierPath bezierPathWithRect:rect];
//    textView.textContainer.exclusionPaths = @[path];
</code></pre>

<p><img src="/myimg/ios/textkit1.png" alt="image" /></p>

<pre><code> NSAttributedString属性key的说明
 NSFontAttributeName                设置字体属性，默认值：字体：Helvetica(Neue) 字号：12
 NSForegroundColorAttributeName     设置字体颜色，取值为 UIColor对象，默认值为黑色
 NSBackgroundColorAttributeName     设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色
 NSLigatureAttributeName            设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符
 NSKernAttributeName                设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄
 NSStrikethroughStyleAttributeName  设置删除线，取值为 NSNumber 对象（整数）
 NSStrikethroughColorAttributeName  设置删除线颜色，取值为 UIColor 对象，默认值为黑色
 NSUnderlineStyleAttributeName      设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似
 NSUnderlineColorAttributeName      设置下划线颜色，取值为 UIColor 对象，默认值为黑色
 NSStrokeWidthAttributeName         设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果
 NSStrokeColorAttributeName         填充部分颜色，不是字体颜色，取值为 UIColor 对象
 NSShadowAttributeName              设置阴影属性，取值为 NSShadow 对象
 NSTextEffectAttributeName          设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：
 NSBaselineOffsetAttributeName      设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏
 NSObliquenessAttributeName         设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾
 NSExpansionAttributeName           设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本
 NSWritingDirectionAttributeName    设置文字书写方向，从左向右书写或者从右向左书写
 NSVerticalGlyphFormAttributeName   设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本
 NSLinkAttributeName                设置链接属性，点击后调用浏览器打开指定URL地址
 NSAttachmentAttributeName          设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排
 NSParagraphStyleAttributeName      设置文本段落排版格式，取值为 NSParagraphStyle 对象
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的SQLite]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/25/ios-sqlite/"/>
    <updated>2015-12-25T10:44:52+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/25/ios-sqlite</id>
    <content type="html"><![CDATA[<p><img src="/myimg/ios/sqlite.png" alt="image" /></p>

<p><a href="http://www.sqlite.org/">SQLite</a>是一个轻量级的关系型数据库，在iOS和Android手机中都有用到，C语言的面向过程的函数式编程。<a href="https://github.com/woooooojianjie/SQLitePersistentObject">SQLitePersistentObject</a>和<a href="https://github.com/ccgus/fmdb">FMDB</a>框架都是基于SQLite开发的。SQLitePersistentObject更像是个ORM框架，它是由Jeff LaMarche在2008年开发的，所以不是ARC的，要用的请加上<strong>-fno-objc-arc</strong>，且作者已经没有维护了，所以还是推荐使用更加广泛的FMDB。<!--more--></p>

<h3>*SQLite</h3>

<p>添加依赖库libsqlite3.tbd，用SQLite来个原生的增删改查。下面一次性完成了创建并打开数据库，创建表，插入一条数据，查询数据，最后关闭数据库。
<code>
NSString* docsdir = [NSSearchPathForDirectoriesInDomains( NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
NSString* dbpath = [docsdir stringByAppendingPathComponent:@"user.sqlite"];
sqlite3 *database;
//创建并打开数据库*****************
if (sqlite3_open([dbpath UTF8String], &amp;database) != SQLITE_OK) { //SQLITE_OK == 0
   sqlite3_close(database);
   NSAssert(0,@"数据库打开失败"); //若状态不是0就打开失败
}
//创建表格*****************
NSString *createSql = @"CREATE TABLE IF NOT EXISTS student (student_id INTEGER PRIMARY KEY ,student_name TEXT);";
char *createError;
//sqlite3_exec这个方法可以执行那些没有返回结果的操作，例如创建、插入、删除、修改等。这个函数包含了sqlite3_prepare这个函数的操作，目的是将UTF-8格式的SQL语句转换为编译后的语句
if (sqlite3_exec(database, [createSql UTF8String], NULL, NULL, &amp;createError) != SQLITE_OK) {
    sqlite3_close(database);
    NSAssert(0,@"创建表错误：%s", createError);
}
//插入或修改数据*****************  
char *update = "INSERT OR REPLACE INTO student VALUES (?,?)";  
sqlite3_stmt *statement;  
if (sqlite3_prepare_v2(database, update, -1, &amp;statement, nil) == SQLITE_OK) {  
    //将值保存到指定的列,列从1开始！！  
    sqlite3_bind_int(statement, 1, 4);//1是列，4是student_id  
    //第四个参数代表第三个参数中需要传递的长度。对于C字符串来说，-1表示传递全部字符串。第五个参数是一个回调函数，比如执行后做内存清除工作。  
    sqlite3_bind_text(statement, 2, [@"studentName" UTF8String], -1, NULL);  
}    
if (sqlite3_step(statement) != SQLITE_DONE) {  
    NSAssert(0,@"更新数据出错");  
}  
sqlite3_finalize(statement);  
//查询数据库*****************
NSString *querySql = @"SELECT * FROM student;";
sqlite3_stmt *selectStmt;
if (sqlite3_prepare_v2(database, [querySql UTF8String], -1, &amp;selectStmt, nil) == SQLITE_OK) {
    while (sqlite3_step(selectStmt) == SQLITE_ROW) {
        int studentId = sqlite3_column_int(selectStmt, 0);//后面的数字对应每一列
        char *cString = (char *)sqlite3_column_text(selectStmt, 1);
        NSString* studentName = [[NSString alloc]initWithUTF8String:cString];
        NSLog(@"student_id = %d   student_name = %@",studentId,studentName);
    }
    sqlite3_finalize(selectStmt);
}
sqlite3_close(database);//最后关闭数据库
</code>
<img src="/myimg/ios/select.png" alt="image" />
<img src="/myimg/ios/table.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的多线程]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/22/thread/"/>
    <updated>2015-12-22T14:28:22+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/22/thread</id>
    <content type="html"><![CDATA[<p>1.什么是进程</p>

<p>进程是指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。
<img src="/myimg/ios/jincheng.png" alt="image" /><!--more--></p>

<p>2.什么是线程</p>

<p>进程要想执行任务必须通过线程来执行，1个进程至少会有1条线程(主线程)，进程的所有任务都在线程中执行。
<img src="/myimg/ios/xiancheng.png" alt="image" /></p>

<p>线程中任务的执行是按顺序执行的，后面的任务要等前面的任务执行完了才能执行。但1个进程里可以开启多个线程来同时执行不同的任务，可以提高任务的执行效率。
<img src="/myimg/ios/duox.png" alt="image" /></p>

<p>iOS中每个进程都会有一个主线程(UI线程)，<strong>只能在主线程中更新UI</strong>。如果在这个主线程里做了过多的耗时操作，就会造成UI卡顿，所以用多线程来处理耗时操作。常用的开启多线程方式有三种：NSThread, NSOperation, GCD。</p>

<h3>*NSThread</h3>

<p>NSThread是轻量级的多线程开发，用起来也不复杂。</p>

<p>初始化方法
<code>
+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;
- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;
</code>
其他方法
<code>
- (void)start;//启动一个线程，并非立即执行，而是处于就绪状态，当系统调度时才真正执行
- (void)cancel;//取消
+ (BOOL)isMainThread;//当前线程是不是主线程
+ (NSThread *)mainThread //获取主线程
+ (NSThread *)currentThread;//返回当前线程
+ (BOOL)isMultiThreaded;//是不是多线程
+ (void)sleepUntilDate:(NSDate *)date;//休眠
+ (void)sleepForTimeInterval:(NSTimeInterval)ti;//休眠
+ (void)exit;//退出
+ (double)threadPriority;//优先级
+ (BOOL)setThreadPriority:(double)p;//设置优先级 0~1
- (BOOL)isExecuting;//正在执行
- (BOOL)isFinished;//执行完毕
- (BOOL)isCancelled;//已经取消
</code>
在子线程里要调用主线程来更新UI,可以用NSObject类别中的 OnMainThread 方法(前两个)。
<code>
@interface NSObject (NSThreadPerformAdditions)
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array ;
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait ;
- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg ;
@end
</code>
按顺序启动（start）的线程不一定是按顺序执行，由系统调度资源决定的，同样的代码多运行几次顺序就不一样了。
<img src="/myimg/ios/shunxv.png" alt="image" />
<img src="/myimg/ios/shunxv2.png" alt="image" /></p>

<h3>*NSOperation</h3>

<p>NSOperation是个抽象类，使用的话要<strong>继承它然后实现main方法</strong>。但它有两个现成子类：NSInvocationOperation和NSBlockOperation，后者使用Block形式进行代码组织，使用相对方便。</p>

<p>NSOperation要和NSOperationQueue一起使用，只要将一个NSOperation子类对象
放到NSOperationQueue队列中，线程就会依次启动。NSOperationQueue负责管理、执行所有的NSOperation，可以更加容易的管理线程总数和控制线程之间的依赖关系。可以通过监听<strong>isFinished</strong>属性来得到线程执行完毕通知。</p>

<p>NSOperation类中的方法</p>

<pre><code>- (void)start;
- (void)cancel;
- (void)main;//继承后要实现具体操作
- (void)addDependency:(NSOperation *)op;//添加线程间的依赖关系，A依赖B，所以要B先执行完再执行A(切记不要循环依赖...)
- (void)removeDependency:(NSOperation *)op;//移除依赖关系
- (void)waitUntilFinished;
</code></pre>

<p>几个属性
<code>
@property (readonly, getter=isCancelled) BOOL cancelled;
@property (readonly, getter=isExecuting) BOOL executing;
@property (readonly, getter=isFinished) BOOL finished;
@property (readonly, getter=isConcurrent) BOOL concurrent;//已经弃用，用下面的'asynchronous'
@property (readonly, getter=isAsynchronous) BOOL asynchronous;//是否异步执行
@property (readonly, getter=isReady) BOOL ready;
</code>
为什么说<strong>NSOperation要和NSOperationQueue一起使用</strong>呢？因为如果NSOperation子类对象直接start启动的话，它其实是在主线程中执行的！
<img src="/myimg/ios/error.png" alt="image" />
如果把NSOperation子类对象加到NSOperationQueue中,这就不是在主线程中执行了。
<img src="/myimg/ios/right.png" alt="image" /></p>

<p>NSInvocationOperation就两个初始化方法，两个属性&hellip;
<code>
- (nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;
- (instancetype)initWithInvocation:(NSInvocation *)inv;
@property (readonly, retain) NSInvocation *invocation;
@property (nullable, readonly, retain) id result;
</code>
NSBlockOperation就两个方法，一个属性&hellip;
<code>
+ (instancetype)blockOperationWithBlock:(void (^)(void))block;//初始化
- (void)addExecutionBlock:(void (^)(void))block;//创建一个新的线程来执行任务
@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;//任务数组
</code>
<strong>addExecutionBlock</strong>会创建一个新的线程来执行任务，而不是在同一个子线程中。
<img src="/myimg/ios/blockThread.png" alt="image" /></p>

<p>NSOperationQueue中的方法及属性，都很少&hellip;
<code>
- (void)cancelAllOperations;//取消线程
- (void)waitUntilAllOperationsAreFinished;
+ (nullable NSOperationQueue *)currentQueue;
+ (NSOperationQueue *)mainQueue;//获取主线程
- (void)addOperation:(NSOperation *)op;//添加线程
- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait;//添加线程数组
- (void)addOperationWithBlock:(void (^)(void))block;//添加线程block
@property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;
@property (readonly) NSUInteger operationCount;//池子里几个线程
@property NSInteger maxConcurrentOperationCount;//最大并发线程数
@property (getter=isSuspended) BOOL suspended;//延迟
@property (nullable, copy) NSString *name;//线程名字
@property NSQualityOfService qualityOfService;// ??
@property (nullable, assign) dispatch_queue_t underlyingQueue;// ??
</code></p>

<h3>*GCD</h3>

<p>GCD(Grand Central Dispatch)是基于C语言开发的一套多线程开发机制，也是苹果官方推荐的多线程开发方法。抽象层次最高，当然是用起来也最简单，只是它基于C语言开发，并不像NSOperation是面向对象的开发，而是完全面向过程的，最显著的优点就是它对于多核运算更加有效。</p>

<p>GCD中的队列分为<strong>串行队列</strong>和<strong>并发队列</strong>两类，都是异步的：</p>

<p>串行队列：只有一个子线程，加入到队列中的操作按添加顺序依次执行。</p>

<p>并发队列：有多个子线程，操作进来之后它会将这些队列安排在可用的处理器上，同时保证先进来的任务优先处理。</p>

<p><strong>1. 串行队列, 在同一个子线程里, 顺序执行！</strong> 关键字 <em>DISPATCH_QUEUE_SERIAL</em>
<code>
dispatch_queue_t serialQueue = dispatch_queue_create("myThreadQueue", DISPATCH_QUEUE_SERIAL);
    for (int i=0; i&lt;5; ++i) {
        dispatch_async(serialQueue, ^{
            [self doSomething:i];
        });
    }
</code>
<img src="/myimg/ios/gcd1.png" alt="image" /></p>

<pre><code>//更新UI界面,此处调用了GCD主线程队列的方法
dispatch_queue_t mainQueue = dispatch_get_main_queue();
  dispatch_sync(mainQueue, ^{
    [self updateUI];
});
</code></pre>

<p><strong>2. 并发队列, 在不同的子线程里, 并发执行</strong> 关键字 <em>DISPATCH_QUEUE_CONCURRENT</em></p>

<pre><code> //方式一：dispatch_queue_t serialQueue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
 dispatch_queue_t serialQueue=dispatch_queue_create("myThreadQueue", DISPATCH_QUEUE_CONCURRENT);
    for (int i=0; i&lt;5; ++i) {
        dispatch_async(serialQueue, ^{
            [self doSomething:i];
        });
    }
</code></pre>

<p><img src="/myimg/ios/ybbf.png" alt="image" />
若把上面的<strong>dispatch_async</strong>改成<strong>dispatch_sync</strong>,这就是在主线程中顺序执行了！即使在异步并发队列中！
<img src="/myimg/ios/hah.png" alt="image" />
所以，GCD若要<strong>异步多线程</strong>执行必须：使用异步队列<strong>DISPATCH_QUEUE_CONCURRENT</strong> 并且 方法是异步方法(dispatch_async)!! 否则，要么在<strong>子线程</strong>里顺序执行(串行队列，异步方法(dispatch_async))，要么在<strong>主线程</strong>里顺序执行！！(同步方法(dispatch_sync)，不管串行还是并发队列)</p>

<p>解决异步情况下抢占资源问题，可以加锁<strong>NSLock</strong>。获取资源时lock住，获取完资源后unlock。或者用<strong>@synchronized</strong>包裹获取资源代码。</p>

<p>几个线程执行完后得到通知</p>

<pre><code>    dispatch_group_t group = dispatch_group_create();
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^{
        //并发执行的任务一
    });
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^{
        //并发执行的任务二
    });
    dispatch_group_notify(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^{
        //所有任务都执行完了得到通知
    });
</code></pre>

<pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc]init];
NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{
     //并发执行的任务一
 }];
 [blockOperation addExecutionBlock:^{
     //并发执行的任务二
 }];
 [blockOperation setCompletionBlock:^{
     //所有任务都执行完了
 }];
 [queue addOperation:blockOperation];
</code></pre>

<h3>*总结</h3>

<p>1.无论使用哪种方法进行多线程开发，每个线程启动后并不一定立即执行相应的操作，具体什么时候由系统调度，CPU空闲时就会执行。</p>

<p>2.更新UI应该在主线程（UI线程）中进行，常用的方法如下：</p>

<p>-(void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait</p>

<p>-(void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL) wait;//传递[NSThread mainThread]</p>

<p>[[NSOperationQueue mainQueue] addOperationWithBlock:^{ }];</p>

<p>dispatch_sync(dispatch_get_main_queue(), ^{ });</p>

<p>3.NSThread适合轻量级多线程开发，要手动控制线程，线程总数无法控制，无法线程依赖。</p>

<p>4.对于简单的多线程开发建议使用NSObject的扩展方法完成，而不必使用NSThread。</p>

<p>5.可以使用NSThread的currentThread方法取得当前线程，使用 sleepForTimeInterval:方法让当前线程休眠。</p>

<p>6.NSOperation进行多线程开发可以控制线程总数及线程依赖关系。</p>

<p>7.创建一个NSOperation不应该直接调用start方法, 如果直接start则会在主线程中调用, 而是应该放到NSOperationQueue中启动。</p>

<p>8.相比NSInvocationOperation推荐使用NSBlockOperation，代码简单，同时由于闭包性使它没有传参问题。</p>

<p>9.NSOperation是对GCD面向对象的封装，但是GCD基于C语言开发，效率却更高. 建议如果任务之间有依赖关系或者想要监听任务完成状态的情况下优先选择NSOperation否则使用GCD。</p>

<p>10.在GCD中串行队列中的任务被安排到一个单一的子线程中，可以方便地控制执行顺序；并发队列在多个线程中执行（前提是使用异步方法），顺序控制相对复杂，但是更高效。</p>

<p>11.在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并发队列并且使用异步方法执行时才能在多个线程中并发执行。</p>

<p>12.相比使用NSLock，@synchronized更加简单。</p>
]]></content>
  </entry>
  
</feed>
