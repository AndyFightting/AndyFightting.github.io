
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>前端基础知识 - 阿贵</title>
  <meta name="author" content="guimingsu">

  
  <meta name="description" content="前端基础知识 Feb 11th, 2017 1:45 pm * 前端性能优化 CSS精灵(CSS Sprites),把网页中一些零散的图片整合到一张图片中，然后通过background-position来定位获取。减少网页请求，设计师修改风格只需在一张图片上操作，没命名困扰，能减少字节(aaa> &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andyfightting.github.io/blog/2017/02/11/front-end/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="阿贵" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">  -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

<script>
  function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
    });
  }
  $(document).bind('DOMNodeInserted', function(event) {
    addBlankTargetForLinks();
  });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">阿贵</a></h1>
  
    <h2>认真听，好好想，慢慢回。多思考，多做笔记。</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andyfightting.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">前端基础知识</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-02-11T13:45:11+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>1:45 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h3>* 前端性能优化</h3>

<ol>
<li><a href="http://www.cnblogs.com/autumn123/p/4237286.html">CSS精灵(CSS Sprites)</a>,把网页中一些零散的图片整合到一张图片中，然后通过background-position来定位获取。减少网页请求，设计师修改风格只需在一张图片上操作，没命名困扰，能减少字节(aaa>A)。
改动麻烦，一改全动，要么就新增。</li>
<li><a href="https://yq.aliyun.com/articles/49918">JS文件合并</a></li>
<li>JS延迟加载(setTimeout)，图片延迟按需加载(jquery lazyload)，预加载资源</li>
<li>减少DOM元素数量</li>
<li>避免重定向跳转</li>
<li>减小cookie大小</li>
<li>避免空的src,因为它仍然会发送请求</li>
<li>资源压缩传输（Google protocol buffer）</li>
<li>利用缓存，cache-control,Expires</li>
<li>缓存DNS查找</li>
<li>减少http请求(CSS精灵，文件合并都是为了这个)</li>
<li>浏览器会对同一个域的下载链接数有限制(一般是6个)，所以可以按域名来划分下载内容，增大并发下载数量。</li>
<li><a href="http://kb.cnblogs.com/page/121664/">使用CDN</a>(Content Delivery Network，即内容分发网络,将网站的内容发布到最接近用户的网络"边缘"，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度)</li>
</ol>


<h4>*JSONP原理</h4>

<p>JSON是一种数据交换格式，JSONP(JSON Padding)是数据的传递方式，不一样的概念。打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用“暗号”书写的情报，传递给自己同志时使用的接头方式。一个是描述信息的格式，一个是信息传递时约定的方法。</p>

<p>JSONP是为了解决跨域问题，因为受限于浏览器的同源策略(域名相同，协议相同，端口相同)，XMLHttpRequest 不能进行跨域请求，但是 script 标签却可以(有src属性的标签都可以，如img,iframe)。JSONP的原理就是：<strong>让服务器端调用本地的JS方法，在调用的时候把数据当做参数传进去，然后本地就可以获得数据进行处理了。</strong></p>

<p>远程服务器remoteserver.com根目录下有个remote.js文件代码如下：</p>

<pre><code>localHandler({"result":"我是远程js带来的数据"});
</code></pre>

<p>现在我们在test.html页面定义一个函数，然后在远程remote.js中传入数据进行调用,就获取到跨域服务器端的数据了。</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type="text/javascript"&gt;
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
    &lt;/script&gt;
    &lt;script type="text/javascript" src="http://remoteserver.com/remote.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>基本原理就是这样，剩下的就是如何弹性封装了，如：</p>

<pre><code>&lt;script type="text/javascript"&gt;
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };

    var url = "http://remoteserver.com/remote.js?id=123&amp;callback=localHandler";
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
   document.getElementsByTagName('head')[0].appendChild(script); 
&lt;/script&gt;
</code></pre>

<h3>* <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">JS原型链是什么</a></h3>

<p>在 javaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部属性。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向），组成这条链的最后一环。这种一级一级的链结构就称为原型链（prototype chain）。</p>

<p>Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>

<p>JavaScript的对象中都包含了一个 prototype 内部属性，这个属性所对应的就是该对象的原型。在JavaScript的原型对象中，还包含一个"constructor"属性，这个属性对应创建所有指向该原型的实例的构造函数。JavaScript 不包含传统的类继承模型，而是使用 prototypal 原型模型。</p>

<pre><code>XXX.__proto__ :原型(父类)。
XXX.protoype :原型对象(父实例)。
</code></pre>

<p><a href="http://blog.jobbole.com/66441/">参考</a></p>

<h4>*cookie、sessionStorage、localStorage的区别</h4>

<p>document.cookie: 是服务器端保存在客户端的一段信息，如保存登录信息，记住密码等,它可以设置过期时间自动清除,4K左右.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，所以不宜过大。如服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。</p>

<p>window.sessionStorage: session即会话，关闭浏览器即清除。5M左右，仅保存在客户端中，不参与通信。</p>

<p>window.localStorage: 本地持久化，一直都在除非手动删除。5M左右。</p>

<p>sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面。</p>

<p>localStorage：在所有同源窗口中都是共享的。</p>

<p>cookie：也是在所有同源窗口中都是共享的。</p>

<p>共同点：都是保存在浏览器中，且都是同源的。</p>

<p>不同点：大小不同，有效期不同，作用域不同。</p>

<h3>* 创建一个从1到100的数组</h3>

<p>一看这题目应该就不是for循环这么简单了</p>

<p>递归：</p>

<pre><code>  function test(arr, num) {
      if (num &gt; 100) {
          return arr
      }
      arr.push(num);
      return test(arr, num + 1)
  }
  var arr = test([], 1);
</code></pre>

<p>Generator函数：</p>

<pre><code>function* test(i) {
    yield i;
    if (i &lt; 100) {
        yield* test(i + 1);
    }
}
 var arr =   Array.from(test(1));
</code></pre>

<h3>* 说说React &amp; Vue</h3>

<p>虚拟DOM, 单向数据流，双向绑定响应式，组件化，模板+js+css，JSX语法,生命周期，指令，依赖追踪，检查机制,更快的渲染更小的体积, 庞大的社区，RN，Weex,引用本地模块。</p>

<p><a href="http://cn.vuejs.org/v2/guide/comparison.html">对比</a> ,<a href="http://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247484393&amp;idx=1&amp;sn=142b8e37dfc94de07be211607e468030&amp;chksm=9723612ba054e83db6622a891287af119bb63708f1b7a09aed9149d846c9428ad5abbb822294&amp;mpshare=1&amp;scene=1&amp;srcid=1026oUz3521V74ua0uwTcIWa&amp;from=groupmessage&amp;isappinstalled=0#wechat_redirect&amp;utm_source=tuicool&amp;utm_medium=referral">参考</a></p>

<h4>*<a href="http://www.w3school.com.cn/css/css_boxmodel.asp">CSS盒模型</a></h4>

<p><img src="/myimg/js/cssbox.png" width="400" alt="" /></p>

<p>背景应用于由内容和内边距、边框组成的区域。width,heightz只是内容宽高，不包括padding,border,marin.</p>

<h3>*get和post请求的区别</h3>

<p>Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE,可以应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</p>

<p>GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&amp;相连。POST把提交的数据则放置在是HTTP包的包体中。</p>

<p>GET方式提交的数据有大小限制，而POST理论上没有。</p>

<p>POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。</p>

<p><a href="https://www.oschina.net/news/77354/http-get-post-different">99%的人都理解错了&hellip;</a></p>

<h3>*什么是HTTPS</h3>

<p>https是https+ssl(Secure Socket Layer),它是从底层协议的层面来解决如下问题：</p>

<ol>
<li>数据裸奔问题</li>
<li>数据被篡改问题</li>
<li>身份验证问题</li>
</ol>


<p>它的基本思路是采用公钥加密法(RSA)，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。由于非对称加密的效率问题，一般是用对称加密给数据进行加密，然后把对称加密的密钥进行RSA加密来传输，并且对称加密的密钥是动态变化的。</p>

<h3>*说说TCP/UDP</h3>

<p>TCP: 传输控制协议，三次握手，四次挥手。面向连接，安全可靠。传输大量数据，慢。</p>

<p>UDP: 用户数据协议，面向非连接，直接发数据，不可靠，发小量数据，快。</p>

<h3>*JS类的创建</h3>

<p> <strong>构造函数法</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function Dog() {
</span><span class='line'>   this.name = "金毛";
</span><span class='line'>}
</span><span class='line'>var dog = new Dog();
</span><span class='line'>alert(dog.name);</span></code></pre></td></tr></table></div></figure>


<p><strong>Object.create()法</strong>, 但是不能实现私有属性和私有方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  var Dog = {
</span><span class='line'>　　　　name: "金毛",
</span><span class='line'>　　　　makeSound: function(){ alert("hello world"); }
</span><span class='line'>　　};
</span><span class='line'>　　var dog = Object.create(Dog);
</span><span class='line'>　　alert(dog.name); 
</span><span class='line'>　　cat1.makeSound(); </span></code></pre></td></tr></table></div></figure>


<p> <strong>极简法</strong> (这不就是工厂方法吗？工厂的属性和方法是私有的且是共享的)</p>

<p>封装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  var Cat = {
</span><span class='line'>　　　　createNew: function(){
</span><span class='line'>　　　　　　var cat = {};
</span><span class='line'>　　　　　　cat.name = "大毛";
</span><span class='line'>　　　　　　cat.makeSound = function(){ alert("喵喵喵"); };
</span><span class='line'>　　　　　　return cat;
</span><span class='line'>　　　　}
</span><span class='line'>　　};
</span><span class='line'>　　var cat1 = Cat.createNew();
</span><span class='line'>　　cat1.makeSound();</span></code></pre></td></tr></table></div></figure>


<p> 继承：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   var Animal = {
</span><span class='line'>　　　　createNew: function(){
</span><span class='line'>　　　　　　var animal = {};
</span><span class='line'>　　　　　　animal.sleep = function(){ alert("睡懒觉"); };
</span><span class='line'>　　　　　　return animal;
</span><span class='line'>　　　　}
</span><span class='line'>　　};
</span><span class='line'>   var Cat = {
</span><span class='line'>　　　　createNew: function(){
</span><span class='line'>　　　　　　var cat = Animal.createNew();
</span><span class='line'>　　　　　　cat.name = "大毛";
</span><span class='line'>　　　　　　cat.makeSound = function(){ alert("喵喵喵"); };
</span><span class='line'>　　　　　　return cat;
</span><span class='line'>　　　　}
</span><span class='line'>　　};
</span><span class='line'>   var cat1 = Cat.createNew();
</span><span class='line'>　　cat1.sleep();
</span><span class='line'>　　cat1.makeSount();</span></code></pre></td></tr></table></div></figure>


<p>私有属性和方法：下面只要不是定义在cat对象上的方法和属性，都是私有的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  var Cat = {
</span><span class='line'>　　　　createNew: function(){
</span><span class='line'>　　　　　　var cat = {};
</span><span class='line'>　　　　　　var sound = "喵喵喵"; //私有属性
</span><span class='line'>　　　　　　cat.makeSound = function(){ alert(sound); };
</span><span class='line'>　　　　　　return cat;
</span><span class='line'>　　　　}
</span><span class='line'>　　};
</span><span class='line'>　　var cat1 = Cat.createNew();
</span><span class='line'>　　alert(cat1.sound); // undefined</span></code></pre></td></tr></table></div></figure>


<p>数据共享：</p>

<pre><code>  var Cat = {
　　　　sound : "喵喵喵", //被各个实例共享
　　　　createNew: function(){
　　　　　　var cat = {};
　　　　　　cat.makeSound = function(){ alert(Cat.sound); };
　　　　　　return cat;
　　　　}
　　};
　　var cat1 = Cat.createNew();
　　var cat2 = Cat.createNew();
　　cat1.makeSound(); // 喵喵喵
</code></pre>

<p><strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">ES6 class法</a></strong></p>

<pre><code>class Cat { 
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(this.name + ' makes a noise.');
  }
}

class Lion extends Cat {
  speak() {
    super.speak();
    console.log(this.name + ' roars.');
  }
}
</code></pre>

<p><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">参考</a></p>

<h3>*JS闭包</h3>

<p>闭包就是能够读取其他函数内部变量的函数。闭包使得函数拥有私有变量称为可能，它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。因为里面的闭包函数是个全局变量，会一直在内存中。</p>

<p>下面计数器受匿名函数的作用域保护，只能通过 add 方法修改。</p>

<pre><code>var add = (function () {
   var counter = 0;
   return function () {
      return counter += 1;
    }
})();

add();
add();
add();
</code></pre>

<p><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">参考</a></p>

<h3>* use strict</h3>

<p>严格模式，使得JS在更严格的条件下运行，有如下优势：</p>

<pre><code>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为
消除代码运行的一些不安全之处，保证代码运行的安全
提高编译器效率，增加运行速度
为未来新版本的JS特性做好铺垫
</code></pre>

<h3>* CSS Reset 是什么</h3>

<p>在HTML标签在浏览器里有默认的样式，例如 p 标签有上下边距，strong标签有字体加粗样式，em标签有字体倾斜样式。不同浏览器的默认样式之间也会有差别。把浏览器提供的默认样式覆盖掉, 这就是CSS Reset。</p>

<h3>* 回调地狱</h3>

<p>即异步回调的层层嵌套,可以用 Promise 对象、Generator函数，Async函数来解决。</p>

<pre><code>$.ajax({  
    url: url1,  
    success: function(data){  
        $.ajax({  
            url: url2,  
            data: data,  
            success: function(data){  
                $.ajax({  
                    //...
                });  
            }      
        });  
    }  
});  
</code></pre>

<h3>* xss和csrf是什么</h3>

<p>XSS它的全名是：Cross-site scripting 夸站脚本攻击，为了和CSS层叠样式表区分所以取名XSS。是一种网站应用程序的安全漏洞攻击，是代码注入的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。</p>

<p>提交过滤。</p>

<p>CSRF全名是：Cross-site request forgery 跨站请求伪造，也是不攻击服务器端而攻击正常访问网站的用户。CSRF 顾名思义，是伪造请求，冒充用户在站内的正常操作。大多数网站是通过 cookie 等方式辨识用户身份再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机发起用户所不知道的请求。</p>

<p>验证码，域名判断，添加token。</p>

<h3>* 图片滚动到了才加载原理</h3>

<p>即懒加载延迟加载，原理是：先在img src中放一张占位符图片，而真实的图片地址存放在相对应一个属性 data-img中，这样的话 那么页面加载的时候 只加载src地址 不会对属性的图片真正地址加载，滚动时候判断 待加载的资源相对于浏览器顶端的距离小于可视区域相对于浏览器顶端的距离 如果为true的话 则把相对应的data-img值赋值给src 加载，否则不加载。</p>

<p>主要有三种模式：</p>

<pre><code>第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟，如果用户在加载前就离开了页面，那么就不会加载。
第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。
第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。
</code></pre>

<h3>* 把URL参数解析为一个对象</h3>

<pre><code>var url = "http://www.taobao.com/index.php?key0=0&amp;key1=1&amp;key2=2";
var obj = parseUrl(url);

function parseUrl(argu){
  var str = argu.split('?')[1];
  var result = {};
  var temp = str.split('&amp;');
  for(var i=0; i&lt;temp.length; i++)
  {
     var temp2 = temp[i].split('=');
     result[temp2[0]] = temp2[1];
  }
  return result;
}
</code></pre>

<h3>* flex布局与传统布局</h3>

<p>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。</p>

<p>flex容器布局：默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>

<p><img src="/myimg/js/flexbox.png" width="600" alt="" /></p>

<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">参考</a></p>

<h3>* JS事件流</h3>

<p>事件流：事件在页面中传播的顺序。</p>

<p>捕获，冒泡：xxx.addEventListener(type,handler,flag),flag是一个bool值，true表示事件捕捉阶段执行，false表示事件冒泡阶段执行，默认是冒泡。</p>

<p><img src="/myimg/js/event.png" width="400" alt="" /></p>

<p><a href="http://www.cnblogs.com/starof/p/4066381.html">参考</a></p>

<h3>* 从输入 URL 到页面加载完的过程中都发生了什么事情</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>检查浏览器缓存，如果有的话直接解析显示。
</span><span class='line'>DNS域名解析，层层寻找，负载均衡，找到对应的IP
</span><span class='line'>TCP链接，三次握手(HTTPS更多次)
</span><span class='line'>加载策略，RSA密钥协商，加密解密
</span><span class='line'>服务器处理，数据库查询，返回页面
</span><span class='line'>网页重定向
</span><span class='line'>页面里的资源链接再获取数据，浏览器渲染</span></code></pre></td></tr></table></div></figure>


<h3>* link和import的区别</h3>

<pre><code>来源不同：link 属于html标签，而@import完全是css提供的一种方式。link还能加载其他东西如RSS,而import只能加载CSS.
加载顺序不同：当一个页面被加载的时候，link引用的CSS会同时被加载，而@import引用的CSS 会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁，阿里云APP总这样闪），网速慢的时候还挺明显。
兼容性差别：由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。
使用dom控制样式时的差别：当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。
</code></pre>

<h3>* JS优缺点</h3>

<pre><code>JavaScript是一种基于对象（Object）和事件驱动（Event Driven,单线程事件轮询）、动态、弱类型、基于原型的语言。
函数作为一等公民存在,函数式编程。动态性，指定函数的执行语境，动态混入，动态修改原型等。

允许同名函数的重复定义，后面的定义可以覆盖前面的定义。隐式类型转换。全局变量难以控制，null &amp; undefined鸡肋。
</code></pre>

<h3>* CSS预处理</h3>

<p>CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的逻辑程序、函数等,在编程语言中的一些基本特性，可以让你的 CSS 更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。</p>

<p><a href="http://less.bootcss.com/">Less</a> 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。</p>

<p><a href="https://segmentfault.com/q/1010000002527156">参考</a></p>

<h3>* 函数声明 &amp; 函数表达式</h3>

<p>定义函数的方法主要有三种：</p>

<ol>
<li>函数声明(Function Declaration)</li>
<li>函数表达式Function Expression)</li>
<li>new Function构造函数</li>
</ol>


<p>用函数声明创建的函数funDeclaration可以在funDeclaration定义之前就进行调用；而用函数表达式创建的funExpression函数不能在funExpression被赋值之前进行调用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//声明
</span><span class='line'>function functionName(arg1, arg2){}
</span><span class='line'>//表达式
</span><span class='line'>var  variable = function(arg1, arg2){}</span></code></pre></td></tr></table></div></figure>


<p>用函数声明创建的函数funDeclaration可以在funDeclaration定义之前就进行调用；而用函数表达式创建的funExpression函数不能在funExpression被赋值之前进行调用。</p>

<pre><code>funDeclaration("Declaration");//=&gt; true
     function funDeclaration(type){
         return type==="Declaration";
     }

 funExpression("Expression");//=&gt;error
     var funExpression = function(type){
         return type==="Expression";
     }
</code></pre>

<p><a href="http://www.cnblogs.com/isaboy/p/javascript_function.html">参考</a></p>

<h3>* <a href="http://webpackdoc.com/amd.html">AMD(异步模块定义)</a> &amp; <a href="http://webpackdoc.com/commonjs.html">CommonJs规范</a></h3>

<p>CommonJS是服务器端模块化规范，NodeJS采用了这个规范。根据它的规范，一个文件就是一个模块，每个模块都在一个单独的作用域，也就是说在该模块内部定义的变量，无法被其他模块读取，除非定义global对象的属性。CommonJS加载模块是同步的，也就是说只有加载完成，才能执行后面的操作。它的 exports 才是对外接口。</p>

<p>CommonJS 规范是为了解决 JavaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行。该规范的主要内容是，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>所有代码都运行在模块作用域，不会污染全局作用域。
</span><span class='line'>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
</span><span class='line'>模块加载的顺序，按照其在代码中出现的顺序。</span></code></pre></td></tr></table></div></figure>


<pre><code>//模块定义 example.js
var x = 5;
var addX = function (value) {
  return value + x;
};
module.exports.x = x;
module.exports.addX = addX;

//使用模块
var example = require('./example.js');
console.log(example.x); // 5
console.log(example.addX(1)); // 6
</code></pre>

<p>Node内部提供一个Module构建函数。所有模块都是Module的实例。每个模块内部，都有一个module对象，代表当前模块。它有以下属性。module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module.id 模块的识别符，通常是带有绝对路径的模块文件名。
</span><span class='line'>module.filename 模块的文件名，带有绝对路径。
</span><span class='line'>module.loaded 返回一个布尔值，表示模块是否已经完成加载。
</span><span class='line'>module.parent 返回一个对象，表示调用该模块的模块。
</span><span class='line'>module.children 返回一个数组，表示该模块要用到的其他模块。
</span><span class='line'>module.exports 表示模块对外输出的值。</span></code></pre></td></tr></table></div></figure>


<p>AMD规范则是非同步的加载模块，允许指定回调函数。由于nodeJS主要用于服务器编程，模块文件一般都在本地，所以加载起来比较快，不用考虑非同步的加载方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器端加载模块，则必须采用非同步模式，所以浏览器一般采用AMD规范。</p>

<p>规范其实只有一个主要接口 define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。</p>

<pre><code>define(['package/lib'], function(lib){
  function foo(){
    lib.log('hello world!');
  }

  return {
    foo: foo
  };
});
</code></pre>

<p><a href="http://javascript.ruanyifeng.com/nodejs/module.html">参考</a></p>

<h3>* attribute和property的区别</h3>

<p><a href="https://www.web-tinker.com/article/20115.html">参考</a></p>

<h3>* ajax 原理</h3>

<h3>* jquery 原理</h3>

<h3>* 作用域链</h3>

<h3>* XMLHttpRequest</h3>

<h3>* JS事件委托</h3>

<h3>* this</h3>

<p><a href="http://www.cnblogs.com/yuanzm/p/4150558.html">参考</a></p>

<h3>* CSS动画原理</h3>

<h3>* 拖拽实现</h3>

<h3>* session</h3>

<h3>* 浮动清除</h3>

<h3>* 几种定位方法</h3>

<p><a href="https://developer.mozilla.org/en-US/docs/Web">MDN</a></p>

<p><a href="https://leohxj.gitbooks.io/front-end-database/content/index.html">前端参考手册</a></p>
</div>


      | <a href="#comments">Comments</a>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">guimingsu</span></span>

      




<time class='entry-date' datetime='2017-02-11T13:45:11+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>1:45 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/javascript/'>javascript</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
  <!-- JiaThis Button -->
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/12/30/utf8/" title="Previous Post: Unicode、UTF-8编码起源">&laquo; Unicode、UTF-8编码起源</a>
      
      
    </p>
  </footer>
</article>


  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-title="Octopress博客的个性化配置"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"tianweili"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END --></div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/02/11/front-end/">前端基础知识</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/30/utf8/">Unicode、UTF-8编码起源</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/28/google-protocol-buffer/">Google Protocol Buffer</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/27/suan-fa/">排序算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/21/es6/">ECMAScript 6</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>android (9)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (9)</a></li>
<li class='category'><a href='/blog/categories/java/'>java (6)</a></li>
<li class='category'><a href='/blog/categories/javascript/'>javascript (5)</a></li>
<li class='category'><a href='/blog/categories/other/'>other (5)</a></li>
<li class='category'><a href='/blog/categories/react/'>react (8)</a></li>

  </ul>
</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - guimingsu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
