
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>ECMAScript 6 - 阿贵</title>
  <meta name="author" content="guimingsu">

  
  <meta name="description" content="ECMAScript 6 Jan 16th, 2017 1:14 pm Generator 函数 执行该函数时只是返回一个内部调用栈的指针，然后手动执行 next() 方法进行一次栈里的 yield 表达式。next 方法每次返回一个对象{value: undefined, done: &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andyfightting.github.io/blog/2017/01/16/es6/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="阿贵" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">  -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

<script>
  function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
    });
  }
  $(document).bind('DOMNodeInserted', function(event) {
    addBlankTargetForLinks();
  });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">阿贵</a></h1>
  
    <h2>All growth is a leap in the dark.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andyfightting.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">ECMAScript 6</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-01-16T13:14:56+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>1:14 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h3>Generator 函数</h3>

<p>执行该函数时只是返回一个内部调用栈的指针，然后手动执行 <code>next()</code> 方法进行一次栈里的 <code>yield</code> 表达式。next 方法每次返回一个对象<code>{value: undefined, done: false}</code>
value 的值就是 yield 表达式的值，done 是最有一个yield是否都执行完了。每次调用 next 方法都是在上一次执行的 yield 后再执行下一次的 yield,也就是相当于Generator函数可以暂停，然后继续。next 方法还可以传入一个参数到函数内部，它会替换上一次 yield 的返回值(注意区分不是next方法的放回值，next方法始终是返回一个对象)。也就是说可以用 next方法动态的向函数里传参数，函数的执行时分段的，可以暂停，可以继续。Generator 函数还可以用 for of 进行遍历执行。</p>

<p><strong># 动态传参：</strong> Generator 函数的暂停执行的效果，意味着可以把异步操作写在 yield 语句里面，等到调用 next 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在 yield 语句下面，反正要等到调用next 方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>

<pre><code>      //next 传参
      function* myGenerator() {
          let a = yield 'hello';        //执行test.next('A')后： a = undefined,暂停在此处，等待下一次的next再继续
          let b = yield 'world' + a;    //执行test.next('B')后： a = 'B', b = undefined,暂停在此处，等待下一次的next再继续
          let c = yield 'generator' + b;//执行test.next('C')后： a = 'B', b = 'C', c = undefined ,暂停在此处，等待下一次的next再继续
          return '结束' + c;             //执行test.next('D')后： a = 'B', b = 'C', c = 'D'
        }

        let test = myGenerator();

        test.next('A');  //反回对象： {value: "hello", done: false} ,第一次的next传参是无效的，没意义的！
        test.next('B');  //反回对象： {value: "worldB", done: false}
        test.next('C');  //反回对象： {value: "generatorC", done: false}
        test.next('D');  //反回对象： {value: "结束D", done: true}
</code></pre>

<p><strong># for of  遍历:</strong> 注意，一旦 next 方法的返回对象的done属性为 true，for&hellip;of 循环就会中止，且不包含该返回对象，所以上面代码的 return 语句返回的 4，不包括在 for&hellip;of 循环之中。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> function *foo() {
</span><span class='line'>    yield 1;
</span><span class='line'>    yield 2;
</span><span class='line'>    yield 3;
</span><span class='line'>    return 4;
</span><span class='line'>  }
</span><span class='line'>  for (let v of foo()) {
</span><span class='line'>    console.log(v);
</span><span class='line'>  }
</span><span class='line'>  // 1 2 3 </span></code></pre></td></tr></table></div></figure>


<p><strong># 捕获外部错误：</strong> Generator 函数还有一个特点，它可以在函数体外抛出错误，然后在函数体内捕获。也可以函数体内抛错，外部捕获。 注意下面 throw 的不同！！</p>

<pre><code>   var g = function* () {
      while (true) {
        try {
          console.log('aaa');
          yield console.log('bbb');
          console.log('ccc');
        } catch (error) {
          console.log('内部捕获', error);
        }
      }
    };

    var i = g();
    i.next();
    try {
      i.throw('a'); //这是迭代器的 throw 方法
    } catch (error) {
      console.log('外部捕获', error);
    }
  //aaa
  //bbb
  //内部捕获 a
  //aaa   //为何这里还会执行 ？？
  //bbb
</code></pre>

<p><strong># 异步操作：</strong>  可以像下面那样就不用函数回调了！只是在异步操作成功后调用next就可以。注意，makeAjaxCall 函数中的 next 方法，必须加上 response 参数，因为 yield 语句构成的表达式，本身是没有值的，总是等于 undefined。</p>

<pre><code>   function* main() {
      var result = yield request("http://some.url");
      var resp = JSON.parse(result);
        console.log(resp.value);
    }

    function request(url) {
      makeAjaxCall(url, function(response){
        it.next(response);
      });
    }

    var it = main();
    it.next();
</code></pre>

<h3>Promise 对象</h3>

<p>Promise 对象是用来处理异步操作流程的，避免了层层嵌套的回调函数。</p>

<pre><code>  const step0 = function () {
      return new Promise(function(resolve, reject) {
          setTimeout(()=&gt;{
            console.log('step 0 处理');
              resolve(); //表示异步处理成功
          },2000);
      });
    };

    const step1 = function () {
      return new Promise(function(resolve, reject) {
        setTimeout(()=&gt;{
          console.log('step 1 处理');
          resolve(); //表示异步处理成功
        },2000);
      });
    };

    function allSuccess() {
        console.log('全部成功了');
    }

    function failed() {
      console.log('失败了');
    }

    step0().then(step1).then(allSuccess,failed);
</code></pre>

<p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>

<pre><code>var p = Promise.all([p1,p2,p3]);
</code></pre>

<p>p的状态由p1、p2、p3决定，分成两种情况。</p>

<ol>
<li>只有p1、p2、p3的状态都变成resolve，p的状态才会变成resolve，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要p1、p2、p3之中有一个被reject，p的状态就变成reject，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li>
</ol>


<p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。与all方法不同的是只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值。</p>

<p><strong>Catch:</strong>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>

<p><strong>注意：</strong>区别一下几种情况：</p>

<pre><code>// 写法一
doSomething().then(function () {
  return doSomethingElse();
}).then(finalHandler);

// 写法二
doSomething().then(function () {
  doSomethingElse();
}).then(finalHandler);

// 写法三
doSomething().then(doSomethingElse()).then(finalHandler);

// 写法四
doSomething().then(doSomethingElse).then(finalHandler);
</code></pre>

<p>写法一finalHandler的参数，是doSomethingElse返回的结果，下面最后会打印出hello.</p>

<pre><code>const doSomething = function () {
      return new Promise(function(resolve, reject) {
        console.log('step 0 处理');
        resolve();
      });
    };

    const doSomethingElse = function () {
       new Promise(function(resolve, reject) {
        console.log('step 1 处理');
        resolve();
      });

       return 'hello'
    };

    function finalHandler(msg) {
        console.log(msg);
    }

    doSomething().then(function () {
      return doSomethingElse();
    }).then(finalHandler);
</code></pre>

<p>写法二的finalHandler回调函数的参数是undefined。写法三的finalHandler回调函数的参数，是doSomethingElse函数返回的回调函数的运行结果。主要是写法三和写法四的区别，三的话doSomethingElse是马上执行，finalHandler拿不到它的返回结果！而四可以拿到它的返回结果。</p>

<pre><code>//三的打印
step 0
setp 1
undefined

//四的打印结果
step 0
setp 1
hello
</code></pre>

<h3>Async 函数</h3>

<p>async函数与Promise、Generator函数一样，是用来取代回调函数、解决异步操作的一种方法。它本质上是Generator函数的语法糖。</p>

<pre><code>  var a = function (){
      return new Promise(function (resolve, reject){
             setTimeout(()=&gt;{
               console.log('处理 a');
                 resolve();
             },1000);
      });
    };

    var b = function (){
      return new Promise(function (resolve, reject){
        setTimeout(()=&gt;{
          console.log('处理 b');
          resolve();
        },1000);
      });
    };

    var gen =async function(){
       await a();
       await b();
      console.log('结束');
    };

     gen();
</code></pre>

<ol>
<li>内置执行器。Generator函数的执行必须靠执行器，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li>
<li>更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>
</ol>


<h4>块级别的 let,const, 不会变量提升，会有暂时性死区。let可变，const常量只能初始化赋值一次。const的指向不能修改，但对象的属性可以修改。注意for循环中用var做临时变量时，循环结束后该临时变量还在！用let就不会。</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var a = [];
</span><span class='line'>for (var i = 0; i &lt; 10; i++) {
</span><span class='line'>  a[i] = function () {
</span><span class='line'>    console.log(i);
</span><span class='line'>  };
</span><span class='line'>}
</span><span class='line'>a[0](); // 10 ，全部都是 10   </span></code></pre></td></tr></table></div></figure>


<h4>for of遍历，可遍历对象的[key,value],遍历set,map, for in 不行。基于Iterator接口遍历。</h4>

<h4>默认参数，&hellip;不定个数参数，&hellip;对象展开, 不定参数只能放最后，</h4>

<h4>Set,Map,WeakSet,WeakMap</h4>

<h4>对象增强,直接写变量和方法作为对应的属性</h4>

<h4>字符窜模板插值 ${}</h4>

<h4>解构，匹配赋值，var {name:n, age:a} = getUser(); //n=getUser().name, a=getUser().age</h4>

<h4>Symbol，解决属性名冲突问题，始终唯一  Symbol(&lsquo;a&rsquo;) != Symbol(&lsquo;a&rsquo;)</h4>

<h4>Proxy，代理拦截 var p = new Proxy(target, handler); 操作 p 就会被handler代理拦截。</h4>

<h4>语法糖，用 => 定义方法， class 类, 像java似的写代码，<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">注意：</a></h4>

<pre><code>// 加上括弧包着是返回一个对象字面表达式, 注意两种区别 ！
 params =&gt; ({foo: bar})
 params =&gt; { statements }
</code></pre>

<p><strong>下面这种方式定义的方法会自动绑定上下文 this, 所以React可以用这样来代替手动 bind(this)</strong> <a href="https://facebook.github.io/react/docs/handling-events.html">这里</a></p>

<pre><code> &lt;button onClick={this.handleClick}&gt;
  handleClick = () =&gt; {  
    //thist 可用
  }

  //或者 这样也会自动绑定this
  &lt;button onClick={() =&gt; this.handleClick()}&gt;
  handleClick() {
     //this 可用
  }
</code></pre>

<h4>字符编码，之前都是基于 UTF-16 两个字节的编码，length 和 charAt()都是基于这样来读取的。然而 ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。对于那些需要四个字节存储的字符，再用之前的length ， charAt() 来操作就无法正确读取，所以得用新的方法新的方式来统一处理。codePointAt可以正确提取给定位置字符串的对应 Unicode 码.</h4>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">Mozilla MDN 文档</a></p>

<p><a href="http://es6.ruanyifeng.com/#docs/reference">ECMAScript 6 入门</a></p>

<p><a href="http://javascript.ruanyifeng.com/">JavaScript 标准参考</a></p>

<p><a href="https://github.com/irideas/es6features">ES6 Features</a></p>
</div>


      | <a href="#comments">Comments</a>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">guimingsu</span></span>

      




<time class='entry-date' datetime='2017-01-16T13:14:56+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>1:14 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/javascript/'>javascript</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
  <!-- JiaThis Button -->
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/12/22/react-ios/" title="Previous Post: React Native 和 iOS 互相调用">&laquo; React Native 和 iOS 互相调用</a>
      
      
    </p>
  </footer>
</article>


  <section>
    <h1>Comments</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-title="Octopress博客的个性化配置"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"tianweili"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- Duoshuo Comment END --></div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/01/16/es6/">ECMAScript 6</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/22/react-ios/">React Native 和 iOS 互相调用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/20/weex/">Weex</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/19/vue/">Vue</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/10/suan-fa/">排序算法</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>android (9)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (10)</a></li>
<li class='category'><a href='/blog/categories/java/'>java (6)</a></li>
<li class='category'><a href='/blog/categories/javascript/'>javascript (4)</a></li>
<li class='category'><a href='/blog/categories/other/'>other (5)</a></li>
<li class='category'><a href='/blog/categories/react/'>react (8)</a></li>

  </ul>
</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - guimingsu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
