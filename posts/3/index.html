
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>阿贵</title>
  <meta name="author" content="guimingsu">

  
  <meta name="description" content="MyBatis 的使用 Nov 14th, 2016 7:26 pm Mybatis是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andyfightting.github.io/posts/3/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="阿贵" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">  -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

<script>
  function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
    });
  }
  $(document).bind('DOMNodeInserted', function(event) {
    addBlankTargetForLinks();
  });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">阿贵</a></h1>
  
    <h2>confidence comes from preparation</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andyfightting.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/14/mybatis/">MyBatis 的使用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-14T19:26:25+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>7:26 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Mybatis是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>

<p>需要两个包：<a href="https://github.com/mybatis/mybatis-3/releases">MyBatis包</a>和<a href="https://www.mysql.com/products/connector/">JDBC Driver for MySQL</a></p>

<p>无论是用过的mybatis和hibernate他们的共同点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1.从配置文件(通常是XML配置文件中)得到sessionfactory
</span><span class='line'>2.由sessionfactory产生session
</span><span class='line'>3.在session中完成对数据的增删改查和事务提交等
</span><span class='line'>4.在用完之后关闭session 
</span><span class='line'>5.在java 对象和数据库之间有mapping的配置文件，也通常是xml文件</span></code></pre></td></tr></table></div></figure>


<p>主要XML配置文件中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源和决定事务范围和控制方式的事务管理器。通过加载该文件获取SqlSessionFactory。</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;!--对象别名定义 --&gt;
    &lt;typeAliases&gt;
        &lt;typeAlias alias="User" type="com.sgm.java.User" /&gt;
    &lt;/typeAliases&gt;

&lt;!--数据库连接 --&gt;
&lt;environments default="development"&gt;
    &lt;environment id="development"&gt;
        &lt;transactionManager type="JDBC" /&gt;
        &lt;dataSource type="POOLED"&gt;
            &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt;
            &lt;property name="url" value="jdbc:mysql://localhost:8889/java_db" /&gt;
            &lt;property name="username" value="root" /&gt;
            &lt;property name="password" value="root" /&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;

&lt;!--数据库操作映射文件 --&gt;
&lt;mappers&gt;
    &lt;mapper resource="com/sgm/mybatis/User.xml" /&gt;
&lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>

<p>数据库操作映射文件</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;!--namespace很重要，绑定对应的接口文件！--&gt;
&lt;mapper namespace="com.sgm.java.UserDao"&gt;

&lt;resultMap type="User" id="resultListUser"&gt;
    &lt;result column="name" property="name" /&gt;
    &lt;result column="age" property="age" /&gt;
&lt;/resultMap&gt;

&lt;!--id名字要和UserDao里的方法名一样  --&gt;
&lt;insert id="addUser" parameterType="User" useGeneratedKeys="true" keyProperty="id"&gt;
    insert into user(name, age) values(#{name}, #{age});
&lt;/insert&gt;

&lt;delete id="deleteUserById" parameterType="int"&gt;
    delete from user where id = #{id};
&lt;/delete&gt;

&lt;update id="updateUser" parameterType="User" &gt;
     update user set name = #{name}, age = #{age} where id = #{id};
&lt;/update&gt;

&lt;select id="getAllUsers" resultMap="resultListUser"&gt;
    select * from user ;
&lt;/select&gt;

&lt;select id="selectUserById" parameterType="int" resultType="User"&gt;
   select * from user where id = #{id};
&lt;/select&gt;
&lt;/mapper&gt;
</code></pre>

<p>定义数据库操作接口，方法要和对应的映射文件里的id名称一样！</p>

<pre><code>public interface UserDao {
    //  方法名要和User.xml配置文件里的id名称一样
    public void addUser(User user);

    public void deleteUserById(int id);

    public void updateUser(User user);

    public List&lt;User&gt; getAllUsers();

    public User selectUserById(int id);
}
</code></pre>

<p>操作的Java对象</p>

<pre><code>public class User {
        public int id;
        public String name;
        public int age;

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre>

<p>测试</p>

<pre><code>public class Main {
    private static Reader reader;
    private static SqlSessionFactory sqlSessionFactory;

static {
    try {
        reader = Resources.getResourceAsReader("MyBatisConfig.xml");
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public static void main(String[] args) {
    SqlSession session = sqlSessionFactory.openSession();
    UserDao userDao = session.getMapper(UserDao.class);

    try {
//          // 增
//          User newUser = new User();
//          newUser.setName("andy");
//          newUser.setAge(20);
//          userDao.addUser(newUser);
//          session.commit();//必须提交
//          System.out.println("reult------： 新增的userId " + newUser.getId());    
//          //删
//          userDao.deleteUserById(1);
//          session.commit();//必须提交

//          //改
//          User updateUser = new User();
//          updateUser.setId(4);
//          updateUser.setName("andy");
//          updateUser.setAge(20);
//          userDao.updateUser(updateUser);
//          session.commit();//必须提交

//          //列表
//          List&lt;User&gt; userList = userDao.getAllUsers();
//          for(User user : userList){
//              System.out.println("reult------：  " + user.getName());            
//          }
            //查单个
//          User user = userDao.selectUserById(4);
//          System.out.println("reult------：  " + user.getName());
        } finally {
            session.close();//必须关闭
        }
    }
}
</code></pre>

<h3>传参方式</h3>

<h5>1.用下标获取</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//Dao层接口定义
</span><span class='line'>public User selectUser(String name,String password);
</span><span class='line'>//对应的映射方法,用下标获取
</span><span class='line'>&lt;select id="selectUser" resultMap="userList"&gt;
</span><span class='line'>    select  *  from user where name = #{0} and password=#{1}
</span><span class='line'>&lt;/select&gt;
</span><span class='line'>//定义userList
</span><span class='line'>&lt;resultMap type="User" id="userList"&gt;
</span><span class='line'>  &lt;result column="id" property="id" /&gt;
</span><span class='line'>  &lt;result column="name" property="name" /&gt;
</span><span class='line'>  &lt;result column="password" property="password" /&gt;
</span><span class='line'>&lt;/resultMap&gt;</span></code></pre></td></tr></table></div></figure>


<h5>2.传自定义对象</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void updateUser(User user);
</span><span class='line'>&lt;update id="updateUser" parameterType="User"&gt;
</span><span class='line'>  update user set name = #{name}, password = #{password} where id = #{id};
</span><span class='line'>&lt;/update&gt;
</span><span class='line'>//定义User别名
</span><span class='line'>&lt;typeAliases&gt;
</span><span class='line'>  &lt;typeAlias alias="User" type="com.sgm.bean.User" /&gt;
</span><span class='line'>&lt;/typeAliases&gt;</span></code></pre></td></tr></table></div></figure>


<h5>3.用注解的方式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public User selectUser(@Param("name")String name,@Param("password")String password);
</span><span class='line'>&lt;select id="selectUser" resultType="User"&gt;
</span><span class='line'>  select * from user where name = #{name} and password = #{password};
</span><span class='line'>&lt;/select&gt;</span></code></pre></td></tr></table></div></figure>


<h4>动态SQL语句</h4>

<pre><code>&lt;select id="selectSameAddressUser" parameterType="User" resultType="userList"&gt;
    select * from user 
        &lt;if test="name != null"&gt;
            title = #{name}
        &lt;/if&gt;
        &lt;if test="address != null"&gt;
            and address = #{address}
        &lt;/if&gt;
&lt;/select&gt;
</code></pre>

<h3>注意!</h3>

<h5>SqlSessionFactoryBuilder</h5>

<p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围,也就是局部方法变量。可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p>

<h5>SqlSessionFactory</h5>

<p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次。因此 SqlSessionFactory 的最佳范围是应用范围。可以使用单例模式或者静态单例模式。</p>

<h5>SqlSession</h5>

<p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的范围是请求或方法范围。不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。每次操作应该打开一个 SqlSession，处理数据，处理完后就关闭它。关闭操作很重要，应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SqlSession session = sqlSessionFactory.openSession();
</span><span class='line'>try {
</span><span class='line'>  // do work
</span><span class='line'>} finally {
</span><span class='line'>  session.close();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


      | <a href="/blog/2016/11/14/mybatis/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/11/android-select-photo/">Android 一行代码选取图片</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-11T19:31:33+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>7:31 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一行代码模仿iOS的选取图片效果。思路主要是把相机和相册的回调放在一个透明的Activity里，然后在这个透明的Activity中弹出自定义的ActionSheet选择框，选取调相机还是相册。相机比较简单，直接调系统的。相册就不用系统的了，不同手机差别太大，效果也不好。自己遍历本地图片文件然后显示。这样即时在不同手机上也能展示相同的效果了。封装后使用就简单了，一行代码调用就可以，不会和业务Activity耦合了！</p>

<h4>使用:</h4>

<p>1.选取一张正方形图片</p>

<pre><code>   SelectPhotoSheet.showCropImageSheet(this, new AlbumResultListener() {
            @Override
            public void complete(View tapedView, List&lt;String&gt; pathList) {
                cache.displayBmp(headImageView, pathList.get(0), new Point(100, 100));
            }
        });
</code></pre>

<p>2.选取限制数量的全尺寸图片</p>

<pre><code>SelectPhotoSheet.showFullImageSheet(this, 8, new AlbumResultListener() {
            @Override
            public void complete(View tapedView, List&lt;String&gt; pathList) {
                localPathList.clear();
                localPathList.addAll(pathList);
                adapter.notifyDataSetChanged();
            }
        });
</code></pre>

<p><img src="/myimg/android/one_select.png" alt="" /></p>

<h4>实现</h4>

<p>1.自定义ActionSheet，弄一个Sheet的工具类 BaseSheetActivity。</p>

<pre><code>//用作弹出 action sheet 效果的 base activity
public class BaseSheetActivity extends Activity {
    protected int activityCloseEnterAnimation;
    protected int activityCloseExitAnimation;

public static ItemTapListener itemTapListener;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);

    TypedArray activityStyle = getTheme().obtainStyledAttributes(new int[] {android.R.attr.windowAnimationStyle});
    int windowAnimationStyleResId = activityStyle.getResourceId(0, 0);
    activityStyle.recycle();

    activityStyle = getTheme().obtainStyledAttributes(windowAnimationStyleResId, new int[] {android.R.attr.activityCloseEnterAnimation, android.R.attr.activityCloseExitAnimation});
    activityCloseEnterAnimation = activityStyle.getResourceId(0, 0);
    activityCloseExitAnimation = activityStyle.getResourceId(1, 0);
    activityStyle.recycle();
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    dismiss();
    if (itemTapListener != null){
        itemTapListener.itemTap(new View(this),"");
    }
    return super.onTouchEvent(event);
}

@Override
public void finish() {
    dismiss();
}

public void dismiss(){
    super.finish();
    overridePendingTransition(activityCloseEnterAnimation, activityCloseExitAnimation);
}

public static void show(Context context, Class showedActivityClass, ItemTapListener itemTapListener){
    BaseSheetActivity.itemTapListener = itemTapListener;
    Intent intent = new Intent(context,showedActivityClass);
    context.startActivity(intent);
}
}
</code></pre>

<p>  要使用ActionSheet的效果话就是继承它，然后theme选择ActionSheetTheme。然后把界面的布局从bottom开始布局。</p>

<pre><code>  public class PhotoSheet extends BaseSheetActivity {

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.action_photo_sheet); //action_photo_sheet的布局从bottom开始

}

public void itemTap(View view){
    dismiss();
    if (itemTapListener != null){
        itemTapListener.itemTap(view,"");
    }
}

@Override
public void onBackPressed() {
    dismiss();
    if (itemTapListener != null){
        itemTapListener.itemTap(new View(this),"");
    }
}
}

   //设置为自定义的样式
 &lt;activity
        android:name=".photo_lib.photo.PhotoSheet"
        android:theme="@style/ActionSheetTheme" /&gt;
</code></pre>

<p>2.读图片文件路径，不单单是相册里的图片</p>

<pre><code>public void getLocalImages() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                Uri mImageUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
                ContentResolver mContentResolver = AlbumDirActivity.this.getContentResolver();

            Cursor mCursor = mContentResolver.query(
                    mImageUri,
                    null,
                    MediaStore.Images.Media.MIME_TYPE + "=? or " + MediaStore.Images.Media.MIME_TYPE + "=? or " + MediaStore.Images.Media.MIME_TYPE + "=?",
                    new String[]{"image/jpeg", "image/png", "image/jpg"},
                    MediaStore.Images.Media.DATE_MODIFIED);

            while (mCursor.moveToNext()) {
                String path = mCursor.getString(mCursor.getColumnIndex(MediaStore.Images.Media.DATA));
                String parentName = new File(path).getParentFile().getName();

                if (!dirMap.containsKey(parentName)) {
                    List&lt;String&gt; chileList = new ArrayList&lt;&gt;();
                    chileList.add(path);
                    dirMap.put(parentName, chileList);
                } else {
                    dirMap.get(parentName).add(path);
                }
            }
            mCursor.close();
            mHandler.sendEmptyMessage(SCAN_OK);
        }
    }).start();
}
</code></pre>

<p>3.用LruCache缓存显示压缩后的图片</p>

<pre><code>public class LocalImageCache {

private static LocalImageCache mInstance;

private Handler mHander = new Handler();
private LruCache&lt;String, Bitmap&gt; mMemoryCache;
private CacheImageCallBack mCallBack;
private ExecutorService mImageThreadPool = Executors.newFixedThreadPool(5);

private LocalImageCache() {
    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
    final int cacheSize = maxMemory / 5;

    mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {
        @Override
        protected int sizeOf(String key, Bitmap bitmap) {
            return bitmap.getByteCount()/1024;
        }
    };

    mCallBack = new CacheImageCallBack() {
        @Override
        public void onImageLoader(ImageView imageView, Bitmap bitmap) {
            if (bitmap != null &amp;&amp; imageView != null) {
                imageView.setImageBitmap(bitmap);
            }
        }
    };
}

public static LocalImageCache getInstance() {
    synchronized (LocalImageCache.class) {
        if (mInstance == null) {
            mInstance = new LocalImageCache();
        }
        return mInstance;
    }
}

public static void clearCache() {
    LocalImageCache cache = getInstance();
    cache.mMemoryCache.evictAll();
}

public void displayBmp(final ImageView imageView, final String path, final Point mPoint) {
    if (TextUtils.isEmpty(path) || imageView == null) {
        return;
    }

    Bitmap bitmap = getBitmapFromMemCache(path);
    if (bitmap == null) {
        imageView.setImageBitmap(null);

        mImageThreadPool.execute(new Runnable() {
            Bitmap mBitmap;

            @Override
            public void run() {
                mBitmap = decodeThumbBitmapForFile(path, mPoint == null ? 0 : mPoint.x, mPoint == null ? 0 : mPoint.y);
                mHander.post(new Runnable() {
                    @Override
                    public void run() {
                        mCallBack.onImageLoader(imageView, mBitmap);
                    }
                });
                addBitmapToMemoryCache(path, mBitmap);
            }
        });
    } else {
        imageView.setImageBitmap(bitmap);
    }
}

private void addBitmapToMemoryCache(String key, Bitmap bitmap) {
    if (getBitmapFromMemCache(key) == null &amp;&amp; bitmap != null) {
        mMemoryCache.put(key, bitmap);
    }
}

private Bitmap getBitmapFromMemCache(String key) {
    return mMemoryCache.get(key);
}

private Bitmap decodeThumbBitmapForFile(String path, int viewWidth, int viewHeight) {
    BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeFile(path, options);
    options.inSampleSize = computeScale(options, viewWidth, viewHeight);
    options.inJustDecodeBounds = false;

    return BitmapFactory.decodeFile(path, options);
}

private int computeScale(BitmapFactory.Options options, int viewWidth, int viewHeight) {
    int inSampleSize = 1;
    if (viewWidth == 0 || viewHeight == 0) {
        return inSampleSize;
    }
    int bitmapWidth = options.outWidth;
    int bitmapHeight = options.outHeight;

    if (bitmapWidth &gt; viewWidth || bitmapHeight &gt; viewHeight) {
        int widthScale = Math.round((float) bitmapWidth / (float) viewWidth);
        int heightScale = Math.round((float) bitmapHeight / (float) viewHeight);

        inSampleSize = (widthScale+heightScale)/2;
    }
    return inSampleSize;
}


private interface CacheImageCallBack {
    void onImageLoader(ImageView imageView, Bitmap bitmap);
}
}
</code></pre>

<p>4.用DrawerLayout封装了一个手势返回的基础类</p>

<pre><code>public class BaseSwipeActivity extends AppCompatActivity {

private LinearLayout containerLayout;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    initSwipeView();
}

@Override
protected void onDestroy() {
    super.onDestroy();
}

private void initSwipeView() {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    setContentView(R.layout.activity_base_swipe);

    containerLayout = (LinearLayout) findViewById(R.id.container_layout);

    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.base_drawer_layout);
    drawer.openDrawer(GravityCompat.END);
    ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawer, R.string.navigation_drawer_open, R.string.navigation_drawer_close) {
        @Override
        public void onDrawerClosed(View drawerView) {
            super.onDrawerClosed(drawerView);
            finish();
        }
    };
    drawer.addDrawerListener(toggle);
}

//子类要手势返回就用setMainView!!!!
public void setMainView(int viewId) {
    LayoutInflater inflater = LayoutInflater.from(this);
    View tmpView = inflater.inflate(viewId, null);

    if (tmpView instanceof LinearLayout) {
        LinearLayout.LayoutParams linearLayoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(linearLayoutParams);
    } else if (tmpView instanceof RelativeLayout) {
        RelativeLayout.LayoutParams relativeLayoutParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(relativeLayoutParams);
    }
    containerLayout.removeAllViews();
    containerLayout.addView(tmpView);
}

public void backViewTap(View v) {

}

public void backImageTap(View v) {
    finish();
}
}
</code></pre>

<p>其他Activity需要手势返回的话就继承它，然后使用setMainView()替代setContentView()设置界面布局，其他什么都不用管啦！</p>

<h4>注意</h4>

<p>要在使用的Activity的onDestroy()方法中调用 FileUtil.deleteAllFile(); 清除选取的临时缓存图片！！！</p>

<p><a href="https://github.com/AndyFightting/SelectPhoto_Android">下载</a></p>
</div>
  
  


      | <a href="/blog/2016/11/11/android-select-photo/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/12/link-bug/">iOS Not Found for Architecture Arm64</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-12T10:00:18+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>接手维护一个项目，更新一下出现了下面这问题👇
<img src="/myimg/ios/arm64.png" alt="image" /></p>

<p>好像不常见的问题，谷歌一下</p>

<p><a href="http://stackoverflow.com/questions/19213782/undefined-symbols-for-architecture-arm64">Stack Overflow</a>
<img src="/myimg/ios/stackoverflow.png" alt="image" /></p>

<p>说是Architectures设置问题&hellip; 说是Other Linker Flags问题&hellip;说是Target Membership问题&hellip; 改了好像都没用啊，问题还是一动不动的出现在那里&hellip;
<img src="/myimg/ios/targetMap.png" alt="image" /></p>

<p>继续找找找&hellip;用对应的类文件全局搜一下&hellip;诶~ 好像那里不对啊&hellip;路径怎么这样子??怎么和别的不一样~~ 喜出望外，好像知道原因了，果然项目文件夹里看不到该文件，Add Files to &ldquo;XXX"添加文件!
<img src="/myimg/ios/errorLoad.png" alt="image" /></p>

<p>还是不行&hellip;把对应的.h .m文件拖到桌面上，再重新添加到项目里，解决了！！为什么一开始不怀疑是文件索引问题呢？ 因为项目编译没报 XXX.h not found &hellip;以为文件都好好的呢，以为是项目的配置问题&hellip; 所以一开始找问题的方向就跑偏了！其实这问题之前也遇到过，一般是第三方的XXX.a文件出现这问题，只是这次脑袋没长记性&hellip;这问题一般是多人开发项目用SVN更来更去导致的<code>project.pbxproj</code>里对应的文件索引没了。好了，再遇到这问题就不要跑偏了，把对应的文件重新添加就可以了！！</p>
</div>
  
  


      | <a href="/blog/2016/09/12/link-bug/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/08/okhttp-retrofit/">OkHttp and Retrofit</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-08T14:57:19+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:57 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://square.github.io/okhttp/">OkHttp</a>和<a href="http://square.github.io/retrofit/">Retrofit</a>都是<a href="http://square.github.io/">Square</a>公司开源出来的网络请求框架。Retrofit是对OkHttp的封装，使其可以用注解的方式调用。</p>

<h4>OkHttp</h4>

<pre><code>//-----okhttp 网络请求 工具类-----

//异步请求结果放在主线程回调。
private static final Handler mainHandler = new Handler(Looper.getMainLooper()); 

private static final OkHttpClient client = new OkHttpClient.Builder()
        .connectTimeout(10, TimeUnit.SECONDS)
        .writeTimeout(10, TimeUnit.SECONDS)
        .readTimeout(10, TimeUnit.SECONDS)
        .build();

public static void getRequest(String url, final OkHttpListener listener) {
    Request request = new Request.Builder()
            .header("token", getUserToken())
            .header("client", "Android")
            .header("versionCode", getVersionCode())
            .header("versionName", getVersionName())
            .url(url)
            .build();
    beginRequest(request, listener);
}

//这样就不会有中文乱码问题
public static void postRequest(String url, final Map&lt;String, String&gt; params, final OkHttpListener listener) {
    StringBuilder stringBuilder = new StringBuilder("");
    if (params != null) {
        Set&lt;String&gt; keys = params.keySet();
        for (String key : keys) {
            String value = params.get(key);
            stringBuilder.append(key + "=" + value + "&amp;");
        }
    }

    MediaType mediaType = MediaType.parse("application/x-www-form-urlencoded;charset=utf-8");
    RequestBody body = RequestBody.create(mediaType, stringBuilder.toString());

    Request request = new Request.Builder()
            .header("token", getUserToken())
            .header("client", "Android")
            .header("versionCode", getVersionCode())
            .header("versionName", getVersionName())
            .url(url)
            .post(body)
            .build();

    beginRequest(request, listener);
}

//可添加图片文件
public static void postMutibleRequest(String url, final Map&lt;String, Object&gt; params, final OkHttpListener listener) {
    MultipartBody.Builder multipleBuilder = new MultipartBody.Builder();
    multipleBuilder.setType(MultipartBody.FORM);

    if (params != null) {
        Set&lt;String&gt; keys = params.keySet();
        for (String key : keys) {
            Object obj = params.get(key);

            if (obj instanceof File) {
                File tmpFile = (File) obj;
                multipleBuilder.addFormDataPart(key, tmpFile.getName(), MultipartBody.create(MediaType.parse("image/jpg"), tmpFile));
            } else {
                multipleBuilder.addPart(Headers.of("Content-Disposition", "form-data; name=\"" + key + "\""), RequestBody.create(null, (String) obj));
            }
        }
    }

    RequestBody multipleBody = multipleBuilder.build();
    Request request = new Request.Builder()
            .header("token", getUserToken())
            .header("client", "Android")
            .header("versionCode", getVersionCode())
            .header("versionName", getVersionName())
            .url(url)
            .post(multipleBody)
            .build();

    beginRequest(request, listener);
}

//保存网络图片到相册,返回本地存储路径
public static void downloadImageToSysPhoto(String imageUrl, final OkHttpListener listener) {
    Request request = new Request.Builder().url(imageUrl).build();
    Call call = client.newCall(request);
    call.enqueue(new Callback() {
        @Override
        public void onResponse(Call call, Response response) throws IOException {
            try {
                //系统相册路径
                final String localPath = "/storage/emulated/0/DCIM/Camera/" + CommonUtil.getUniqueString(10) + ".jpg";

                InputStream is = response.body().byteStream();
                FileOutputStream fos = new FileOutputStream(localPath);
                byte[] buffer = new byte[1024];

                int len;
                while ((len = is.read(buffer)) != -1) {
                    fos.write(buffer, 0, len);
                }
                is.close();
                fos.close();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.success(localPath);
                        }
                    }
                });
            } catch (Exception e) {
                e.printStackTrace();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.fail(0, "");
                        }
                    }
                });
            }
        }

        @Override
        public void onFailure(Call call, IOException e) {
            mainHandler.post(new Runnable() {
                @Override
                public void run() {
                    if (listener != null) {
                        listener.fail(0, "");
                    }
                }
            });
        }
    });
}

private static void beginRequest(Request request, final OkHttpListener listener) {
    Call call = client.newCall(request);

    call.enqueue(new Callback() {//enqueue是异步请求
        @Override
        public void onResponse(Call call, Response response) throws IOException {
            final String responseString = response.body().string();
            final int code = response.code();

            if (response.isSuccessful()) {
                CommonUtil.logJson(responseString);

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.success(responseString);
                        }
                    }
                });
            } else {
                //请求失败：    400  ---------   {"code":100004,"msg":"手机号已注册"}
                CommonUtil.logString("请求失败：" + code + "---------" + responseString);
                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.fail(code, responseString);
                        }
                    }
                });
            }
        }

        @Override
        public void onFailure(Call call, IOException e) {
            e.printStackTrace();
            CommonUtil.logString("请求错误");
            mainHandler.post(new Runnable() {
                @Override
                public void run() {
                    if (listener != null) {
                        listener.fail(0, "请求失败");
                    }
                }
            });
        }
    });
}

public static String getFailedMsg(String response) {
    try {
        JSONObject jsonObject = new JSONObject(response);
        return jsonObject.getString("msg");
    } catch (Exception e) {
        e.printStackTrace();
    }
    return "请求失败";
}

public static String getUserToken() {
    UserModel userModel = UserModel.getUser();
    if (userModel != null) {
        return userModel.getToken();
    }
    return "";
}

public static String getVersionCode() {
    try {
        PackageInfo pi = application.getPackageManager().getPackageInfo(application.getPackageName(), 0);
        return pi.versionCode + "";
    } catch (Exception e) {
        e.printStackTrace();
    }
    return "";
}

public static String getVersionName() {
    try {
        PackageInfo pi = application.getPackageManager().getPackageInfo(application.getPackageName(), 0);
        return pi.versionName;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return "";
}

//下载apk安装包，HUD是自定义的等待进度条
private static int apkProgress;
public static void downloadAPK(final Context context, String apkUrl) {
    HUD.show(context, "下载中...");
    HUD.setCancelable(false);

    Request request = new Request.Builder().url(apkUrl).build();
    Call call = client.newCall(request);
    call.enqueue(new Callback() {
        @Override
        public void onResponse(Call call, Response response) throws IOException {
            try {
                FileUtil.createDir();//创建  ~/paiqi/ 文件夹
                final String apkLocalPath = FileUtil.DIR_PATH + "paiqi.apk";

                InputStream is = response.body().byteStream();
                FileOutputStream fos = new FileOutputStream(apkLocalPath);
                int readNum;
                byte[] buffer = new byte[1024];

                int progressCount = 0;
                long totalLength = response.body().contentLength();

                while ((readNum = is.read(buffer)) != -1) {
                    progressCount += readNum;
                    apkProgress = (int) (((float) progressCount / totalLength) * 100);

                    mainHandler.post(new Runnable() {
                        @Override
                        public void run() {
                            HUD.setMessage("下载中 " + apkProgress + "%");
                        }
                    });

                    fos.write(buffer, 0, readNum);
                }
                is.close();
                fos.close();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        HUD.dismiss();
                        installAPK(context, apkLocalPath);
                    }
                });
            } catch (Exception e) {
                e.printStackTrace();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        HUD.dismiss();
                        CommonUtil.showToast("下载失败");
                    }
                });
            }
        }

        @Override
        public void onFailure(Call call, IOException e) {
            mainHandler.post(new Runnable() {
                @Override
                public void run() {
                    HUD.dismiss();
                    CommonUtil.showToast("下载失败");
                }
            });
        }
    });
}

//安装apk
private static void installAPK(Context context, String apkPath) {
    File apkFile = new File(apkPath);
    if (!apkFile.exists()) {
        CommonUtil.showToast("安装失败");
        return;
    }
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setDataAndType(Uri.parse("file://" + apkFile.toString()), "application/vnd.android.package-archive");
    context.startActivity(intent);
} 

//请求回调接口定义
public interface OkHttpListener {
   void success(String response);
   void fail(int code,String response);
}
</code></pre>

<p>要注意的是enqueue方法是异步请求，所以要把结果回调放在主线程中进行。</p>

<pre><code> mainHandler.post(new Runnable() {
                        @Override
                        public void run() {
                            if (listener != null) {
                                listener.success(responseString);
                            }
                        }
                    });
</code></pre>

<p>之前看过一个同事的网络库封装，把网络回调接口放在BaseActivity里，然后在子Activity里重写回调方法！这样导致的结果就是，Fragment里的请求都要通过Activity来重写方法，然后再转发给Fragment&hellip;简直想骂街啊有木有！下面这样调用是不是很简单呢~!</p>

<pre><code>//get异步请求,回调都已放在主线程中
 OkHttpHelper.getRequest(ulr, new OkHttpListener() {
        @Override
        public void success(String response) {

        }

        @Override
        public void fail() {

        }
    });

   //post异步请求，回调都已放在主线程中，也可以用于提交File
    Map&lt;String, Object&gt; paramter = new HashMap&lt;&gt;();
    paramter.put("name", "阿贵");
    paramter.put("file", new File("filePath"));//提交图片文件

    OkHttpHelper.postRequest(url, paramter, new OkHttpListener() {
        @Override
        public void success(String response) {

        }

        @Override
        public void fail() {

        }
    });
</code></pre>

<p>还有很多人喜欢把网络请求和结果解析写在一起，比如通过请求结果直接得到对应的Bean。这样导致的结果就是网球请求结果类型不统一，返回各种Bean。个人不太喜欢这样，可以对结果解析进行简单封装一下，这样网络返回的结果也会统一，数据解析也就一行代码。</p>

<pre><code>//使用: getBean(json, User.class);
public static &lt;T&gt; T getBean(String json, Class&lt;T&gt; clazz) {
    T bean = null;
    try {
        Gson gson = new Gson();
        bean = gson.fromJson(json, clazz);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return bean;
}

   //使用：getBeanList(json, User[].class);
    public static &lt;T&gt; List&lt;T&gt; getBeanList(String json, Class&lt;T[]&gt; type) {
        try{
            T[] list = new Gson().fromJson(json, type);
            return Arrays.asList(list);
        }catch (Exception e){
            e.printStackTrace();
            return null;
        }
    }
</code></pre>

<h4>Retrofit</h4>

<p><a href="http://square.github.io/retrofit/">Retrofit官网</a>上的例子中返回结果是Bean，但又没说添加了GsonConverterFactory，所以会报 Could not locate ResponseBody converter for XXBean 错误！所以要引入GsonConverterFactory转化库<code>compile 'com.squareup.retrofit2:converter-gson:2.0.2'</code>, 然后在Retrofit初始化的时候添加该库！官网后面说了 By default, Retrofit can only deserialize HTTP bodies into OkHttp&rsquo;s ResponseBody type and it can only accept its RequestBody type for @Body. 默认只会返回ResponseBody！并且只有ResponseBody才可以使用@Body注解！我个人还是不喜欢直接在这里得到Bean, 我还是喜欢先通过得到response.body().string()，然后再转化成Bean，各司其职。注意是<code>response.body().string()</code>，不是<code>response.body().toString()</code>!!</p>

<pre><code>    Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://api.github.com/")
                .addConverterFactory(GsonConverterFactory.create()) //添加Bean转化库
                .build();

    ServiceInterface service = retrofit.create(ServiceInterface.class);

    Call&lt;TestBean&gt; requestCall = service.getUserInfo();

    requestCall.enqueue(new Callback&lt;TestBean&gt;() {
        @Override
        public void onResponse(Call&lt;TestBean&gt; call, Response&lt;TestBean&gt; response) {

                TestBean b = response.body();
        }

        @Override
        public void onFailure(Call&lt;TestBean&gt; call, Throwable t) {

        }
    });

 public interface ServiceInterface {
    @GET("users/andyfightting")
    Call&lt;TestBean&gt; getUserInfo();

    //这里继续添加其他接口

}
</code></pre>
</div>
  
  


      | <a href="/blog/2016/09/08/okhttp-retrofit/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/07/asynctask/">Android中的AsyncTask</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-07T10:15:12+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:15 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Android和iOS一样，对UI的操作只能放在主线程中进行，即UI线程。如果在UI线程中执行比较耗时的方法，就会造成界面卡顿假死无反应，所以应该把耗时操作放在<code>非UI线程</code>中处理，处理完成后再在<code>UI线程</code>中更新界面。</p>

<p>在没有AsyncTask类的时候，是通过在子线程处理，然后sendMessage(Message msg)给主线程中创建的Handler,然后在主线程中实现handleMessage(Message msg)处理相应信息。而这些工作AsyncTask帮我们做了，AsyncTask就是对Thread和Handler的封装。</p>

<h4>AsyncTask使用</h4>

<p>AsyncTask是一个抽象类，所以必须创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个参数类型,这三个类型会影响重写方法对应的参数类型。</p>

<ol>
<li>Params: 在execute()启动任务时需要传入的参数</li>
<li>Progress: 后台任务执行过程中，需要实时反馈出来的信息，比如执行进度什么的</li>
<li>Result: 后台任务执行完毕后，如果需要对结果进行返回，则返回该类型</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//on开通的方法都是在UI线程中执行的
</span><span class='line'>class MyAsyncTask extends AsyncTask&lt;Void,Integer,Boolean&gt;{
</span><span class='line'>    @Override
</span><span class='line'>    protected void onPreExecute() {//在执行实际的后台的doInBackground方法前
</span><span class='line'>        super.onPreExecute();
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    @Override
</span><span class='line'>    protected Boolean doInBackground(Void... params) {//在onPreExecute 方法执行后马上执行，该方法运行在后台线程中
</span><span class='line'>        for (int i = 0; i &lt;= 100; i++) {
</span><span class='line'>            publishProgress(i);//调用onProgressUpdate
</span><span class='line'>            try {
</span><span class='line'>                Thread.sleep(1000);
</span><span class='line'>            } catch (InterruptedException e) {
</span><span class='line'>                e.printStackTrace();
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return true;//可以判断是否顺利执行完了啊
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void onProgressUpdate(Integer... values) {//这个函数在doInBackground调用publishProgress时被调用后
</span><span class='line'>        super.onProgressUpdate(values);
</span><span class='line'>        //比如实时更新进度条
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void onPostExecute(Boolean aBoolean) {
</span><span class='line'>        super.onPostExecute(aBoolean);
</span><span class='line'>        //后台顺利执行完后要干啥呢
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void onCancelled() {
</span><span class='line'>        super.onCancelled();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<ol>
<li>Task的实例必须在UI 线程中创建</li>
<li>execute方法必须在UI 线程中调用</li>
<li>不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params&hellip;)等方法</li>
<li>该task只能被执行一次，否则多次调用时将会抛出异常</li>
</ol>


<h4>AsyncTask源码</h4>

<p>AsyncTask有个handler内部类，用它来处理在主线程中实时更新和任务完成后的回调</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private static InternalHandler sHandler;
</span><span class='line'>
</span><span class='line'>private static Handler getHandler() {
</span><span class='line'>    synchronized (AsyncTask.class) {
</span><span class='line'>        if (sHandler == null) {
</span><span class='line'>            sHandler = new InternalHandler();
</span><span class='line'>        }
</span><span class='line'>        return sHandler;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private static class InternalHandler extends Handler {
</span><span class='line'>    public InternalHandler() {
</span><span class='line'>        super(Looper.getMainLooper());
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @SuppressWarnings({"unchecked", "RawUseOfParameterizedType"})
</span><span class='line'>    @Override
</span><span class='line'>    public void handleMessage(Message msg) {
</span><span class='line'>        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;
</span><span class='line'>        switch (msg.what) {
</span><span class='line'>            case MESSAGE_POST_RESULT:
</span><span class='line'>                // There is only one result
</span><span class='line'>                result.mTask.finish(result.mData[0]);
</span><span class='line'>                break;
</span><span class='line'>            case MESSAGE_POST_PROGRESS:
</span><span class='line'>                result.mTask.onProgressUpdate(result.mData);
</span><span class='line'>                break;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>当我们调用publishProgress方法时，就是得到handler单列然后发消息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   protected final void publishProgress(Progress... values) {
</span><span class='line'>        if (!isCancelled()) {
</span><span class='line'>            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,
</span><span class='line'>                    new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>   private static class AsyncTaskResult&lt;Data&gt; {
</span><span class='line'>        final AsyncTask mTask;
</span><span class='line'>        final Data[] mData;
</span><span class='line'>
</span><span class='line'>     AsyncTaskResult(AsyncTask task, Data... data) {
</span><span class='line'>            mTask = task;
</span><span class='line'>            mData = data;
</span><span class='line'>        }
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>当执行execute()方法时，会在后台任务doInBackground(mParams)开始执行前调用onPreExecute方法。从下面可以看出，当task已经在运行或者已经结束的时候不可以再调用execute()方法，否则会报错。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {
</span><span class='line'>        return executeOnExecutor(sDefaultExecutor, params);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>  public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
</span><span class='line'>            Params... params) {
</span><span class='line'>        if (mStatus != Status.PENDING) {
</span><span class='line'>            switch (mStatus) {
</span><span class='line'>                case RUNNING:
</span><span class='line'>                    throw new IllegalStateException("Cannot execute task:"
</span><span class='line'>                            + " the task is already running.");
</span><span class='line'>                case FINISHED:
</span><span class='line'>                    throw new IllegalStateException("Cannot execute task:"
</span><span class='line'>                            + " the task has already been executed "
</span><span class='line'>                            + "(a task can be executed only once)");
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        mStatus = Status.RUNNING;
</span><span class='line'>
</span><span class='line'>        onPreExecute(); //后台任务开始前执行
</span><span class='line'>
</span><span class='line'>        mWorker.mParams = params;
</span><span class='line'>        exec.execute(mFuture);
</span><span class='line'>
</span><span class='line'>        return this;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>     mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
</span><span class='line'>            public Result call() throws Exception {
</span><span class='line'>                mTaskInvoked.set(true);
</span><span class='line'>
</span><span class='line'>                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
</span><span class='line'>                //noinspection unchecked
</span><span class='line'>                Result result = doInBackground(mParams);   //这里开始执行后台任务！！！
</span><span class='line'>                Binder.flushPendingCommands();
</span><span class='line'>                return postResult(result);
</span><span class='line'>            }
</span><span class='line'>        };
</span><span class='line'>
</span><span class='line'>        mFuture = new FutureTask&lt;Result&gt;(mWorker) {
</span><span class='line'>            @Override
</span><span class='line'>            protected void done() {
</span><span class='line'>                try {
</span><span class='line'>                    postResultIfNotInvoked(get());    //后台任务执行完毕！！！
</span><span class='line'>                } catch (InterruptedException e) {
</span><span class='line'>                    android.util.Log.w(LOG_TAG, e);
</span><span class='line'>                } catch (ExecutionException e) {
</span><span class='line'>                    throw new RuntimeException("An error occurred while executing doInBackground()",
</span><span class='line'>                            e.getCause());
</span><span class='line'>                } catch (CancellationException e) {
</span><span class='line'>                    postResultIfNotInvoked(null);
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        };
</span><span class='line'>    
</span></code></pre></td></tr></table></div></figure>


<p>后台任务执行完毕时，也是通过handler发消息，然后判断是不是取消状态来调用相应的方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> mFuture = new FutureTask&lt;Result&gt;(mWorker) {
</span><span class='line'>            @Override
</span><span class='line'>            protected void done() {
</span><span class='line'>                try {
</span><span class='line'>                    postResultIfNotInvoked(get());   //后台任务执行完毕！！！
</span><span class='line'>                } catch (InterruptedException e) {
</span><span class='line'>                    android.util.Log.w(LOG_TAG, e);
</span><span class='line'>                } catch (ExecutionException e) {
</span><span class='line'>                    throw new RuntimeException("An error occurred while executing doInBackground()",
</span><span class='line'>                            e.getCause());
</span><span class='line'>                } catch (CancellationException e) {
</span><span class='line'>                    postResultIfNotInvoked(null);
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        };
</span><span class='line'>        
</span><span class='line'>   private void postResultIfNotInvoked(Result result) {
</span><span class='line'>        final boolean wasTaskInvoked = mTaskInvoked.get();
</span><span class='line'>        if (!wasTaskInvoked) {
</span><span class='line'>            postResult(result);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>   private Result postResult(Result result) {
</span><span class='line'>        @SuppressWarnings("unchecked")
</span><span class='line'>        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,
</span><span class='line'>                new AsyncTaskResult&lt;Result&gt;(this, result));
</span><span class='line'>        message.sendToTarget();
</span><span class='line'>        return result;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'> private void finish(Result result) {
</span><span class='line'>        if (isCancelled()) {
</span><span class='line'>            onCancelled(result);
</span><span class='line'>        } else {
</span><span class='line'>            onPostExecute(result);
</span><span class='line'>        }
</span><span class='line'>        mStatus = Status.FINISHED;
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>从下面的代码可以看出，ThreadPoolExecutor是类变量，所以不管创建多少个AsyncTask子类的对象，他们都共用一个线程池。默认线程池可维护的线程数和最大数量，与可用的CUP处理器个数有关。线程池中超过corePoolSize数目的空闲线程最大存活时间1，单位SECONDS。如果线程池的线程数量小于CORE_POOL_SIZE，这个时候新添加一个异步任务则会新建一个线程；如果线程池的数量大于等于CORE_POOL_SIZE，这个时候新建一个异步任务这个任务会被放入缓存队列中等待执行。缓存队列大小为128，并且SerialExecutor是异步顺序执行任务的。</p>

<pre><code>private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE = 1;

private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);

public static final Executor THREAD_POOL_EXECUTOR
        = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);


private static class SerialExecutor implements Executor {
    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        mTasks.offer(new Runnable() {
            public void run() {
                try {
                    r.run();
                } finally {
                    scheduleNext();
                }
            }
        });
        if (mActive == null) {
            scheduleNext();
        }
    }

    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}
</code></pre>

<h4>问题</h4>

<p>AsyncTask处理任务的时候，一般都是习惯在onPreExecute显示进度条，在数据处理完成之后的onPostExecute关闭进度条。但是当横竖屏切换或者内存重启导致Activity重新启动时，假设你还在onPostExecute写了一些其他逻辑，这个时候的AsyncTask已经与之前的Activity没有关联了，会导致onPostExecute无效问题。</p>

<p>解决办法是在onPostExecute方法里用EventBus,Otto类库或者自己写通知，把结果发送给Activity去处理！！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>    protected void onPostExecute(String result) {
</span><span class='line'>        EventBus.getDefault().post(new AsyncTaskResultEvent(result));
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<h4>个人看法</h4>

<p>觉得Android很喜欢造这种中型轮子啊！好像没什么必要再造个AsyncTask这样的轮子放在SDK里啊? 像AsyncTask这种任务不应该是开发者去完成的吗？还有比如NavigationView，真的有必要吗？这不是应该让开发者来自定义的View吗？反正我不是很理解，这可能也是Android为什么如此碎片化的原因之一吧！&mdash;- 喜欢造中型轮子！</p>
</div>
  
  


      | <a href="/blog/2016/09/07/asynctask/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/02/apk-decode/">反编译Android的APK</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-02T09:55:10+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>9:55 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本人用的环境是Mac 10.11.5, 需要用到的工具有：<a href="https://ibotpeaches.github.io/Apktool/">apktool</a>, <a href="https://sourceforge.net/projects/dex2jar/">dex2jar</a>, <a href="http://jd.benow.ca/">JD-GUI</a>。</p>

<p>下面用淘宝2.2.1版本和微信2.3版本为例子来反编译。为什么用这么老的版本？因为可能老版本没有做代码混淆，反编译后会更好看一点。可以用<a href="http://www.anzhi.com/">安智市场</a>来下载历史版本，推荐用安智市场的手机APP来下载，会看到所有的历史版本，而电脑网站只能看到最近的几个历史版本。
<img src="/myimg/android/az_taobao.png" alt="image" /></p>

<h4>1.apktool</h4>

<p>需要至少Java 7环境，通过<code>java -version</code>查看
<img src="/myimg/android/javaVersion.png" alt="image" /></p>

<p>配置apktool
<img src="/myimg/android/apktool.png" alt="image" /></p>

<p>输入apktool如下所示就成功了
<img src="/myimg/android/apktool_result.png" alt="imag" /></p>

<p>用apktool工具处理后就可以查看xml文件了。在桌面建一个文件夹test, 把apk文件放进去，进入该文件夹，然后执行<code>apktool d apk名称.apk</code>。就会在test文件夹里出现一个<code>apk名称</code>的文件夹。里面的资源文件和xml文件就可以打开查看了。
<img src="/myimg/android/apktool1.png" alt="imag" />
<img src="/myimg/android/apktool2.png" alt="imag" />
<img src="/myimg/android/apktool3.png" alt="imag" /></p>

<h4>2.dex2jar</h4>

<p>dex2jar工具可以吧dex或者apk文件转成jar文件。dex2jar下载好后进入文件夹，执行<code>chmod a+x *.sh</code>命令启用.sh文件。</p>

<h6>方式一</h6>

<p>把apk文件的后缀名改为zip，然后解压得到classes.dex文件，把classes.dex文件放到dex2jar文件夹中，进入该文件夹，执行<code>sh d2j-dex2jar.sh classes.dex</code>命令，就会得到对应的jar文件。</p>

<h6>方式二</h6>

<p>直接把apk文件放入dex2jar文件夹中，执行<code>sh d2j-dex2jar.sh apk名称.apk</code>也会得到对应的jar文件。</p>

<h4>3.JD-GUI</h4>

<p>把JD-GUI下载下来，打开上面生成的jar文件就可查看了。
<img src="/myimg/android/taobao211.png" alt="image" /></p>

<p>下面是微信2.3处理后的结果
<img src="/myimg/android/wx1.png" alt="image" />
<img src="/myimg/android/wx2.png" alt="image" />
<img src="/myimg/android/wx3.png" alt="image" />
剩下的就看细心、耐心、和好奇心了&hellip;下面说说我是怎么查看QQ2.0的。</p>

<h3>我的查看流程</h3>

<p>找一个页面的特殊字符，如下面的"我的个人资料"
<img src="/myimg/android/find00.jpg" alt="image" /></p>

<p>然后Finder搜索，找到strings.xml文件，在里面找到"我的个人资料"对应的key &ndash; &ldquo;info_info"。
<img src="/myimg/android/find0.png" alt="image" />
<img src="/myimg/android/find1.png" alt="image" /></p>

<p>然后搜"info_info"，找到对应的布局文件"info_self.xml"
<img src="/myimg/android/find2.png" alt="image" /></p>

<p>然后通过"info_self"布局文件名搜索，找到对应的smali文件
<img src="/myimg/android/find3.png" alt="image" /></p>

<p>然后通过smali文件名"InfoActivity"在JD-GUI的Search功能搜索，不是Find!找到对应的Activity，这样想看的东西应该都能找到了。
<img src="/myimg/android/find4.png" alt="image" /></p>
</div>
  
  


      | <a href="/blog/2016/09/02/apk-decode/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/09/01/fragment/">Android中的Fragment</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-01T11:38:27+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>11:38 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在 Android 3.0（API 11 级）中引入了Fragment，主要是为了给大屏幕上更加动态和灵活的 UI 设计提供支持。由于平板电脑的屏幕比手机屏幕大得多，因此可用于组合和交换 UI 组件的空间更大。利用Fragment实现此类设计时，无需管理对视图层次结构的复杂更改。它具有自己的生命周期，能接收自己的输入事件，并且可以在 Activity 运行时添加或删除Fragment，有点像可以在不同 Activity 中重复使用的"子 Activity"。 通过将 Activity 布局分成Fragment，可以在运行时修改 Activity 的外观，并在由 Activity 管理的返回栈中保留这些更改。Fragment必须始终嵌入在 Activity 中，其生命周期直接受宿主 Activity 生命周期的影响。当 Activity 暂停时，其中的所有Fragment也会暂停；当 Activity 被销毁时，所有Fragment也会被销毁。</p>

<p>下面是Android官网上的<a href="https://developer.android.com/guide/components/activities.html">Activity</a>和<a href="https://developer.android.com/guide/components/fragments.html">Fragment</a>的生命周期图。</p>

<p><img src="/myimg/android/activity_lifecycle.png" alt="imga" /> <img src="/myimg/android/fragment_lifecycle.png" alt="imga" /></p>

<p>下面是网友整理的详细的<a href="https://github.com/xxv/android-lifecycle">周期图比较</a>。</p>

<p><img src="/myimg/android/fragment.png" alt="image" /></p>

<h4>用Fragment可能会遇到的问题</h4>

<h5>getActivity()空指针</h5>

<p>可能遇到过getActivity()返回null，或者平时运行完好的代码，在“内存重启”之后，调用getActivity()的地方却返回null，报了空指针异常。大多数情况下的原因：在调用了getActivity()时，当前的Fragment已经onDetach()了宿主Activity。比如在pop了Fragment之后，该Fragment的异步任务仍然在执行，并且在执行完成后调用了getActivity()方法，这样就会空指针。</p>

<p>可以在Fragment基类里设置一个Activity mActivity的全局变量，在onAttach(Activity activity)里赋值，使用mActivity代替getActivity()，保证Fragment即使在onDetach后，仍持有Activity的引用。</p>

<h5>Fragment重叠问题</h5>

<p>如果add()了几个Fragment，然后使用show()、hide()方法控制，比如微信、QQ的底部tab等情景。如果你什么都不做的话，在“内存重启”后回，Tab的这几个Fragment界面会重叠。(手机横竖屏切换就可以模拟“内存重启”)。原因是FragmentManager帮我们管理Fragment，当发生“内存重启”，他会从栈底向栈顶的顺序恢复Fragment，但是因为没有保存Fragment的hidden属性，默认为false，所以所有Fragment都是以show的形式恢复，界面就重叠了。</p>

<h5>解决方法一</h5>

<p>不用add()的方式处理tab的Fragment，直接在Activity的布局文件中添加需要的Fragment,然后在Activity中通过getFragmentManager().findFragmentById()的方式得到Fragment，然后处理对应的hide,show。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;fragment
</span><span class='line'>    android:id="@+id/fragment0"
</span><span class='line'>    android:name="com.suguiming.myandroid.tab0.Fragment0"
</span><span class='line'>    android:layout_above="@+id/tab_line"
</span><span class='line'>    android:layout_width="match_parent"
</span><span class='line'>    android:layout_height="match_parent"
</span><span class='line'>    tools:layout="@layout/fragment_container"/&gt;
</span><span class='line'>&lt;fragment
</span><span class='line'>    android:id="@+id/fragment1"
</span><span class='line'>    android:name="com.suguiming.myandroid.tab1.Fragment1"
</span><span class='line'>    android:layout_above="@+id/tab_line"
</span><span class='line'>    android:layout_width="match_parent"
</span><span class='line'>    android:layout_height="match_parent"
</span><span class='line'>    tools:layout="@layout/fragment_container"/&gt;</span></code></pre></td></tr></table></div></figure>


<h5>解决方法二</h5>

<p>在用add()或者replace()时为Fragment绑定一个tag，一般用fragment的类名作为tag，然后在发生“内存重启”时，即savedInstanceState!=null 时，通过getFragmentManager().findFragmentByTag()找到对应的Fragment，然后hide、show 对应的Fragment。</p>

<pre><code>protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity);

TargetFragment targetFragment;
HideFragment hideFragment;

if (savedInstanceState != null) {  // “内存重启”时调用
    targetFragment = getSupportFragmentManager().findFragmentByTag(TargetFragment.class.getName);
    hideFragment = getSupportFragmentManager().findFragmentByTag(HideFragment.class.getName);
    // 解决重叠问题
    getFragmentManager().beginTransaction()
            .show(targetFragment)
            .hide(hideFragment)
            .commit();
}else{  // 正常时
    targetFragment = TargetFragment.newInstance();
    hideFragment = HideFragment.newInstance();

    getFragmentManager().beginTransaction()
            .add(R.id.container, targetFragment, targetFragment.getClass().getName())
            .add(R.id,container,hideFragment,hideFragment.getClass().getName())
            .hide(hideFragment)
            .commit();
}
}
</code></pre>

<h5>解决方法三</h5>

<p>由于造成重叠的原因是因为Fragment不会保存hide的状态，那我们可以在BaseFragment中手动保存然后处理啊！</p>

<pre><code>private static final String FRAGMENT_IS_HIDDEN = "FRAGMENT_IS_HIDDEN";

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    //解决重叠问题
    if (savedInstanceState != null) {
        boolean isHidden = savedInstanceState.getBoolean(FRAGMENT_IS_HIDDEN);
        FragmentTransaction ft = getFragmentManager().beginTransaction();
        if (isHidden) {
            ft.hide(this);
        } else {
            ft.show(this);
        }
        ft.commit();
    }
}

@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    outState.putBoolean(FRAGMENT_IS_HIDDEN, isHidden());//保持fragment是否隐藏的状态
}
</code></pre>

<p>在使用时还是要注意判断savedInstanceState是否为null，只有在为空时才add()。在不为空时就可以不用处理了，交由BaseFragment处理了。</p>
</div>
  
  


      | <a href="/blog/2016/09/01/fragment/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/31/android-swipe/">Android手势滑动返回</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-31T15:16:10+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>3:16 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>偶然间发现了一个Android自带的抽屉控件<a href="https://developer.android.com/training/implementing-navigation/nav-drawer.html">DrawerLayout</a>,就觉得应该可以用他来封装成手势返回的基础控件。思路就是先设置Activity的跳转动画是从右到左，并且前一个Activity不能动。然后设置DrawerLayout的menu从右边出来，然设置menu全屏，这个menu就相当于子Activity View的容器，默认打开menu,然后设置DrawerLayout容器透明，当DrawerLayout close的时候finish它所在的Activity！还要把状态栏设置成透明，不然DrawerLayout closed 再 finish Activity的时候会有视觉差！复杂的手势控制就交由自带的DrawerLayout处理啦，生命周期还是Activity的生命周期。怎么样，是不是机智如我！！😆</p>

<p>遇到的问题：DrawerLayout的menu即时设置成match_parent也不能全屏！因为源码里设置了margin64dp! 那我们只好再设置回来：android:layout_marginLeft=&ldquo;-64dp"。</p>

<pre><code> private static final int MIN_DRAWER_MARGIN = 64; // dp
</code></pre>

<p>BaseSwipeActivity</p>

<pre><code>package com.suguiming.myandroid.base;
import android.os.Bundle;
import android.support.v4.view.GravityCompat;
import android.support.v4.widget.DrawerLayout;
import android.support.v7.app.ActionBarDrawerToggle;
import android.support.v7.app.AppCompatActivity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.WindowManager;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;

import com.suguiming.myandroid.R;

public class BaseSwipeActivity extends AppCompatActivity {

private DrawerLayout drawer;
private LinearLayout containerLayout;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    setContentView(R.layout.activity_base_swipe);

    containerLayout = (LinearLayout) findViewById(R.id.container_layout);

    drawer = (DrawerLayout) findViewById(R.id.base_drawer_layout);
    drawer.openDrawer(GravityCompat.END);
    ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawer, R.string.navigation_drawer_open, R.string.navigation_drawer_close) {
        @Override
        public void onDrawerClosed(View drawerView) {
            super.onDrawerClosed(drawerView);
            finish();
        }
    };
    drawer.setDrawerListener(toggle);
}

//子类不要用setContentView,用setMainView!!!!
public void setMainView(int viewId) {
    LayoutInflater inflater = LayoutInflater.from(this);
    View tmpView = inflater.inflate(viewId, null);

    if (tmpView instanceof LinearLayout) {
        LinearLayout.LayoutParams linearLayoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(linearLayoutParams);
    } else if (tmpView instanceof RelativeLayout) {
        RelativeLayout.LayoutParams relativeLayoutParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(relativeLayoutParams);
    }
    containerLayout.removeAllViews();
    containerLayout.addView(tmpView);
}

}
</code></pre>

<p>对应的布局文件</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="@android:color/transparent"
    tools:context="com.suguiming.myandroid.base.BaseSwipeActivity"&gt;

&lt;android.support.v4.widget.DrawerLayout
    android:id="@+id/base_drawer_layout"
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/transparent"
    tools:openDrawer="end"&gt;
    &lt;LinearLayout
        android:orientation="vertical"
        android:background="@color/clear"
        android:layout_width="match_parent"
        android:layout_height="match_parent"&gt;
    &lt;/LinearLayout&gt;

    &lt;!---64dp是源码menu的margin,这里设置为65,不然会有一条黑线--&gt;
    &lt;LinearLayout
        android:id="@+id/container_layout"
        android:orientation="vertical"
        android:layout_gravity="end"
        android:layout_marginLeft="-65dp"
        android:background="@color/light_gray"
        android:layout_width="match_parent"
        android:layout_height="match_parent"&gt;
    &lt;/LinearLayout&gt;
&lt;/android.support.v4.widget.DrawerLayout&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p>push 的动画 style</p>

<pre><code>&lt;!--手势返回theme--&gt;
&lt;style name="BackSwipeTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;
    &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt;
    &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt;
    &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="android:backgroundDimEnabled"&gt;false&lt;/item&gt;
    &lt;item name="android:windowAnimationStyle"&gt;@style/ActivitySwipeBackAnimation&lt;/item&gt;
&lt;/style&gt;
&lt;style name="ActivitySwipeBackAnimation" parent="@android:style/Animation.Activity"&gt;
    &lt;item name="android:activityOpenEnterAnimation"&gt;@anim/activity_swipe_in&lt;/item&gt;
    &lt;item name="android:activityOpenExitAnimation"&gt;@anim/activity_swipe_out&lt;/item&gt;
    &lt;item name="android:activityCloseEnterAnimation"&gt;@anim/activity_swipe_in&lt;/item&gt;
    &lt;item name="android:activityCloseExitAnimation"&gt;@anim/activity_swipe_out&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>使用的话就是让Activity继承BaseSwipeActivity，然后设置Activity的Theme为BackSwipeTheme。</p>

<pre><code>public class ActivitySwipeBack extends BaseSwipeActivity {
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    //要用setMainView，不要用setContentView
    setMainView(R.layout.activity_activity_swipe_back);
  }
}

&lt;activity android:name=".tab0.ActivitySwipeBack"
            android:theme="@style/BackSwipeTheme"/&gt;
</code></pre>

<p>完整Demo请查看<a href="https://github.com/AndyFightting/MyAndroid">MyAndroid</a>中的"手势滑动返回"。</p>

<p><img src="/myimg/android/android_swipe.png" alt="imge" /></p>
</div>
  
  


      | <a href="/blog/2016/08/31/android-swipe/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/04/swift-read/">Swift</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-04T16:23:05+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:23 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let 声明常量，var 声明变量，会自动进行类型推断(小数推断为Double),一行末尾可不加分号(;)。
</span><span class='line'>值永远不会被隐式转换为其他类型，务必显示强制转换。
</span><span class='line'>if语句的条件不能默认非0为真。 类型后加?号表示可选值，要么有值，要么是nil。
</span><span class='line'>用 if let(或者var) name = optionName 来获取可选值处理。 
</span><span class='line'>`??` 操作符来提供一个默认值。如果`可选值`缺失的话，可以使用默认值来代替。
</span><span class='line'>let nickName: String? = nil
</span><span class='line'>let fullName: String = "John Appleseed"
</span><span class='line'>let informalGreeting = "Hi \(nickName ?? fullName)"
</span><span class='line'>switch支持任意类型的数据以及各种比较操作——不仅仅是整数以及测试相等。
</span><span class='line'>switch的case中自带break，switch要保证全部遍历，否则必须要有default选项。
</span><span class='line'>字典是一个无序的集合，所以他们的键和值以任意顺序迭代结束。
</span><span class='line'>do while --&gt; repeat while.
</span><span class='line'>0&lt;= x &lt;4 等价 0..&lt;4 , 0&lt;= x &lt;=4 等价 0...4 。 
</span><span class='line'>用 func 声明函数，用-&gt;指定返回类型func greet(name: String, day: String) -&gt; String { ... }。 
</span><span class='line'>参数名前用 _ 表示不适用参数标签。参数前面添加字符重新定义适用的参数名。
</span><span class='line'>元组概念，一般用做函数返回值。 -&gt; (min: Int, max: Int, sum: Int) 。
</span><span class='line'>func sumOf(numbers: Int...) -&gt; Int {}，...表示可变个数的参数，这些参数在函数内表现为数组的形式。
</span><span class='line'>函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。
</span><span class='line'>函数是一等类型，像int float一样，可用作参数或者返回值。 
</span><span class='line'>可以使用{}来创建一个匿名闭包。使用in将参数和返回值类型声明与闭包函数体进行分离。
</span><span class='line'>numbers.map({
</span><span class='line'>    (number: Int) -&gt; Int in
</span><span class='line'>    let result = 3 * number
</span><span class='line'>    return result
</span><span class='line'>})
</span><span class='line'>匿名闭包可以有很多种缩写：
</span><span class='line'>let mappedNumbers = numbers.map({ number in 3 * number })
</span><span class='line'>let sortedNumbers = numbers.sort { $0 &gt; $1 }
</span><span class='line'>闭包优化：
</span><span class='line'>利用上下文推断参数和返回值类型
</span><span class='line'>隐式返回单表达式闭包，即单表达式闭包可以省略 return 关键字
</span><span class='line'>参数名称缩写
</span><span class='line'>尾随闭包语法
</span><span class='line'>{ (parameters) -&gt; returnType in
</span><span class='line'>    statements
</span><span class='line'>}
</span><span class='line'>class 声明类,属性都要赋值，要么在声明直接写死，要么在init方法中赋值。 使用deinit创建一个析构函数。
</span><span class='line'>func关键字之前加上关键字static，来指定类方法。还可以用关键字class来允许子类重写父类的方法实现。(static = final + class)(不可重写的类方法)
</span><span class='line'>重写父类方法必须用 override 标记。 属性可以有get set willGet didSet 等方法。 
</span><span class='line'>mutating关键字用来标记一个会修改结构体(属性)的方法。 
</span><span class='line'>extension来为现有的类型添加功能，比如新的方法和计算属性。
</span><span class='line'>泛型(指定类型)就是java中的泛型。 Bool值是true或false。 
</span><span class='line'>typealies name = 类型 给类型起个别名。 
</span><span class='line'>OC中的nil只用在对象上(int不行)，Swift中nil可指任何东西(对象或int)。
</span><span class='line'>使用!来获取一个不存在的可选值会导致错误。隐式解析可选类型(类型!)就是可选类型，但是可以当做非可选类型来使用(不用!解析,没值时会报错)。 
</span><span class='line'>throws do try catch 的使用。Swift的赋值操作不返回任何值。% 浮点数也可以取余运算。 
</span><span class='line'>空合运算符(a ?? b)对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b(b和a要类型相同)。逻辑 &&，|| 都是短路计算的。
</span><span class='line'>条件中的下划线 _ 来忽略对值的访问，case 中的下划线 _ 表示所有可能的值,case中可进行值绑定，case条件可用where语句。 
</span><span class='line'>字典的遍历顺序和插入顺序可能不同(字典无序的)。 
</span><span class='line'>Swift语言的repeat-while循环合其他语言中的do-while循环是类似的。
</span><span class='line'>注意循环中switch中的continue(开始下次)和break(跳到switch}后面继续执行)的差别，switch中的fallthrouth进入下一个case时不会再进行条件判断。
</span><span class='line'>guard(守卫)语句总是有一个else分句。 
</span><span class='line'>调用函数时第一个参数名不要，之后的参数名要，用逗号分开(第一个参数省略其外部参数名，第二个以后的参数使用其本地参数名作为自己的外部参数名。
</span><span class='line'>所有参数需要有不同的本地参数名，但可以共享相同的外部参数名。如果你提供了外部参数名，那么函数在被调用时，必须使用外部参数名。如果你不想为第二个及后续的参数设置参数名，用下划线_代替)。
</span><span class='line'>一个函数最多只能有一个可变参数(...),如果函数同时有默认参数和可变参数要把可变参数放最后。 
</span><span class='line'>函数参数默认是常量，修改会报错，但可以用var声明为变量,修改只在函数体内有效。 
</span><span class='line'>inout参数(只能传入变量)会替换原来的值，使用时在变量名前加&符号。 
</span><span class='line'>原数组不会被sort()方法修改。 闭包就是用{}包起来的函数代码块，用in分开返回值和处理代码，参数不能有默认值。如果需要将闭包作为最后一个参数，可变成尾随闭包。
</span><span class='line'>Array的map方法可返回不同类型。 函数和闭包都是引用类型。
</span><span class='line'>结构体和枚举是值类型，所有的基本类型都是值类型，并且都是以结构体的形式在后台所实现。
</span><span class='line'>默认情况下，值类型的属性不能在它的实例方法中被修改。如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，
</span><span class='line'>然后就可以从其方法内部改变它的属性.并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。
</span><span class='line'>方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。
</span><span class='line'>不能在结构体类型的常量上调用可变方法，因为其属性不能被改变，即使属性是变量属性.
</span><span class='line'>var somePoint = Point(x: 1.0, y: 1.0) //somePoint是var就可以
</span><span class='line'>somePoint.moveByX(2.0, y: 3.0)
</span><span class='line'>let fixedPoint = Point(x: 3.0, y: 3.0)
</span><span class='line'>fixedPoint.moveByX(2.0, y: 3.0)//因为fixedPoint是let 这里将会报告一个错误
</span><span class='line'>类是引用类型。常量实例依然可改变其中的变量属性值。
</span><span class='line'>必须将延迟存储属性声明成变量（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。
</span><span class='line'>如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。
</span><span class='line'>计算属性不直接存储值，而是提供一个 get 和一个可选的 set，来间接获取和设置其他属性或变量的值。
</span><span class='line'>swift指针并不直接指向内存中的某个地址，而且也不要求你使用星号（*）来表明你在创建一个引用。
</span><span class='line'>结构体实例总是通过值传递，类实例总是通过引用传递。
</span><span class='line'>Swift 中字符串（String）,数组（Array）和字典（Dictionary）均以结构体的形式实现的值类型,而在OC中是以类的形式实现的引用类型。
</span><span class='line'>计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。
</span><span class='line'>如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使定义了变量存储属性，由于结构体（struct）属于值类型，当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。
</span><span class='line'>如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行.
</span><span class='line'>这种行为是由于结构体（struct）属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。
</span><span class='line'>引用类型的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。
</span><span class='line'>必须将延迟存储属性声明成变量（使用var关键字），因为属性的初始值可能在实例构造完成之后才会得到。
</span><span class='line'>结构体总是通过被复制的方式在代码中传递，不使用引用计数。
</span><span class='line'>而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。
</span><span class='line'>计算属性不直接存储值，而是提供一个 get和一个可选的set，来间接获取和设置其他属性或变量的值。
</span><span class='line'>必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。
</span><span class='line'>父类的属性在子类的构造器中被赋值时，它在父类中的willSet和didSet观察器会被调用。
</span><span class='line'>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy特性。局部范围的常量或变量不会延迟计算。
</span><span class='line'>必须给存储类型的类属性指定默认值，因为类型本身无法在初始化过程中使用构造器给类型属性赋值。
</span><span class='line'>结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。
</span><span class='line'>重写类只能扩大范围而不能缩小范围，如把只读属性重写为读写属性，而不能反过来。有setter的话必须也提供getter。重写属性必须写上类型。通过标记final来表示不可被继承或重写。
</span><span class='line'>下标可以定义在类、结构体和枚举中，是访问集合，列表或序列中元素的快捷方式。可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法。
</span><span class='line'>下标允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。语法类似于实例方法语法和计算型属性语法的混合。
</span><span class='line'>与实例方法不同的是，下标可以设定为读写或只读。可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数。
</span><span class='line'>所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。与结构体不同，类实例没有默认的成员逐一构造器。
</span><span class='line'>在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），
</span><span class='line'>都是值类型，并且在底层都是以结构体的形式所实现。值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。
</span><span class='line'>类的实例即时是let也可以改变类里的var属性。
</span><span class='line'>===检测两个类常量或者变量是否引用同一个实例。(值类型不存在引用之说，都是copy)
</span><span class='line'>结构体适用情况：
</span><span class='line'>该数据结构的主要目的是用来封装少量相关简单数据值。
</span><span class='line'>有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。
</span><span class='line'>该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。
</span><span class='line'>该数据结构不需要去继承另一个既有类型的属性或者行为。
</span><span class='line'>一个函数最多只能拥有一个可变参数。函数参数默认是常量。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）。
</span><span class='line'>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。
</span><span class='line'>函数和闭包都是引用类型。
</span><span class='line'>Swift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。
</span><span class='line'>Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。
</span><span class='line'>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。
</span><span class='line'>当为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。
</span><span class='line'>可以在构造过程中修改常量属性.只要在构造过程结束时是一个确定的值。可选类型的属性将自动初始化为nil.
</span><span class='line'>结构体的逐一成员构造器：如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。
</span><span class='line'>类没有默认的逐一成员构造器。
</span><span class='line'>如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。
</span><span class='line'>这种限制可以防止你为值类型增加了一个额外的且十分复杂的构造器之后,仍然有人错误的使用自动生成的构造器。
</span><span class='line'>假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（extension）中，而不是写在值类型的原始定义中。
</span><span class='line'>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。
</span><span class='line'>类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。
</span><span class='line'>类的构造器代理规则：
</span><span class='line'>指定构造器必须调用其直接父类的的指定构造器。
</span><span class='line'>便利构造器(convenience)必须调用同类中定义的其它构造器。
</span><span class='line'>便利构造器必须最终导致一个指定构造器被调用。
</span><span class='line'>(指定构造器必须总是向上代理，便利构造器必须总是横向代理）
</span><span class='line'>两段式构造过程:
</span><span class='line'>第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。
</span><span class='line'>跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。子类不能调用父类的便利构造器。所以在子类中“重写”一个父类便利构造器时，不需要加override前缀。
</span><span class='line'>假设你为子类中引入的所有新属性都提供了默认值,以下 2 个规则适用：
</span><span class='line'>1.如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。
</span><span class='line'>2.如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。
</span><span class='line'>对于规则 2，子类可以将父类的指定构造器实现为便利构造器。
</span><span class='line'>析构器只适用于类，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字deinit来标示。每个类最多只能有一个析构器，而且析构器不带任何参数。析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。
</span><span class='line'>用类型检查操作符（is）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 true，否则返回 false。
</span><span class='line'>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（as? 或 as!）。
</span><span class='line'>Any 可以表示任何类型，包括函数类型。AnyObject 可以表示任何类的实例。
</span><span class='line'>如果一条catch子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为error的局部常量。
</span><span class='line'>可以使用defer语句在即将离开当前代码块时执行一系列语句。以用defer语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。
</span><span class='line'>defer语句将代码的执行延迟到当前的作用域退出之前。
</span><span class='line'>可选链式调用是一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。
</span><span class='line'>通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。
</span><span class='line'>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。
</span><span class='line'>如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。
</span><span class='line'>可以通过定义类之间的关系为弱引用或无主引用，以替代强引用，从而解决循环强引用的问题。
</span><span class='line'>弱引用和无主引用允许循环引用中的一个实例引用而另外一个实例不保持强引用。这样实例能够互相引用而不产生循环强引用。
</span><span class='line'>生命周期更长的话用弱引用(如公寓和租客，在公寓对象里的租客属性用弱引用weak)，更短的话用无主引用(客户和银行卡的关系，客户不一定有银行卡，银行卡一定属于某个客户，所以在银行卡对象里的非可选属性客户前用无主引用unowned)。当 ARC 设置弱引用为nil时，属性观察不会被触发。
</span><span class='line'>Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。
</span><span class='line'>Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。
</span><span class='line'>存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</span></code></pre></td></tr></table></div></figure>


<p><img src="/myimg/ios/swift0.png" width="700" alt="" />
<img src="/myimg/ios/swift1.png" width="700" alt="" />
<img src="/myimg/ios/swift2.png" width="700" alt="" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>无主引用通常都被期望拥有值。不过 ARC 无法在实例被销毁后将无主引用设为nil，因为非可选类型的变量不允许被赋值为nil。
</span><span class='line'>使用无主引用，你必须确保引用始终指向一个未销毁的实例。
</span><span class='line'>如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。
</span><span class='line'>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如self.someProperty，或者闭包中调用了实例的某个方法，例如self.someMethod()。这两种情况都导致了闭包“捕获”self，从而产生了循环强引用。循环强引用的产生，是因为闭包和类相似，都是引用类型。虽然闭包多次使用了self，它只捕获实例的一个强引用。
</span><span class='line'>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。
</span><span class='line'>捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。
</span><span class='line'>Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod()（而不只是someProperty或someMethod()）。这提醒你可能会一不小心就捕获了self。
</span><span class='line'>弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。如果被捕获的引用绝对不会变为nil，应该用无主引用，而不是弱引用。
</span><span class='line'>扩展可以为添加新的功能，但是不能重写已有的功能。可以添加计算型属性，不能添加存储属性。也不可以为已有属性添加属性观察器。Swift 的扩展没有名字。
</span><span class='line'>如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。
</span><span class='line'>如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。
</span><span class='line'>实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。
</span><span class='line'>mutating：表示可以在该方法中修改它所属的实例以及实例的任意属性的值。
</span><span class='line'>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。
</span><span class='line'>标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类遵循，其他类以及结构体和枚举均不能遵循这种协议。</span></code></pre></td></tr></table></div></figure>

</div>
  
  


      | <a href="/blog/2016/08/04/swift-read/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/04/animation/">iOS中的动画</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-04T16:22:41+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:22 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>动画是作用的UIView的CALayer上的，UIView是CALayer的代理，给CALayer提供数据参数，CALayer负责渲染和动画。UIView是在UIKit框架中，而CALayer是在QuartzCore框架中。UIView可以响应用户事件，而CALayer不可以响应用户事件。CALayer也可以像UIView一样添加子Layer。
<img src="/myimg/ios/calayer.png" alt="image" /></p>

<h4>CALayer常用属性</h4>

<pre><code>anchorPoint 和中心点position重合的一个点，称为“锚点”，锚点的描述是相对于x、y位置比例而言的默认在图像中心点(0.5,0.5)的位置
backgroundColor 图层背景颜色  
borderColor 边框颜色    
borderWidth 边框宽度    
bounds  图层大小    
contents    图层显示内容，例如可以将图片作为图层内容显示
contentsRect    图层显示内容的大小和位置    
cornerRadius    圆角半径    
doubleSided 图层背面是否显示，默认为YES 
frame   图层大小和位置，不支持隐式动画，所以CALayer中很少使用frame，通常使用bounds和position代替
hidden  是否隐藏    
mask    图层蒙版    
maskToBounds    子图层是否剪切图层边界，默认为NO 
opacity 透明度 ，类似于UIView的alpha    
position    图层中心点位置，类似于UIView的center
shadowColor 阴影颜色    
shadowOffset    阴影偏移量 
shadowOpacity   阴影透明度，注意默认为0，如果设置阴影必须设置此属性
shadowPath  阴影的形状 
shadowRadius    阴影模糊半径  
sublayers   子图层   
sublayerTransform   子图层形变 
transform   图层形变
</code></pre>

<p>要注意position和anchorPoint的区别：<strong>position是layer中的anchorPoint点在superLayer中的位置坐标！position点是相对suerLayer的，anchorPoint点是相对自身layer的！</strong> 所以说position不变，但anchorPoint改变的话，也会改变layer在superLayer中的位置！</p>

<pre><code>layer=[[CALayer alloc]init];
layer.backgroundColor=[UIColor purpleColor].CGColor;
layer.bounds=CGRectMake(0, 0, 100,100);
layer.shadowColor=[UIColor redColor].CGColor;
layer.shadowOffset=CGSizeMake(5, 5);
layer.shadowOpacity=0.7;
layer.borderColor=[UIColor yellowColor].CGColor;
layer.borderWidth=3;
layer.position=CGPointMake(size.width/2, size.height/2);
[self.view.layer addSublayer:layer];

//layer.anchorPoint=CGPointMake(0, 0); //图一
//layer.anchorPoint=CGPointMake(0, 1); //图二
</code></pre>

<p>图中position一样，但anchorPoint不一样，所以图片位置也不一样。  <br/>
<img src="/myimg/ios/layer_position.png" alt="image" />
注意如果要设置圆角，对于图层本身而言可以正常显示，但是对于图层中绘制的图片无法正确显示。如果想要图片正确显示则必须设置masksToBounds=YES，剪切子图层。但设置layer.masksToBounds=YES后，图层的影效果无法和masksToBounds=YES同时使用，因为masksToBounds的目的就是剪切外边框。如果同时要阴影又要圆角的话，就用两个重叠的图层,底部负责绘制阴影，上层负责绘制圆角。</p>

<h4>Core Animation</h4>

<p>iOS的核心动画Core Animation包含在Quartz Core框架中。核心动画分为几类：基础动画、关键帧动画、动画组、转场动画,各个类的关系大致如下：
<img src="/myimg/ios/core_animation.png" alt="image" />
*CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</p>

<p>*CAPropertyAnimation：属性动画的基类，通过属性进行动画设置，不能直接使用。</p>

<p>*CAAnimationGroup：动画组合模式，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</p>

<p>*CATransition：转场动画，主要通过滤镜进行动画效果设置。</p>

<p>*CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</p>

<p>*CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</p>

<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，只需要设置初始值和结束值，中间的过程动画由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的过渡动画由系统自动完成。</p>
</div>
  
  


      | <a href="/blog/2016/08/04/animation/#comments">Comments</a>


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/4">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/2">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/12/30/utf8/">Unicode、UTF-8编码起源</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/28/google-protocol-buffer/">Google Protocol Buffer</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/27/suan-fa/">排序算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/25/front-end/">前端基础知识</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/21/es6/">ECMAScript 6</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>android (9)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (9)</a></li>
<li class='category'><a href='/blog/categories/java/'>java (6)</a></li>
<li class='category'><a href='/blog/categories/javascript/'>javascript (5)</a></li>
<li class='category'><a href='/blog/categories/other/'>other (5)</a></li>
<li class='category'><a href='/blog/categories/react/'>react (8)</a></li>

  </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - guimingsu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
