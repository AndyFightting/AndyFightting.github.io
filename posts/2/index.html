
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>阿贵</title>
  <meta name="author" content="guimingsu">

  
  <meta name="description" content="1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
let 声明常量，var 声明变量 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andyfightting.github.io/posts/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="阿贵" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">  -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

<script>
  function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
    });
  }
  $(document).bind('DOMNodeInserted', function(event) {
    addBlankTargetForLinks();
  });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">阿贵</a></h1>
  
    <h2>Stay Hungry, Stay Foolish</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andyfightting.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/04/swift-read/">Swift阅读笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-04T16:23:05+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:23 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let 声明常量，var 声明变量，会自动进行类型推断(小数推断为Double),一行末尾可不加分号(;)。
</span><span class='line'>值永远不会被隐式转换为其他类型，务必显示强制转换。
</span><span class='line'>if语句的条件不能默认非0为真。 类型后加?号表示可选值，要么有值，要么是nil。
</span><span class='line'>用 if let(或者var) name = optionName 来获取可选值处理。 
</span><span class='line'>switch的case中自带break，switch要保证全部遍历，否则必须要有default选项。
</span><span class='line'>0&lt; x &lt;4 等价 0..&lt;4 , 0&lt; x &lt;=4 等价 0...4 。 
</span><span class='line'>用 func 声明函数，用-&gt;指定返回类型func greet(name: String, day: String) -&gt; String { ... }。 
</span><span class='line'>元组概念，一般用做函数返回值。 
</span><span class='line'>func sumOf(numbers: Int...) -&gt; Int {}，...表示可变个数的参数。 
</span><span class='line'>函数是一等类型，像int float一样，可用作参数或者返回值。 
</span><span class='line'>class 声明类,属性都要赋值，要么在声明直接写死，要么在init方法中赋值。 
</span><span class='line'>重写父类方法必须用 override 标记。 属性可以有get set willGet didSet 等方法。 
</span><span class='line'>mutating关键字用来标记一个会修改结构体(属性)的方法。 
</span><span class='line'>extension来为现有的类型添加功能，比如新的方法和计算属性。
</span><span class='line'>泛型(指定类型)就是java中的泛型。 Bool值是true或false。 
</span><span class='line'>typealies name = 类型 给类型起个别名。 
</span><span class='line'>OC中的nil只用在对象上(int不行)，Swift中nil可指任何东西(对象或int)。
</span><span class='line'>使用!来获取一个不存在的可选值会导致错误。隐式解析可选类型(类型!)就是可选类型，但是可以当做非可选类型来使用(不用!解析,没值时会报错)。 
</span><span class='line'>throws do try catch 的使用。Swift的赋值操作不返回任何值。% 浮点数也可以取余运算。 
</span><span class='line'>空合运算符(a ?? b)对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b(b和a要类型相同)。逻辑 &&，|| 都是短路计算的。
</span><span class='line'>条件中的下划线 _ 来忽略对值的访问，case 中的下划线 _ 表示所有可能的值,case中可进行值绑定，case条件可用where语句。 
</span><span class='line'>字典的遍历顺序和插入顺序可能不同(字典无序的)。 
</span><span class='line'>Swift语言的repeat-while循环合其他语言中的do-while循环是类似的。
</span><span class='line'>注意循环中switch中的continue(开始下次)和break(跳到switch}后面继续执行)的差别，switch中的fallthrouth进入下一个case时不会再进行条件判断。
</span><span class='line'>guard(守卫)语句总是有一个else分句。 
</span><span class='line'>调用函数时第一个参数名不要，之后的参数名要，用逗号分开(第一个参数省略其外部参数名，第二个以后的参数使用其本地参数名作为自己的外部参数名。
</span><span class='line'>所有参数需要有不同的本地参数名，但可以共享相同的外部参数名。如果你提供了外部参数名，那么函数在被调用时，必须使用外部参数名。如果你不想为第二个及后续的参数设置参数名，用下划线_代替)。
</span><span class='line'>一个函数最多只能有一个可变参数(...),如果函数同时有默认参数和可变参数要把可变参数放最后。 
</span><span class='line'>函数参数默认是常量，修改会报错，但可以用var声明为变量,修改只在函数体内有效。 
</span><span class='line'>inout参数(只能传入变量)会替换原来的值，使用时在变量名前加&符号。 
</span><span class='line'>原数组不会被sort()方法修改。 闭包就是用{}包起来的函数代码块，用in分开返回值和处理代码，参数不能有默认值。如果需要将闭包作为最后一个参数，可变成尾随闭包。
</span><span class='line'>Array的map方法可返回不同类型。 函数和闭包都是引用类型。
</span><span class='line'>结构体和枚举是值类型，所有的基本类型都是值类型，并且都是以结构体的形式在后台所实现。
</span><span class='line'>类是引用类型。常量实例依然可改变其中的变量属性值。
</span><span class='line'>swift指针并不直接指向内存中的某个地址，而且也不要求你使用星号（*）来表明你在创建一个引用。
</span><span class='line'>结构体实例总是通过值传递，类实例总是通过引用传递。
</span><span class='line'>Swift 中字符串（String）,数组（Array）和字典（Dictionary）均以结构体的形式实现的值类型,而在OC中是以类的形式实现的引用类型。
</span><span class='line'>计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。
</span><span class='line'>如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使定义了变量存储属性，由于结构体（struct）属于值类型，当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。
</span><span class='line'>必须将延迟存储属性声明成变量（使用var关键字），因为属性的初始值可能在实例构造完成之后才会得到。
</span><span class='line'>而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。
</span><span class='line'>计算属性不直接存储值，而是提供一个 get和一个可选的set，来间接获取和设置其他属性或变量的值。
</span><span class='line'>必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。
</span><span class='line'>父类的属性在子类的构造器中被赋值时，它在父类中的willSet和didSet观察器会被调用。
</span><span class='line'>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy特性。局部范围的常量或变量不会延迟计算。
</span><span class='line'>必须给存储类型的类属性指定默认值，因为类型本身无法在初始化过程中使用构造器给类型属性赋值。
</span><span class='line'>结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。</span></code></pre></td></tr></table></div></figure>

</div>
  
  


      | <a href="/blog/2016/08/04/swift-read/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/04/animation/">iOS中的动画</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-04T16:22:41+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:22 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>动画是作用的UIView的CALayer上的，UIView是CALayer的代理，给CALayer提供数据参数，CALayer负责渲染和动画。UIView是在UIKit框架中，而CALayer是在QuartzCore框架中。UIView可以响应用户事件，而CALayer不可以响应用户事件。CALayer也可以像UIView一样添加子Layer。
<img src="/myimg/ios/calayer.png" alt="image" /></p>

<h4>CALayer常用属性</h4>

<pre><code>anchorPoint 和中心点position重合的一个点，称为“锚点”，锚点的描述是相对于x、y位置比例而言的默认在图像中心点(0.5,0.5)的位置
backgroundColor 图层背景颜色  
borderColor 边框颜色    
borderWidth 边框宽度    
bounds  图层大小    
contents    图层显示内容，例如可以将图片作为图层内容显示
contentsRect    图层显示内容的大小和位置    
cornerRadius    圆角半径    
doubleSided 图层背面是否显示，默认为YES 
frame   图层大小和位置，不支持隐式动画，所以CALayer中很少使用frame，通常使用bounds和position代替
hidden  是否隐藏    
mask    图层蒙版    
maskToBounds    子图层是否剪切图层边界，默认为NO 
opacity 透明度 ，类似于UIView的alpha    
position    图层中心点位置，类似于UIView的center
shadowColor 阴影颜色    
shadowOffset    阴影偏移量 
shadowOpacity   阴影透明度，注意默认为0，如果设置阴影必须设置此属性
shadowPath  阴影的形状 
shadowRadius    阴影模糊半径  
sublayers   子图层   
sublayerTransform   子图层形变 
transform   图层形变
</code></pre>

<p>要注意position和anchorPoint的区别：<strong>position是layer中的anchorPoint点在superLayer中的位置坐标！position点是相对suerLayer的，anchorPoint点是相对自身layer的！</strong> 所以说position不变，但anchorPoint改变的话，也会改变layer在superLayer中的位置！</p>

<pre><code>layer=[[CALayer alloc]init];
layer.backgroundColor=[UIColor purpleColor].CGColor;
layer.bounds=CGRectMake(0, 0, 100,100);
layer.shadowColor=[UIColor redColor].CGColor;
layer.shadowOffset=CGSizeMake(5, 5);
layer.shadowOpacity=0.7;
layer.borderColor=[UIColor yellowColor].CGColor;
layer.borderWidth=3;
layer.position=CGPointMake(size.width/2, size.height/2);
[self.view.layer addSublayer:layer];

//layer.anchorPoint=CGPointMake(0, 0); //图一
//layer.anchorPoint=CGPointMake(0, 1); //图二
</code></pre>

<p>图中position一样，但anchorPoint不一样，所以图片位置也不一样。  <br/>
<img src="/myimg/ios/layer_position.png" alt="image" />
注意如果要设置圆角，对于图层本身而言可以正常显示，但是对于图层中绘制的图片无法正确显示。如果想要图片正确显示则必须设置masksToBounds=YES，剪切子图层。但设置layer.masksToBounds=YES后，图层的影效果无法和masksToBounds=YES同时使用，因为masksToBounds的目的就是剪切外边框。如果同时要阴影又要圆角的话，就用两个重叠的图层,底部负责绘制阴影，上层负责绘制圆角。</p>

<h4>Core Animation</h4>

<p>iOS的核心动画Core Animation包含在Quartz Core框架中。核心动画分为几类：基础动画、关键帧动画、动画组、转场动画,各个类的关系大致如下：
<img src="/myimg/ios/core_animation.png" alt="image" />
*CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</p>

<p>*CAPropertyAnimation：属性动画的基类，通过属性进行动画设置，不能直接使用。</p>

<p>*CAAnimationGroup：动画组合模式，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</p>

<p>*CATransition：转场动画，主要通过滤镜进行动画效果设置。</p>

<p>*CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</p>

<p>*CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</p>

<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，只需要设置初始值和结束值，中间的过程动画由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的过渡动画由系统自动完成。</p>
</div>
  
  


      | <a href="/blog/2016/08/04/animation/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/04/core-data/">iOS中的Core Data</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-04T16:22:22+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:22 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://developer.apple.com/library/watchos/documentation/Cocoa/Conceptual/CoreData/index.html">Core Data</a>是一个对sqlite数据库进行封装的ORM(Object Relation Mapping)框架。它主要由以下几部分组成：</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObject_Class/">NSManagedObject</a></h4>

<p>NSManagedObject is a generic class that implements all the basic behavior required of a Core Data model object. It is not possible to use instances of direct subclasses of NSObject (or any other class not inheriting from NSManagedObject) with a managed object context. You may create custom subclasses of NSManagedObject, although this is not always required. If no custom logic is needed, a complete object graph can be formed with NSManagedObject instances.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectModel_Class/">NSManagedObjectModel</a></h4>

<p>An NSManagedObjectModel object describes a schema, a collection of entities (data models) that you use in your application.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/">NSManagedObjectContext</a></h4>

<p>An instance of NSManagedObjectContext represents a single “object space” or scratch pad in an application. Its primary responsibility is to manage a collection of managed objects. These objects form a group of related model objects that represent an internally consistent view of one or more persistent stores. A single managed object instance exists in one and only one context, but multiple copies of an object can exist in different contexts. Thus object uniquing is scoped to a particular context.</p>

<h4><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSPersistentStoreCoordinator_Class/">NSPersistentStoreCoordinator</a></h4>

<p>Instances of NSPersistentStoreCoordinator associate persistent stores (by type) with a model (or more accurately, a configuration of a model) and serve to mediate between the persistent store or stores and the managed object context or contexts. Instances of NSManagedObjectContext use a coordinator to save object graphs to persistent storage and to retrieve model information. A context without a coordinator is not fully functional as it cannot access a model except through a coordinator. The coordinator is designed to present a façade to the managed object contexts such that a group of persistent stores appears as an aggregate store. A managed object context can then create an object graph based on the union of all the data stores the coordinator covers.</p>

<h4><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSFetchRequest_Class/index.html#//apple_ref/occ/cl/NSFetchRequest">NSFetchRequest</a></h4>

<p>An instance of NSFetchRequest describes search criteria used to retrieve data from a persistent store.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSPredicate_Class/">NSPredicate</a></h4>

<p>The NSPredicate class is used to define logical conditions used to constrain a search either for a fetch or for in-memory filtering.</p>

<p><img src="/myimg/ios/cd_orm.png" alt="image" />
<img src="/myimg/ios/cd_table.png" alt="image" /></p>
</div>
  
  


      | <a href="/blog/2016/08/04/core-data/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/04/session/">iOS中的NSURLSession</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-04T16:22:02+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:22 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


      | <a href="/blog/2016/08/04/session/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/04/block/">iOS中的block</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-04T16:21:41+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>4:21 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>block就是一个代码块，闭包，会捕获上下文的匿名函数，它可以作为参数或者返回值进行传递。在objc中，根据对象的定义，凡是首地址是*isa的结构体指针，都可以认为是对象(id)，所以block实际上就算是对象，但它的内存管理又和NSObject有点不一样。</p>

<h4>声明:</h4>

<pre><code>*变量：returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};

*属性：@property (nonatomic, copy) returnType (^blockName)(parameterTypes);

*方法：-(void)someMethod:(returnType (^nullability)(parameterTypes))blockName;

*回调：[object  method:^returnType (parameters) {...}];

*定义：typedef returnType (^TypeName)(parameterTypes); --&gt; TypeName blockName = ^returnType(parameters) {...};
</code></pre>

<p>block中的isa指向的是该block的Class,主要有三种类型：</p>

<pre><code>_NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量。
_NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。
_NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。
</code></pre>

<p>当block第一次被创建时，它是存在于该函数的栈上的，其Class是固定的NSConcreteStackBlock。其捕获的变量是会赋值到结构体的成员上，所以当block初始化完成后，捕获到的变量不能更改。当函数返回时，函数的栈被销毁，这个block的内存也会被清除。所以在函数结束后仍然需要这个block时，就必须用Block_copy()方法将它拷贝到堆上，类型变为NSConcreteMallocBlock，向它发送retain，增加block的引用计数。</p>

<p>默认block捕获到的局部变量，都是赋值给block的结构体的，相当于const不可改。为了让block能访问并修改外面的局部变量，需要加上__block修饰词。</p>

<pre><code>void test(){
 __block int i = 3;
  void(^myBlock)(void) = ^{
     i = 5;//局部变量没有__block修饰的话不可修改
  };
 myBlock();
}
</code></pre>

<h4>捕获规则：</h4>

<pre><code>1.静态存储区的变量,例如全局变量、方法中的static变量:
  引用，可修改。

2.block接受的参数传值:
  可修改，和一般函数的参数相同。

3.栈变量(局部变量):
  常量，不可修改，block会对id类型的变量产生强引用。

4.栈变量(有__block前缀的局部变量):
  引用，可以修改。如果是id类型则不会被block retain、如果该类型是C类型变量，该值会被挪动到堆中。
</code></pre>

<p>在ARC中，block被赋值传递的时候会自动拷贝到堆上，堆上的对象就有可能被释放掉，所以要用copy强引用着,以免野指针crash。</p>

<h4>循环引用:</h4>

<p>当block被copy到堆之后，该block对它捕获的对象产生强引用，所以有时需要避免block copy后产生的循环引用。</p>

<p>如self引用了block，block又捕获了self，这样就会有循环引用,因此，需要用weak来声明self。</p>

<pre><code>- (void)test {
    ViewController * __weak weakSelf = self;
    self.block = ^{
        [weakSelf doSomething]; //用弱引用,打破循环引用
    }
}
</code></pre>

<p>如果捕获到的是对象的成员变量对象，也会间接造成对self的循环引用，同样也要避免。</p>

<pre><code>- (void)test {
    id tempPropertyObj = _propertyObj; //用临时变量,避免了循环引用
    self.block = ^{
        [tempPropertyObj doSomething];
    }
}
</code></pre>

<h4>问题</h4>

<pre><code>[UIView animateWithDuration:0.5 animations:^{
        [self doSomething];
    }];
</code></pre>

<p>上面例子并不会造成循环引用，因为block强引用了self,而self并没有强引用block。如果像下面就会循环引用：self &ndash;> _observer &ndash;> block &ndash;> self 这也是一个循环引用。</p>

<pre><code>//_observer 是self的实例变量
    _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"test"
                                                                  object:nil
                                                                   queue:[NSOperationQueue mainQueue]
                                                              usingBlock:^(NSNotification * _Nonnull note) {
                                                                  [self doSomething];
                                                              }];
</code></pre>
</div>
  
  


      | <a href="/blog/2016/08/04/block/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/08/01/runtime/">iOS中的Runloop与Runtime</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-08-01T10:20:14+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>10:20 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">Runloop</a></h3>

<p>Runloop与线程息息相关，它是线程的基础架构部分，每个线程都有自己的runloop对象，可以用[NSRunLoop currentRunLoop]来得到它。主线程中的runloop是启动运行状态，而自己创建的线程中的runloop默认是没有启动的，需要的话要手动去启动。Runloop是一个事件处理循环，用来不停的监听输入事件或者定时事件，并将其分配到对应的目标上进行处理。它可以使线程在有工作的时候工作，没有工作的时候休眠。</p>

<p>Runloop同时也负责autorelease pool的创建和释放，每当一个运行循环结束的时候，它都会释放autorelease pool，同时pool中的所有自动释放类型变量都会被释放掉。NSRunloop不是线程安全的，而CFRunLoopRef是线程安全的。RunLoop要指定在特定Mode下Run：</p>

<p>*NSDefaultRunLoopMode：处理大多数的操作，一般情况下用这个。</p>

<p>*NSRunLoopCommonModes：For Cocoa applications, this set includes the default, modal, and event tracking modes by default. Core Foundation includes just the default mode initially.</p>

<p>而且通过scheduleInRunLoop的方式启动的请求，虽然是在主线程中执行！但也会有异步的效果！SDWebImageDownloader 中的 NSURLConnection 就是这样启动请求的！！</p>

<pre><code>- (void)start{
    NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:15];
    self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];
    [connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
    [connection start];
    if (connection){
        self.imageData = [NSMutableData data];
    }else{
        if ([delegate respondsToSelector:@selector(imageDownloader:didFailWithError:)]){
            [delegate performSelector:@selector(imageDownloader:didFailWithError:) withObject:self withObject:nil];
        }
    }
}
</code></pre>

<p>NSURLConnection在代理方法中打印出的线程：
<img src="/myimg/ios/sdrunloop.png" alt="iamge" /></p>

<p>runloop监听用户输入事件和定时事件
<img src="/myimg/ios/runloop.png" alt="image" /></div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2016/08/01/runtime/">阅读全文</a>
    </footer>
  


      | <a href="/blog/2016/08/01/runtime/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/26/core-text/">iOS中的CoreText</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-26T15:16:23+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>3:16 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>CoreText进行图文混排的核心思想是把需要摆放图片的位置用空字符替换原来的字符，并且实现CTRunDelegate，用于动态设置空字符的高度和宽度（代表图片的大小），并且对这些空字符设置一个属性名来区别于其他CTRun，之后进行图片渲染的时候就能通过该属性来区分哪些空字符是代表图片的占位符，哪些是普通的空字符。使用CoreText处理点击事件的关键是判断点击的位置是本文内容中的第几个字符，然后通过判断该字符是否在需要处理点击事件的字符串范围内。</p>

<p><img src="/myimg/ios/text2.png" alt="image" /></div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/12/26/core-text/">阅读全文</a>
    </footer>
  


      | <a href="/blog/2015/12/26/core-text/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/25/ios-sqlite/">iOS中的SQLite</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-25T10:44:52+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:44 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img src="/myimg/ios/sqlite.png" alt="image" /></p>

<p><a href="http://www.sqlite.org/">SQLite</a>是一个轻量级的关系型数据库，在iOS和Android手机中都有用到，C语言的面向过程的函数式编程。<a href="https://github.com/woooooojianjie/SQLitePersistentObject">SQLitePersistentObject</a>和<a href="https://github.com/ccgus/fmdb">FMDB</a>框架都是基于SQLite开发的。SQLitePersistentObject更像是个ORM框架，它是由Jeff LaMarche在2008年开发的，所以不是ARC的，要用的请加上<strong>-fno-objc-arc</strong>，且作者已经没有维护了，所以还是推荐使用更加广泛的FMDB。</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/12/25/ios-sqlite/">阅读全文</a>
    </footer>
  


      | <a href="/blog/2015/12/25/ios-sqlite/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/22/thread/">iOS中的多线程</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-22T14:28:22+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>2:28 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1.什么是进程</p>

<p>进程是指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。
<img src="/myimg/ios/jincheng.png" alt="image" /></div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/12/22/thread/">阅读全文</a>
    </footer>
  


      | <a href="/blog/2015/12/22/thread/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/19/desigin-pattern/">设计模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-19T21:51:06+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:51 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我理解的设计模式都是为了让代码模块化，结构化，各司其职，再把各个模块通过"接口"组合起来。封装变化；多用组合少用继承；针对接口编程，不针对实现编程；为交互对象之间的松耦合设计而努力；对扩展开放，对修改关闭。</p>

<h3>1.MVC模式</h3>

<p>看图就可以了，简洁明了~
<img src="/myimg/other/mvc.png" alt="image" /></div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2015/12/19/desigin-pattern/">阅读全文</a>
    </footer>
  


      | <a href="/blog/2015/12/19/desigin-pattern/#comments">Comments</a>


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/11/14/react-native/">React Native Demo</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/14/springmvc-plus-mybatda-jian/">SpringMVC + MyBatis 框架搭建</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/14/mybatis/">MyBatis 的简单使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/11/android-select-photo/">Android 一行代码选取图片</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/12/link-bug/">iOS Not Found for Architecture Arm64</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>android (9)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (10)</a></li>
<li class='category'><a href='/blog/categories/other/'>other (6)</a></li>

  </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - guimingsu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
