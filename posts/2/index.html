
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>阿贵</title>
  <meta name="author" content="guimingsu">

  
  <meta name="description" content="Flexbox 布局 Nov 30th, 2016 8:56 am 弹性盒子布局由弹性容器和弹性子item组成。容器默认存在两根轴：水平的主轴和垂直的交叉轴。主轴的开始位置叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andyfightting.github.io/posts/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="阿贵" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">  -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

<script>
  function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
    });
  }
  $(document).bind('DOMNodeInserted', function(event) {
    addBlankTargetForLinks();
  });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">阿贵</a></h1>
  
    <h2>认真听，好好想，慢慢回。多思考，多做笔记。</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andyfightting.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/30/css-flex-box/">Flexbox 布局</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-30T08:56:06+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:56 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>弹性盒子布局由弹性容器和弹性子item组成。容器默认存在两根轴：水平的主轴和垂直的交叉轴。主轴的开始位置叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。item默认沿主轴排列。item占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size
<img src="/myimg/java/flexbox.png" width="600" alt="" /></p>

<p><strong>用在容器上的属性：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>flex-direction :决定item的排列方向。(row,row-reverse,column,column-reverse)
</span><span class='line'>flex-wrap :决定item如何换行。(nowrap,wrap,wrap-reverse)
</span><span class='line'>justify-content :决定itme在主轴上的对齐方式。(flex-start,flex-end,center,space-between,space-around)
</span><span class='line'>align-items :决定item在交叉轴上的对齐方式。(stretch,flex-start,flex-end,center,baseline:item第一行文字基线对齐)
</span><span class='line'>align-content :决定多条交叉轴线的对齐方式。(flex-start,flex-end,center,space-between,space-around,stretch)</span></code></pre></td></tr></table></div></figure>


<p>align-content:</p>

<p><img src="/myimg/java/flex1.png" width="400" alt="" /></p>

<p><strong>用在Item上的属性</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>order :定义item的排列顺序。数值越小，排列越靠前，默认为0。
</span><span class='line'>flex-grow :定义item的放大比例。默认为0，即如果存在剩余空间也不放大。有多个的话按比例均分。
</span><span class='line'>flex-shrink :定义item的缩小比例。默认为1，即如果空间不足，该项目将缩小。0则不缩小。
</span><span class='line'>flex-basis :定义了在分配多余空间之前，item占据的主轴空间,默认auto,即本来大小。
</span><span class='line'>flex : flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。
</span><span class='line'>align-self :设置item自身在交叉轴上的对齐方式。可覆盖align-items属性。
</span><span class='line'>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
</span><span class='line'>(auto,flex-start,flex-end,center,baseline,stretch)</span></code></pre></td></tr></table></div></figure>


<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，也有些差异:flexDirection的默认值是column而不是row，alignItems的默认值是stretch而不是flex-start。使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求。</p>

<p><code>flexDirection</code>: 决定布局的主轴。子元素是沿着水平轴方向排列，还是沿着竖直轴方向排列。</p>

<p><code>justifyContent</code>: 决定子元素沿着主轴的排列方式。有flex-start、center、flex-end、space-around 和 space-between。</p>

<p><code>alignItems</code>: 决定其子元素沿着交叉轴的排列方式。有flex-start、center、flex-end以及stretch。<strong>注意：要使stretch选项生效的话，子元素在次轴方向上不能固定尺寸。</strong></p>

<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Fexbox布局实例</a></p>
</div>
  
  


      | <a href="/blog/2016/11/30/css-flex-box/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/29/rn-style/">React Native 样式属性</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-29T22:27:51+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:27 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>React Native 采用CSS样式来布局，也会有继承和覆盖作用。只要在样式表中书写一个不存在的样式，就会报错，提示该样式不存在，然后提供所有可用的样式：
<img src="/myimg/java/style.png" alt="" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//边框
</span><span class='line'>borderBottomWidth 
</span><span class='line'>borderLeftWidth 
</span><span class='line'>borderRightWidth 
</span><span class='line'>borderTopWidth 
</span><span class='line'>borderWidth </span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//边框颜色
</span><span class='line'>borderBottomColor
</span><span class='line'>borderLeftColor
</span><span class='line'>borderRightColor
</span><span class='line'>borderTopColor
</span><span class='line'>borderColor</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//外边距
</span><span class='line'>marginTop
</span><span class='line'>marginBottom
</span><span class='line'>marginLeft
</span><span class='line'>marginRight
</span><span class='line'>marginVertical //相当于marginTop 和 marginBottom
</span><span class='line'>marginHorizontal //相当于 marginLeft 和 marginRight
</span><span class='line'>margin</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//内边距  
</span><span class='line'>paddingTop  
</span><span class='line'>paddingBottom
</span><span class='line'>paddingLeft  
</span><span class='line'>paddingRight  
</span><span class='line'>paddingVertical //相当于 paddingTop 和 paddingBottom
</span><span class='line'>paddingHorizontal  //相当于 paddingLeft 和 paddingRight
</span><span class='line'>padding </span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//边框圆角
</span><span class='line'>borderTopLeftRadius
</span><span class='line'>borderTopRightRadius
</span><span class='line'>borderBottomLeftRadius
</span><span class='line'>borderBottomRightRadius
</span><span class='line'>borderRadius</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//flex 布局
</span><span class='line'>flex number 
</span><span class='line'>flexDirection enum('row', 'column') 
</span><span class='line'>flexWrap enum('wrap', 'nowrap') 
</span><span class='line'>alignItems enum('flex-start', 'flex-end', 'center', 'stretch') 
</span><span class='line'>alignSelf enum('auto', 'flex-start', 'flex-end', 'center', 'stretch') 
</span><span class='line'>justifyContent enum('flex-start', 'flex-end', 'center', 'space-between', 'space-around') 
</span><span class='line'>position属性值为absolute和relative，当使用绝对布局时，定位根据屏幕来进行。</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//字体相关属性
</span><span class='line'>color 字体颜色
</span><span class='line'>fontFamily 字体族
</span><span class='line'>fontSize 字体大小
</span><span class='line'>fontStyle 字体样式，正常，倾斜等，值为enum('normal', 'italic')
</span><span class='line'>fontWeight 字体粗细，值为enum("normal", 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900')
</span><span class='line'>letterSpacing 字符间隔
</span><span class='line'>lineHeight 行高
</span><span class='line'>textAlign 字体对齐方式，值为enum("auto", 'left', 'right', 'center', 'justify')
</span><span class='line'>textDecorationLine 上划线，下划线，删除线，无修饰，值为enum("none", 'underline', 'line-through', 'underline line-through')
</span><span class='line'>textDecorationStyle 修饰的线的类型 enum("solid", 'double', 'dotted', 'dashed')
</span><span class='line'>textDecorationColor 修饰的线的颜色
</span><span class='line'>writingDirection enum("auto", 'ltr', 'rtl') 书写方向，从左往右写还是从右往左写</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//图片相关属性
</span><span class='line'>resizeMode enum('cover', 'contain', 'stretch')
</span><span class='line'>overflow enum('visible', 'hidden') 超出部分是否显示，hidden为隐藏
</span><span class='line'>tintColor 着色，rgb字符串类型
</span><span class='line'>opacity 透明度
</span><span class='line'>scaleX:水平方向缩放
</span><span class='line'>scaleY:垂直方向缩放
</span><span class='line'>rotation:旋转
</span><span class='line'>translateX:水平方向平移
</span><span class='line'>translateY:水平方向平移
</span><span class='line'>//阴影,默认透明的，要设置shadowOpacity大于0才有效果
</span><span class='line'>shadowColor
</span><span class='line'>shadowOffset
</span><span class='line'>shadowOpacity
</span><span class='line'>shadowRadius</span></code></pre></td></tr></table></div></figure>



</div>
  
  


      | <a href="/blog/2016/11/29/rn-style/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/28/react-native-run-bug/">React Native 问题汇总</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-28T18:46:09+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:46 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Android 设备:小米 red note MUI 8.0, iOS 设备:iPhone 6Plus 8.3</p>

<h5>1.运行不起来</h5>

<p>按照<a href="https://facebook.github.io/react-native/docs/getting-started.html#content">官网</a>的步骤一步一步下来运行报：</p>

<pre><code>com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Failed to establish session
</code></pre>

<p><a href="https://github.com/facebook/react-native/issues/6499">这里</a>说小米系列的手机都这样，我们平时用Android Studio调试运行不是会弹出个弹出框问是否安装吗？这是用USB链接的，所以没问题，但是用命令就掉动不起来那弹出框&hellip;
<img src="/myimg/java/react_error_xm0.png" alt="" /></p>

<p>解决办法如下，关键是第4步，关闭小米的优化
<img src="/myimg/java/react_error_xm1.png" alt="" /></p>

<h5>2.运行不起来</h5>

<p>报错：</p>

<pre><code>com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Unable to upload some APKs
</code></pre>

<p>解决：把 /项目/android/build.gradle 文件里的 <code>classpath 'com.android.tools.build:gradle:1.3.1'</code> 改成 <code>classpath 'com.android.tools.build:gradle:1.2.3'</code>就可以了&hellip;.why? yeah,why?</p>

<h5>3.白屏</h5>

<p>运行起来了，等啊等，怎么还是白屏？不是有东西的吗？摇啊摇不是有弹出框的吗？弹出框呢？？</p>

<p>解决：进系统设置，应用管理，找到这个应用，点击应用详情里的权限管理，开启显示悬浮框。刷新一下再摇一摇就有弹出框了。</p>

<h5>4.Could not connect to development server</h5>

<p>摇啊摇弹出框后，点击最后的 <code>Dev Settings</code> ，然后设置 <code>Debug server host &amp; port for device</code> 为<code>本机IP:8081</code>后返回刷新出现如下错误:</p>

<p><img src="/myimg/java/react_error2.png" alt="" /></p>

<p>解决：命令行进入项目文件夹，运行如下命令：</p>

<pre><code>react-native start &gt; /dev/null 2&gt;&amp;1 &amp; curl "http://localhost:8081/index.android.bundle?platform=android" -o "android/app/src/main/assets/index.android.bundle"
</code></pre>

<p>如果提示没有 assets 文件夹，则先手动建一个再运行。之后就能真机运行起来了：</p>

<p><img src="/myimg/java/react_android.png" alt="" /></p>

<h5>iOS模拟器Cmd+R不刷新，Cmd+D也没弹出框</h5>

<p>解决：要开启模拟器的键盘链接。模拟器菜单<code>Hardware</code>-><code>Keyboard</code> 选中 <code>Connect Hardware Keyboard</code></p>
</div>
  
  


      | <a href="/blog/2016/11/28/react-native-run-bug/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/26/react-native-basic/">React</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-26T11:16:25+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:16 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>React 的核心思想是：封装组件! React 应用都是构建在组件之上，各个组件维护自己的状态和 UI，当状态变更，自动重新渲染自身组件。组件的第一个字母必须大写,组件只能包含一个顶层标签。</h4>

<p><strong>Remember that components may accept any props, including primitive values, React elements, or functions !.</strong></p>

<h4>Declarative</h4>

<p><a href="https://facebook.github.io/react/">React</a> 可以很好的创建交互式组件，设计不同状态下的组件，并且React可以根据组件的不同参数高效的刷新渲染。这样的组件可以让你的代码更加的可预测并且更方便调试。</p>

<h4>Component-Based</h4>

<p>基于组件，封装一个组件，让它们管理自己的状态，然后用它们去组成更加复杂的UI。由于组件的逻辑是写在JavaScript里的而不是模板里，这样你可以很轻松的让它穿梭于复杂的数据之间，并且在DOM外保持自己的状态。</p>

<h4>Learn Once, Write Anywhere</h4>

<p>我们不假定你现在的技术栈是怎样的，所以你可以不用重写已存在的代码来用React开放新的功能。React也可以在服务器端渲染，也可以用React Native创建强大的移动应用。</p>

<h4>A Simple Component</h4>

<p>React 组件调用 <code>render()</code> 方法来输入参数然后返回要显示的样子。这个例子用一个类似XML语言的我们称之为JSX，通过<code>this.props</code>输入数据传到组件内部可以被<code>render()</code>方法获取。使用React的话，JSX是可选的，不是必须要使用的。试着点击<code>Complied JS</code>去看看通过JSX编译器产生的原生的JavaScript 代码。</p>

<h4>A Stateful Component</h4>

<p>除了通过<code>this.props</code>来传入参数，组件可以通过<code>this.state</code>来维护自己内部状态的数据。当组件的状态数据改变时，渲染器就会重新调用<code>render()</code>方法来刷新。</p>

<h4>An Application</h4>

<p>使用<code>props</code>和<code>state</code>我们可以收集一个小型的代办事项申请。这个例子用<code>state</code>来跟踪当前列表和用户输入的数据。虽然事件处理程序似乎是呈现内联,他们会通过事件代理被收集和使用。</p>

<h4>A Component Using External Plugins</h4>

<p>React 是灵活的，并且提供了一个钩子来和库或框架进行链接。这个例子使用<code>remarkable</code>,一个外部的 Markdown 库，来实时转化文本内容。</p>

<p>哎呀~ 自己翻译果然别扭&hellip;😞  React 是什么呢？React 是Facebook 封装的一组JS代码库：</p>

<p><img src="/myimg/java/react.png" alt="" /></p>

<p>按它规则可封装一个一个模块组件，这个模块组件有自己的状态，自己的逻辑等，它是一个独立的东西，然后把这样的组件一个一个组合起来。按照React 的规则可以混合着写JavaScript和HTML,这样的一个组件就是一个独立的模块化的View。添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。</p>

<p>React 还封装了一个自己的虚拟的DOM，通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。因为如果大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个虚拟 DOM，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 <a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">diff</a> 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性。给组件设置一个 <code>ref</code> 属性，然后用 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点对象。</p>

<h4>Hello World</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;

    &lt;script type="text/babel"&gt;
    var MyComponent = React.createClass({
      render: function() {
        return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;
      }
    });

    ReactDOM.render(&lt;MyComponent name="World !" /&gt;,
                    document.getElementById('example') );
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>上面的代码中用React的语法自定义了一个组件叫<code>MyComponent</code>,这个组件返回一个块区间，里面显示 Hello + 这个组件的<code>name</code>属性值。注意script 的type 要声明为<code>text/babel</code>。这样就可以在其他地方使用这个自定义的组件了。可以把 <code>props</code> 看作是组件的配置属性，在组件内部是不变的，只是在调用这个组件的时候传入不同的属性值来定制显示这个组件。当组件状态 <code>state</code> 有更改的时候，React 会自动调用组件的 <code>render()</code> 方法重新渲染整个组件的 UI。<code>this.props</code> 对象的属性与组件的属性一一对应，<code>this.props.children</code> 表示组件的所有子节点。需要注意， <code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 <code>this.props.children</code> 的时候要小心。上面的代码把 HTML 直接嵌入了 JS 代码里面了，这就是 React 提出的一种叫 JSX 的语法。把原来网页设计的代码分离，现在又融合了！</p>

<p><img src="/myimg/java/react_hello.png" alt="" /></p>

<p>Hello World 运行起来了！嗯~ 我已经成功了一半！😆</p>

<h4>组件组合</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;

    &lt;script type="text/babel"&gt;

    var Avatar = React.createClass({
        render: function() {
            return (
                &lt;div&gt;
                    &lt;ProfilePic username={this.props.username} /&gt;
                    &lt;ProfileName username={this.props.username} /&gt;
                &lt;/div&gt;
            );
        }
       });

    var ProfilePic = React.createClass({
        render: function() {
            return (
                &lt;img src={'https://gss0.bdstatic.com/70cFsj3f_gcX8t7mm9GUKT-xh_/avatar/100/r6s1g6.gif'} /&gt;
            );
        }
    });

    var ProfileName = React.createClass({
        render: function() {
            return (
              &lt;div&gt;
                &lt;a href={'http://guimingsu.com'}&gt;
                    {this.props.username}
                &lt;/a&gt;
              &lt;/div&gt;
            );
        }
    });

    ReactDOM.render(
        &lt;Avatar username="hello world " /&gt;,
        document.getElementById('example')
      );

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这里显示了一个Avatar 组件，这个Avatar 组件是由两个更小的组件ProfilePic和ProfileName组合而成的。父组件和子组件间可以通过<code>props</code>一层一层的传值。Remember: React is all about one-way data flow down the component hierarchy.</p>

<p><img src="/myimg/java/react_hello0.png" alt="" /></p>

<h4>状态变化</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;
    &lt;script type="text/babel"&gt;

     var LikeButton = React.createClass({
      getInitialState: function() {
        return {liked: false};
      },

      handleClick: function(event) {
        this.setState({liked: !this.state.liked});
      },

      render: function() {
        var text = this.state.liked ? 'like' : 'haven\'t liked';
        return (
          &lt;p onClick={this.handleClick}&gt;
            You {text} this. Click to toggle.
          &lt;/p&gt;
        );
      }
    });

    ReactDOM.render(
      &lt;LikeButton /&gt;,
      document.getElementById('example')
    );

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>上面代码是一个 <code>LikeButton</code> 组件，它的 <code>getInitialState</code> 方法用于定义初始状态，也就是一个对象，这个对象可以通过 <code>this.state</code> 属性读取。当用户点击组件，导致状态变化，<code>this.setState</code> 方法就修改状态值，每次修改以后，自动调用 <code>this.render</code> 方法，再次渲染组件。
由于 <code>this.props</code> 和 <code>this.state</code> 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，<code>this.props</code> 表示那些一旦定义，就不再改变的特性，而 <code>this.state</code> 是会随着用户互动而产生变化的特性。即把要跟随某个参数实时变化的代码写在 <code>render: function() {};</code>里，然后在用户调用的方法里调用<code>this.setState({ });</code>方法来改变参数就可以了，因为他们触发<code>render</code>方法。这样就可以根据不同参数值自动显示不同内容。</p>

<h4>生命周期</h4>

<p>组件的生命周期分成三个状态：</p>

<ol>
<li>Mounting：已插入真实 DOM</li>
<li>Updating：正在被重新渲染</li>
<li>Unmounting：已移出真实 DOM</li>
</ol>


<p>React 为每个状态都提供了两种处理函数，<code>will</code> 函数在进入状态之前调用，<code>did</code> 函数在进入状态之后调用，三种状态共计五种处理函数。</p>

<ol>
<li>componentWillMount()</li>
<li>componentDidMount()</li>
<li>componentWillUpdate(object nextProps, object nextState)</li>
<li>componentDidUpdate(object prevProps, object prevState)</li>
<li>componentWillUnmount()</li>
</ol>


<p>此外，React 还提供两种特殊状态的处理函数:</p>

<ol>
<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</li>
<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用</li>
</ol>


<p><img src="/myimg/java/react_life.png" alt="" /></p>

<p>把这个<a href="https://facebook.github.io/react/docs/thinking-in-react.html">官方例子</a>看完就能收获不少了。主要在于思考，拿到设计图如何拆分模块，如何组建，如何选取放置状态参数，如何看懂别人写好的代码等。<a href="/mysrc/java/reactPriceDemo.zip">下载</a></p>

<h3>State 提升</h3>

<p>State 提升就是把本来A组件的state值，提升到它的父组件B中，然后在父组件B通过prop传递下去给A. A的点击事件要修改数据的话，就调用B通过prop传给A的方法，也就是A的事件回调到B去处理state了，然后B的state变化后又会刷新它的子组件A了，这个流程就叫 state提升。这主要是用来解决多个子组件A1,A2,A3&hellip;依赖于同一个state进行变化时的处理流程。</p>

<h3>ref</h3>

<p>ref 旧的语法使用 string 赋值，然后在 this.refs.xxx 获取，而新的ES6语法如下,用 => 定义方法写法。然后this.inStockOnlyInput 获取。</p>

<pre><code>    &lt;input 
        type="checkbox"
        ref={(input) =&gt; this.inStockOnlyInput = input}/&gt;
</code></pre>

<p>看明白了吗？没明白用<a href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-0&amp;code=%20%20%20%20%20%20%20%20%3Cinput%0A%20%20%20%20%20%20%20%20%20%20%20%20type%3D%22checkbox%22%0A%20%20%20%20%20%20%20%20%20%20%20%20ref%3D%7B(input">babel</a>%20%3D%3E%20this.inStockOnlyInput%20%3D%20input%7D%2F%3E)转一下就明白了。</p>

<pre><code>React.createElement("input", {
    type: "checkbox",
    ref: function ref(input) {
        return this.inStockOnlyInput = input;
    } });
</code></pre>

<h3>PureComponent</h3>

<p>在使用PureComponent的时候，如果直接修改对应的prop 或 state 是不会触发render的！ 如下面的代码使用PureComponent将没效果，而使用Component就可以。</p>

<pre><code>class WordAdder extends React.PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      words: ['marklar']
    };
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // This section is bad style and causes a bug
    const words = this.state.words;
    words.push('marklar');
    this.setState({words: words});
  }

  render() {
    return (
      &lt;div&gt;
        &lt;button onClick={this.handleClick} /&gt;
       {this.state.words}
      &lt;/div&gt;
    );
  }
}
  ReactDOM.render(
    &lt;WordAdder/&gt;,
    document.getElementById('root')
  );
</code></pre>

<p>如果要使用PureComponent有效果的话就不能直接修改prop 或 state 值！改成下面这样才正确。</p>

<pre><code>handleClick() {
  this.setState(prevState =&gt; ({
    words: prevState.words.concat(['marklar'])
  }));
}
</code></pre>

<p>或者用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a>来处理对象：</p>

<pre><code>function updateColorMap(colormap) {
  return Object.assign({}, colormap, {right: 'blue'});
}
</code></pre>

<p>或者用<a href="https://github.com/facebook/immutable-js">Immutable JS</a>处理数据</p>

<h5>链接</h5>

<ol>
<li><a href="https://facebook.github.io/react/">React</a></li>
<li><a href="https://babeljs.io/docs/learn-es2015/">ECMAScript6</a></li>
<li><a href="http://es6.ruanyifeng.com/">ECMAScript6</a></li>
<li><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5和ES6的写法对照表</a></li>
</ol>

</div>
  
  


      | <a href="/blog/2016/11/26/react-native-basic/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/24/atom-edit/">Atom</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-24T14:31:17+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:31 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://atom.io/">Atom</a>是由GitHub开发的一款免费开源的编辑器，通过给它安装不同的插件包，就可以变成一款智能的IDE了。这里主要记录一下为了开发<a href="https://facebook.github.io/react-native/">React Native</a>所安装的插件包及基本使用。</p>

<p><a href="https://nuclide.io/">Nuclide</a>是官方推荐的开发React Native的基于Atom的工具。Nuclide 安装好后进入设置，选中<code>Install Recommented Packages on Startup</code>选项，下次启动的时候就会安装Nuclide所建议安装的插件了。</p>

<h4>插件</h4>

<p><strong>atom-react-native-autocomplete :</strong>React Native自动提示。</p>

<p><strong>atom-beautify :</strong> 文件排版格式化。ctrl-alt-b，可以进它的设置里选中 Beauty on Save 自动格式化。</p>

<p><strong>atom-html-preview :</strong> html预览。 ctrl-shift-h
<img src="/myimg/java/atom-html-preview.png" width="700" alt="" /></p>

<p><strong>autocomplete-paths :</strong> 文件路径提示</p>

<p><img src="/myimg/java/autocomplete-paths.png" width="500" alt="" /></p>

<p><strong>color-picker :</strong>颜色选取器，点击色块即可弹出，或者右键选择 Color Picker.</p>

<p><img src="/myimg/java/color-picker.png" width="500" alt="" /></p>

<p><strong>docblockr :</strong> 快捷文档注释</p>

<p><strong>emmet :</strong>web开发神器</p>

<p><strong>file-icons :</strong>给文件加icon</p>

<p><img src="/myimg/java/file-icons.png" width="200" alt="" /></p>

<p><strong>highlight-selected :</strong>选中相同的字符串高亮
<img src="/myimg/java/highlight-selected.png" width="500" alt="" /></p>

<p><strong>js-hyperclick :</strong> js对象 cmd-点击 跳转</p>

<p><strong>merge-conflicts :</strong>解决版本冲突</p>

<p><strong>minimap :</strong>右边位置小地图
<img src="/myimg/java/minimap.png" width="700" alt="" /></p>

<p><strong>pigments :</strong> 显示颜色。 快捷面板里搜 Pigments: Show Palette 可以打开调色板🎨。</p>

<p><img src="/myimg/java/pigment.png" width="400" alt="" /></p>

<p><strong>pretty-json :</strong> Json 格式化。Packages->PrettyJson->Prettify</p>

<p><strong>react-snippets :</strong> React代码块快捷输入
<img src="/myimg/java/react-snippets.png" width="700" alt="" /></p>

<p><strong>sort-lines :</strong>把列按字母排序。功能键 f5(电脑，设置，键盘里要开启功能选项) 或者 Edit->Lines->Sort</p>

<p><strong>tool-bar :</strong>上面显示工具栏，ctrl-alt-t 开/关
<img src="/myimg/java/tool-bar.png" width="500" alt="" /></p>

<p>安装后的插件包不在Atom应用文件夹里，在 <code>/Users/用户名/.atom/packages/</code> 文件夹里。且 <code>.atom</code> 文件夹默认是隐藏的。在命令窗口输入显示文件夹命令。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//显示隐藏文件
</span><span class='line'>defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder
</span><span class='line'>//隐藏文件
</span><span class='line'>defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder</span></code></pre></td></tr></table></div></figure>


<p><img src="/myimg/java/packages.png" width="300" alt="" /></p>

<h4>包的默认值修改</h4>

<p>可以直接点击<code>View Code</code>打开包的代码修改。也可以像上面先显示文件夹，找到对应的包，然后修改里面的默认配置。在Settings -> Open Config Folder 也可以打开所有插件包的配置。
<img src="/myimg/java/package_change.png" width="700" alt="" /></p>

<h4>快捷键</h4>

<p>ctrl-space : 补全提示 (Mac要把设置->键盘->快捷键->Spotlight 里对应的快捷键取消掉! 不然电脑的优先级更高)</p>

<p>ctrl-alt-b : atom-beautify插件 代码格式化，为什么JSX格式化后有点乱&hellip;</p>

<p>cmd-shift-p : 打开快捷面板</p>

<p>cmd-f : 文件里搜索</p>

<p>cmd-shift-f : 项目里搜索</p>

<p>cmd-alt-[ : 折叠代码</p>

<p>cmd-alt-] : 展开代码</p>

<p>cmd-alt-shift-{ : 折叠所有代码</p>

<p>cmd-alt-shift-} : 展开所有代码</p>

<p>ctrl-[ : 左移动</p>

<p>ctrl-] : 右移动</p>

<p>ctrl-g : 跳转到某行</p>

<p>cmd-\ : 左边目录显示或隐藏</p>

<p>cmd-shift-o : 打开文件夹</p>

<p>cmd-b : 在打开的文件间切换</p>

<p>cmd-delete : 删除光标左边的</p>

<p>ctrl-shift-l : 删除一整行</p>

<p>ctrl-shift-&ldquo;+&rdquo; : 增大字体</p>

<p>ctrl-shift-&ldquo;-&rdquo; : 缩小字体</p>

<p><a href="https://github.com/kompasim/atom-plugins">[92款插件推荐]</a></p>

<p><a href="/myimg/channel_v3.json">channel_v3.json</a></p>

<p>嗯，还是WebStorm更专业！还有<a href="https://www.sublimetext.com/">Sublime Text</a> ,<a href="https://code.visualstudio.com/">VSCode</a>也和Atom类似，都是比较火的基于插件包的编辑器。</p>
</div>
  
  


      | <a href="/blog/2016/11/24/atom-edit/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/18/struts-spring-mybatis/">Struts + Spring + MyBatis</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-18T09:22:51+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>9:22 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>基本信息：</h4>

<p><code>Mac OS 10.11</code>, <code>eclipse neon</code>, <code>jdk1.8</code>, <code>tomcat7</code>, <code>struts2.5.5</code>, <code>spring4.3.4</code>, <code>mybatis3.4.1</code>,<code>mybatis-spring1.3</code>,<code>mysql数据库</code></p>

<h4>结构简介：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>用struts2的配置文件来控制方法的调用和页面的跳转，
</span><span class='line'>jps和Action通过strtus2标签方式或者EL表达式传值取值。
</span><span class='line'>Action负责业务逻辑处理，Action调用Service接口，Service接口注入某个Service的实现，
</span><span class='line'>在Service的实现里调用Dao来处理数据库。
</span><span class='line'>而Dao是用Mybatis通过对应的xml映射文件来关联的,
</span><span class='line'>且Action里的Service实现注入,Service实现类里的Dao注入,Dao的Section注入，
</span><span class='line'>都是通过Spring配置文件实现的。</span></code></pre></td></tr></table></div></figure>


<h4>截图:</h4>

<p><img src="/myimg/java/ssm_index.png" alt="" />
<img src="/myimg/java/ssm_list.png" alt="" />
<img src="/myimg/java/ssm_json.png" alt="" />
<img src="/myimg/java/ssm.png" alt="" /></p>

<p><a href="/mysrc/java/SSM.zip">下载</a></p>
</div>
  
  


      | <a href="/blog/2016/11/18/struts-spring-mybatis/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/17/springmvc-hibernate-jian/">SpringMVC + Hibernate</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-17T19:34:43+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>7:34 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>基本信息：</h4>

<p><code>Mac OS 10.11</code>, <code>eclipse neon</code>, <code>jdk1.8</code>, <code>tomcat7</code>, <code>spring4.3.4</code>, <code>Hibernate5.2.4</code>,<code>jackson2.5</code>,<code>mysql数据库</code></p>

<h4>截图:</h4>

<p><img src="/myimg/java/ssh_frame.png" alt="" />
<img src="/myimg/java/ssh_pack.png" alt="" /></p>

<h4>Controller从JSP取值</h4>

<pre><code>//1.使用HttpServletRequest获取
public String addUser(HttpServletRequest request) {
    String name = request.getParameter("name");
    String pass = request.getParameter("password");
    return "/addUser";
}
//2.使用注解
public String addUser(@RequestParam("name") String name,@RequestParam("password") String password) {
    System.out.println(name+password);
    return "/addUser";
}
//3.自动注入Entity属性
public String addUser(User user) {
    System.out.println(user.getName() + user.getPassword());
    return "/addUser";
}
</code></pre>

<h4>Controller传值给JSP</h4>

<pre><code>//1.使用HttpServletRequest 然后setAttribute()，就和Servlet中一样
public String getAllUser(HttpServletRequest request) {
    request.setAttribute("userList", userService.getAllUser());
    return "/index";
}
//2.使用Spring的ModelMap `public class ModelMap extends LinkedHashMap&lt;String, Object&gt;`，ModelMap数据会利用HttpServletRequest的Attribute传值
public String getAllUser(ModelMap modelMap) {
    modelMap.put("userList", userService.getAllUser());
    return "/index";
}
//3.HttpServletReequest的getSession()  
public String getAllUser(HttpServletRequest request) {
    HttpSession session = request.getSession();
    session.setAttribute("userList", userService.getAllUser());
    return "/index";
}
</code></pre>

<p><a href="/mysrc/java/SSH.zip">下载</a></p>
</div>
  
  


      | <a href="/blog/2016/11/17/springmvc-hibernate-jian/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/16/hibernate/">Hibernate 的使用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-16T09:20:12+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>9:20 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>可以认为MyBatis是半自动化，而Hibernate是全自动化(也可半自动)。MyBatis是面向表和列的SQL查询，而Hibernate是用面向对象和对象属性的 HQL查询。 HQL 查询被 Hibernate 翻译为传统的 SQL 查询从而对数据库进行操作。尽管Hibernate可以直接使用本地 SQL 语句，但还是尽可能的使用 HQL 语句，以避免数据库移植产生的麻烦。在 HQL 中一些关键字比如 SELECT ，FROM 和 WHERE 等，是不区分大小写的，但对象名和属性名是区分大小写的。Hibernate也可以用注解方式来进行对象和表的关系映射，类似于<a href="http://ormlite.com/">OrmLit</a>这样。</p>

<p><img src="/myimg/java/hibernate_frame.png" alt="" /></p>

<p>和Mybatis 很像，都是加载配置文件得到SessionFactory, 然后通过SessionFactory获取 Session,然后用Session进行HQL操作。</p>

<p>Hibernate(5.2.4)配置文件</p>

<pre><code>&lt;?xml version="1.0" encoding="GBK"?&gt;  
&lt;!DOCTYPE hibernate-configuration PUBLIC  
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"  
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;
&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:mysql://localhost:8889/java_db&lt;/property&gt;
        &lt;property name="connection.username"&gt;root&lt;/property&gt;
        &lt;property name="connection.password"&gt;root&lt;/property&gt;
        &lt;!-- 指定连接池里最大连接数 --&gt;
        &lt;property name="hibernate.c3p0.max_size"&gt;50&lt;/property&gt;
        &lt;!-- 指定连接池里最小连接数 --&gt;
        &lt;property name="hibernate.c3p0.min_size"&gt;5&lt;/property&gt;
        &lt;!-- 指定连接池里连接的超时时长 --&gt;
        &lt;property name="hibernate.c3p0.timeout"&gt;3000&lt;/property&gt;
        &lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt;
        &lt;property name="hibernate.c3p0.max_statements"&gt;100&lt;/property&gt;
        &lt;property name="hibernate.c3p0.idle_test_perxiod"&gt;3000&lt;/property&gt;
        &lt;property name="hibernate.c3p0.acquire_increment"&gt;2&lt;/property&gt;
        &lt;property name="hibernate.c3p0.validate"&gt;true&lt;/property&gt;
        &lt;!-- 指定数据库方言 --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt;
        &lt;!-- 根据需要自动创建数据表 --&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;
        &lt;!-- 显示Hibernate持久化操作所生成的SQL --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;
        &lt;!-- 将SQL脚本进行格式化后再输出 --&gt;
        &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;

        &lt;!-- 下面罗列所有的映射文件 --&gt;
        &lt;mapping resource="com/sgm/config/user.xml" /&gt;

    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre>

<p>对象到表的映射文件</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; 
&lt;hibernate-mapping package="com.sgm.bean"&gt;
   &lt;class name="User" table="user"&gt;
      &lt;id name="id" type="int" column="id"&gt;
         &lt;generator class="native"/&gt;
      &lt;/id&gt;
      &lt;property name="name" column="name" type="string"/&gt;
      &lt;property name="password" column="password" type="string"/&gt;
   &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>基本使用</p>

<pre><code>public class Main {
    private static SessionFactory factory;
    static{
        try {
            Configuration config = new Configuration().configure("com/sgm/config/hibernate.xml");
            factory = config.buildSessionFactory();
        } catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
        }
    }

@SuppressWarnings("unchecked")
public static void main(String[] args) {
    Session session = factory.openSession();
    Transaction transaction = null;
    try {
        transaction = session.beginTransaction();
        //数据库处理

        transaction.commit();
    } catch (Exception e) {
        if (transaction != null)
            transaction.rollback();
        e.printStackTrace();
    } finally {
        session.close();
    }
  }
}
</code></pre>

<p><img src="/myimg/java/hibernate_zsg.png" alt="" /></p>

<p>一般情况下，用不带entityName参数的方法就可以了。带entityName的是hibernate在探索不使用pojo类进行O/R，不建议使用。</p>

<h4>查询</h4>

<pre><code>//from后面是对象！不是表名！对象和表在mapper文件里关联好了。hql面向的是对象，不是表！
String hql = "FROM User as u where u.id &gt;= 17 ";
Query&lt;User&gt; query = session.createQuery(hql);
List&lt;User&gt; list = query.getResultList();

//用setParameter设置查询参数，setFirstResult和setMaxResults可用于分页
String hql="from User as u where u.name=? and u.password = :password ORDER BY u.id DESC";
Query&lt;User&gt; query=session.createQuery(hql);
query.setParameter(0, "andy");
query.setParameter("password", "123");
query.setFirstResult(1);//从结果集的那一条开始(包括这一条)
query.setMaxResults(2);//最多几条
List&lt;User&gt; list=query.getResultList();

//query也可以用于批量修改和删除 
String hql = "UPDATE User set name = :name WHERE id &gt;= :id";
//String hql = "DELETE from User WHERE name = :name and id &gt;= :id";
Query&lt;User&gt; query = session.createQuery(hql);
query.setParameter("name", "andy hello");
query.setParameter("id", 19);
int result = query.executeUpdate();
System.out.println("处理了几条数据: " + result);
</code></pre>

<h4><a href="https://docs.jboss.org/hibernate/entitymanager/3.5/reference/en/html/querycriteria.html">CriteriaQuery</a> <a href="https://github.com/treehouse/giflib-hibernate/commit/f97a2828a466e849d8ae84884b5dce60a66cf412">废弃更新日志</a></h4>

<p>注意新的创建方式引用的包是 <code>import javax.persistence.criteria.CriteriaQuery</code>,而不是<code>import org.hibernate.criterion.CriteriaQuery</code>!!!</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//旧的已被废弃
</span><span class='line'>session.createCriteria(User.class) 的创建方式已经被废弃
</span><span class='line'>//改为这样,因为5.2.4的session已经继承了EntityManager，所以可以直接getCriteriaBuilder()。
</span><span class='line'>CriteriaBuilder cb = session.getCriteriaBuilder();
</span><span class='line'>CriteriaQuery&lt;User&gt; query = cb.createQuery(User.class);
</span><span class='line'>Root&lt;User&gt; user = query.from(User.class);
</span><span class='line'>query.select(user).where(cb.equal(user.get("name"), "andy"));
</span><span class='line'>List&lt;User&gt; list = session.createQuery(query).getResultList();</span></code></pre></td></tr></table></div></figure>


<h4>原生SQL</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>String sql = "select * from user where id = :tmpId";
</span><span class='line'>NativeQuery&lt;User&gt; nativeQuery = session.createNativeQuery(sql,User.class);
</span><span class='line'>nativeQuery.setParameter("tmpId", 19);
</span><span class='line'>nativeQuery.setFirstResult(1);
</span><span class='line'>nativeQuery.setMaxResults(2);
</span><span class='line'>List&lt;User&gt; list = nativeQuery.getResultList();
</span><span class='line'>//nativeQuery.executeUpdate(); 修改或者删除</span></code></pre></td></tr></table></div></figure>


<h4>one-to-many / many-to-one</h4>

<p>举个栗子： <code>User(单方)----Book(多方)</code>,一个user有多个book, 一个book只属于一个user。</p>

<pre><code>public class User {
    public int id;
    public String name;
    private Set&lt;Book&gt; books = new HashSet&lt;Book&gt;();
    //下面 getter setter
}

public class Book {
    public int id;
    public String name;
    public User user;
    //下面 getter setter
}
</code></pre>

<p>User mapper</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;
&lt;hibernate-mapping package="com.sgm.bean"&gt;
    &lt;class name="User" table="user"&gt;
        &lt;id name="id" type="int" column="id"&gt;
            &lt;generator class="native" /&gt;
        &lt;/id&gt;
        &lt;property name="name" column="name" type="string" /&gt;

        &lt;set name="books" inverse="true" cascade="all"&gt;
            &lt;key column="userId"&gt;&lt;/key&gt;
            &lt;one-to-many class="com.sgm.bean.Book" /&gt;
        &lt;/set&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>Book mapper</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;
&lt;hibernate-mapping package="com.sgm.bean"&gt;
    &lt;class name="Book" table="book"&gt;
        &lt;id name="id" type="int" column="id"&gt;
            &lt;generator class="native" /&gt;
        &lt;/id&gt;
        &lt;property name="name" column="name" type="string" /&gt;

        &lt;many-to-one name="user" class="com.sgm.bean.User"&gt;
            &lt;column name="userId"&gt;&lt;/column&gt;
        &lt;/many-to-one&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>测试</p>

<pre><code>public class Main {
    private static SessionFactory factory;
    static {
        try {
            Configuration config = new Configuration().configure("com/sgm/config/hibernate.xml");
            factory = config.buildSessionFactory();
        } catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
        }
    }

    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        Session session = factory.openSession();
        Transaction transaction = null;
        try {
            transaction = session.beginTransaction();
            // do some work
            User user = new User();
            user.setName("andy");

            Book book1 = new Book();
            book1.setName("哈利波特");
            book1.setUser(user);

            Book book2 = new Book();
            book2.setName("功夫之王");
            book2.setUser(user);

            user.getBooks().add(book1);
            user.getBooks().add(book2);

            session.save(user);

            transaction.commit();
        } catch (Exception e) {
            if (transaction != null)
                transaction.rollback();
            e.printStackTrace();
        } finally {
            session.close();
        }
    }
}
</code></pre>

<p><img src="/myimg/java/hibernate_om.png" alt="" /></p>

<h4>中文乱码</h4>

<p>用Hibernate 插入中文到MySQL数据库时，即使MySQL数据库设置编码 <code>Character set = utf-8</code> 还是乱码。要改Hibernate 的配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;property name="connection.url"&gt;jdbc:mysql://localhost:8889/java_db&lt;/property&gt;
</span><span class='line'>//改为
</span><span class='line'>&lt;property name="connection.url"&gt;&lt;![CDATA[jdbc:mysql://localhost:8889/java_db?useUnicode=true&characterEncoding=utf8]]&gt;&lt;/property&gt;</span></code></pre></td></tr></table></div></figure>



</div>
  
  


      | <a href="/blog/2016/11/16/hibernate/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/15/spring-ioc/">Spring 依赖注入</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-15T09:17:48+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>9:17 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://spring.io/">Spring</a>是一个大东西，框架集合。Spring MVC, Spring AOP, Spring IoC&hellip;等等。先看看Spring IoC(Inversion of Control)控制反转。就是把原先要手动 new 一个对象，现在只要在Srping 的配置文件里配置就可以了，从主动控制对象，到被动接收对象，这就叫控制反转，也叫依赖注入(dependency injection)！ 依赖注入是Spring的核心机制，把对象之间的依赖关系转为用配置文件来管理，这有赖于它的核心组件 Beans, Core, Context 。</p>

<p><img src="/myimg/java/spring_core.png" alt="" /></p>

<p>开始之前要下载Spring jar包，但是官网上只看到了maven 和 gradle 的添加方式，要手动下载jar包还不好找呢，藏得跟宝藏似的。<a href="http://repo.spring.io/release/org/springframework/spring/">Spring jar 包下载</a>，还需要它的依赖包 <a href="http://commons.apache.org/proper/commons-logging/download_logging.cgi">Commons Logging</a>。</p>

<p><img src="/myimg/java/spring_jar.png" alt="" /></p>

<p>把上面的包下载下来添加到项目里，然后 Add to build path。</p>

<p><img src="/myimg/java/spring_add.png" alt="" /></p>

<p>Spring 可以用注解方式注入和xml方式注入。</p>

<h5>1.注解的方式注入一个接口的实现</h5>

<p>接口定义</p>

<pre><code>public interface MessageInterface {
   public String getMessage();
   public String getName();
}
</code></pre>

<p>操作Action</p>

<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component //必须要
public class MessageAction {

final private MessageInterface service;

@Autowired //可不要
public MessageAction(MessageInterface service) {
    this.service = service;
}

public void printMessage() {
    System.out.println(this.service.getMessage() + this.service.getName());
  }
}
</code></pre>

<p>测试类</p>

<pre><code>import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.*;

@Configuration //可不要
@ComponentScan //必须要
public class Application {
    @Bean
    MessageInterface injectImp() {
        return new MessageInterface() {
            public String getMessage() {
              return "Hello World!";
            };

        public String getName(){
            return "sgm";
        }
    };
}

  public static void main(String[] args) {
      ApplicationContext context = new AnnotationConfigApplicationContext(Application.class);
      MessageAction printer = context.getBean(MessageAction.class);
      printer.printMessage();
  }
}
</code></pre>

<p>结果打印出</p>

<pre><code>Hello World!sgm
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Configuration 用于标注一个类，表示bean定义的源文件
</span><span class='line'>@ComponentScan  用于标注一个类，表示扫描指定包中的@Component标注的类。通过该实例得到 ApplicationContext
</span><span class='line'>@Component  用于标注一个类组件，然后通过 ApplicationContext 对象获取
</span><span class='line'>@Bean 用于注入一个实例对象，相当于Spring &lt;bean&gt;XML里的配置
</span><span class='line'>@Autowired  用于标注setter方法，构造器，包含多个参数的方法，集合等等，用于自动注入绑定实例</span></code></pre></td></tr></table></div></figure>


<h5>2.用xml的方式注入一个接口的实现</h5>

<p>如下，UserService是接口，里面定义一个print()方法。UserServiceImp是UserService的一个实现类，实现print(&ldquo;hello wrold&rdquo;)。</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="userService" class="com.sgm.implement.UserServiceImp"/&gt;

&lt;/beans&gt;
</code></pre>

<p>userService.print()就会打印出绑定实现类里的"hello wrold"。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> ApplicationContext context =  new ClassPathXmlApplicationContext("com/sgm/spring/bean.xml");
</span><span class='line'> UserService userService = (UserService) context.getBean("userService");
</span><span class='line'> userService.print();</span></code></pre></td></tr></table></div></figure>


<p>用xml的方式还可以通过类的构造函数注入，上面的例子是通过属性的set方法注入的。</p>

<pre><code>&lt;bean id="serviceProvider" class="com.sgm.service.ServiceProvider"&gt;
    &lt;constructor-arg ref="userService"&gt;&lt;/constructor-arg&gt;  
&lt;/bean&gt; 

&lt;bean id="userService" class="com.sgm.implement.UserServiceImp"/&gt;
</code></pre>

<p>xml默认都是注入一个单例对象的，即bean的属性 scope = &ldquo;singleton&rdquo; 为默认值。如果要每次都注入一个新对象，则设置bean的属性 scope = &ldquo;prototype"。</p>
</div>
  
  


      | <a href="/blog/2016/11/15/spring-ioc/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/14/mybatis/">MyBatis 的使用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-14T19:26:25+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>7:26 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Mybatis是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>

<p>需要两个包：<a href="https://github.com/mybatis/mybatis-3/releases">MyBatis包</a>和<a href="https://www.mysql.com/products/connector/">JDBC Driver for MySQL</a></p>

<p>无论是用过的mybatis和hibernate他们的共同点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1.从配置文件(通常是XML配置文件中)得到sessionfactory
</span><span class='line'>2.由sessionfactory产生session
</span><span class='line'>3.在session中完成对数据的增删改查和事务提交等
</span><span class='line'>4.在用完之后关闭session 
</span><span class='line'>5.在java 对象和数据库之间有mapping的配置文件，也通常是xml文件</span></code></pre></td></tr></table></div></figure>


<p>主要XML配置文件中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源和决定事务范围和控制方式的事务管理器。通过加载该文件获取SqlSessionFactory。</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;!--对象别名定义 --&gt;
    &lt;typeAliases&gt;
        &lt;typeAlias alias="User" type="com.sgm.java.User" /&gt;
    &lt;/typeAliases&gt;

&lt;!--数据库连接 --&gt;
&lt;environments default="development"&gt;
    &lt;environment id="development"&gt;
        &lt;transactionManager type="JDBC" /&gt;
        &lt;dataSource type="POOLED"&gt;
            &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt;
            &lt;property name="url" value="jdbc:mysql://localhost:8889/java_db" /&gt;
            &lt;property name="username" value="root" /&gt;
            &lt;property name="password" value="root" /&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;

&lt;!--数据库操作映射文件 --&gt;
&lt;mappers&gt;
    &lt;mapper resource="com/sgm/mybatis/User.xml" /&gt;
&lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>

<p>数据库操作映射文件</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;!--namespace很重要，绑定对应的接口文件！--&gt;
&lt;mapper namespace="com.sgm.java.UserDao"&gt;

&lt;resultMap type="User" id="resultListUser"&gt;
    &lt;result column="name" property="name" /&gt;
    &lt;result column="age" property="age" /&gt;
&lt;/resultMap&gt;

&lt;!--id名字要和UserDao里的方法名一样  --&gt;
&lt;insert id="addUser" parameterType="User" useGeneratedKeys="true" keyProperty="id"&gt;
    insert into user(name, age) values(#{name}, #{age});
&lt;/insert&gt;

&lt;delete id="deleteUserById" parameterType="int"&gt;
    delete from user where id = #{id};
&lt;/delete&gt;

&lt;update id="updateUser" parameterType="User" &gt;
     update user set name = #{name}, age = #{age} where id = #{id};
&lt;/update&gt;

&lt;select id="getAllUsers" resultMap="resultListUser"&gt;
    select * from user ;
&lt;/select&gt;

&lt;select id="selectUserById" parameterType="int" resultType="User"&gt;
   select * from user where id = #{id};
&lt;/select&gt;
&lt;/mapper&gt;
</code></pre>

<p>定义数据库操作接口，方法要和对应的映射文件里的id名称一样！</p>

<pre><code>public interface UserDao {
    //  方法名要和User.xml配置文件里的id名称一样
    public void addUser(User user);

    public void deleteUserById(int id);

    public void updateUser(User user);

    public List&lt;User&gt; getAllUsers();

    public User selectUserById(int id);
}
</code></pre>

<p>操作的Java对象</p>

<pre><code>public class User {
        public int id;
        public String name;
        public int age;

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre>

<p>测试</p>

<pre><code>public class Main {
    private static Reader reader;
    private static SqlSessionFactory sqlSessionFactory;

static {
    try {
        reader = Resources.getResourceAsReader("MyBatisConfig.xml");
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public static void main(String[] args) {
    SqlSession session = sqlSessionFactory.openSession();
    UserDao userDao = session.getMapper(UserDao.class);

    try {
//          // 增
//          User newUser = new User();
//          newUser.setName("andy");
//          newUser.setAge(20);
//          userDao.addUser(newUser);
//          session.commit();//必须提交
//          System.out.println("reult------： 新增的userId " + newUser.getId());    
//          //删
//          userDao.deleteUserById(1);
//          session.commit();//必须提交

//          //改
//          User updateUser = new User();
//          updateUser.setId(4);
//          updateUser.setName("andy");
//          updateUser.setAge(20);
//          userDao.updateUser(updateUser);
//          session.commit();//必须提交

//          //列表
//          List&lt;User&gt; userList = userDao.getAllUsers();
//          for(User user : userList){
//              System.out.println("reult------：  " + user.getName());            
//          }
            //查单个
//          User user = userDao.selectUserById(4);
//          System.out.println("reult------：  " + user.getName());
        } finally {
            session.close();//必须关闭
        }
    }
}
</code></pre>

<h3>传参方式</h3>

<h5>1.用下标获取</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//Dao层接口定义
</span><span class='line'>public User selectUser(String name,String password);
</span><span class='line'>//对应的映射方法,用下标获取
</span><span class='line'>&lt;select id="selectUser" resultMap="userList"&gt;
</span><span class='line'>    select  *  from user where name = #{0} and password=#{1}
</span><span class='line'>&lt;/select&gt;
</span><span class='line'>//定义userList
</span><span class='line'>&lt;resultMap type="User" id="userList"&gt;
</span><span class='line'>  &lt;result column="id" property="id" /&gt;
</span><span class='line'>  &lt;result column="name" property="name" /&gt;
</span><span class='line'>  &lt;result column="password" property="password" /&gt;
</span><span class='line'>&lt;/resultMap&gt;</span></code></pre></td></tr></table></div></figure>


<h5>2.传自定义对象</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void updateUser(User user);
</span><span class='line'>&lt;update id="updateUser" parameterType="User"&gt;
</span><span class='line'>  update user set name = #{name}, password = #{password} where id = #{id};
</span><span class='line'>&lt;/update&gt;
</span><span class='line'>//定义User别名
</span><span class='line'>&lt;typeAliases&gt;
</span><span class='line'>  &lt;typeAlias alias="User" type="com.sgm.bean.User" /&gt;
</span><span class='line'>&lt;/typeAliases&gt;</span></code></pre></td></tr></table></div></figure>


<h5>3.用注解的方式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public User selectUser(@Param("name")String name,@Param("password")String password);
</span><span class='line'>&lt;select id="selectUser" resultType="User"&gt;
</span><span class='line'>  select * from user where name = #{name} and password = #{password};
</span><span class='line'>&lt;/select&gt;</span></code></pre></td></tr></table></div></figure>


<h4>动态SQL语句</h4>

<pre><code>&lt;select id="selectSameAddressUser" parameterType="User" resultType="userList"&gt;
    select * from user 
        &lt;if test="name != null"&gt;
            title = #{name}
        &lt;/if&gt;
        &lt;if test="address != null"&gt;
            and address = #{address}
        &lt;/if&gt;
&lt;/select&gt;
</code></pre>

<h3>注意!</h3>

<h5>SqlSessionFactoryBuilder</h5>

<p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围,也就是局部方法变量。可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p>

<h5>SqlSessionFactory</h5>

<p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次。因此 SqlSessionFactory 的最佳范围是应用范围。可以使用单例模式或者静态单例模式。</p>

<h5>SqlSession</h5>

<p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的范围是请求或方法范围。不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。每次操作应该打开一个 SqlSession，处理数据，处理完后就关闭它。关闭操作很重要，应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SqlSession session = sqlSessionFactory.openSession();
</span><span class='line'>try {
</span><span class='line'>  // do work
</span><span class='line'>} finally {
</span><span class='line'>  session.close();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



</div>
  
  


      | <a href="/blog/2016/11/14/mybatis/#comments">Comments</a>


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/12/30/utf8/">Unicode、UTF-8编码起源</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/28/google-protocol-buffer/">Google Protocol Buffer</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/27/suan-fa/">排序算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/21/es6/">ECMAScript 6</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/20/weex/">Weex</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>android (9)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (9)</a></li>
<li class='category'><a href='/blog/categories/java/'>java (6)</a></li>
<li class='category'><a href='/blog/categories/javascript/'>javascript (4)</a></li>
<li class='category'><a href='/blog/categories/other/'>other (5)</a></li>
<li class='category'><a href='/blog/categories/react/'>react (8)</a></li>

  </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - guimingsu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
