<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[阿贵]]></title>
  <link href="http://andyfightting.github.io/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-08-31T15:49:43+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android手势滑动返回]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/31/android-swipe/"/>
    <updated>2016-08-31T15:16:10+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/31/android-swipe</id>
    <content type="html"><![CDATA[<p>偶然间发现了一个Android自带的抽屉控件DrawerLayout,就觉得应该可以用他来封装成手势返回的基础控件。思路就是先设置Activity的跳转动画是从右到左，并且前一个Activity不能动。然后设置DrawerLayout的menu从右边出来，然设置menu全屏，这个menu就相当于子Activity View的容器，默认打开menu,然后设置DrawerLayout容器透明，当DrawerLayout close的时候finish它所在的Activity就可以啦！！复杂的手势控制就交由自带的DrawerLayout处理啦，生命周期还是Activity的生命周期。怎么样，是不是机智如我！！😆</p>

<pre><code>package com.suguiming.myandroid.base;
import android.os.Bundle;
import android.support.v4.view.GravityCompat;
import android.support.v4.widget.DrawerLayout;
import android.support.v7.app.ActionBarDrawerToggle;
import android.support.v7.app.AppCompatActivity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.WindowManager;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;

import com.suguiming.myandroid.R;

public class BaseSwipeActivity extends AppCompatActivity {

private DrawerLayout drawer;
private LinearLayout containerLayout;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    setContentView(R.layout.activity_base_swipe);

    containerLayout = (LinearLayout) findViewById(R.id.container_layout);

    drawer = (DrawerLayout) findViewById(R.id.base_drawer_layout);
    drawer.openDrawer(GravityCompat.END);
    ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawer, R.string.navigation_drawer_open, R.string.navigation_drawer_close) {
        @Override
        public void onDrawerClosed(View drawerView) {
            super.onDrawerClosed(drawerView);
            finish();
        }
    };
    drawer.setDrawerListener(toggle);
}

//子类不要用setContentView,用setMainView!!!!
public void setMainView(int viewId) {
    LayoutInflater inflater = LayoutInflater.from(this);
    View tmpView = inflater.inflate(viewId, null);

    if (tmpView instanceof LinearLayout) {
        LinearLayout.LayoutParams linearLayoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(linearLayoutParams);
    } else if (tmpView instanceof RelativeLayout) {
        RelativeLayout.LayoutParams relativeLayoutParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(relativeLayoutParams);
    }
    containerLayout.removeAllViews();
    containerLayout.addView(tmpView);
}

}
</code></pre>

<p>对应的布局文件</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:background="@android:color/transparent"
    tools:context="com.suguiming.myandroid.base.BaseSwipeActivity"&gt;

&lt;android.support.v4.widget.DrawerLayout
    android:id="@+id/base_drawer_layout"
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/transparent"
    tools:openDrawer="end"&gt;
    &lt;LinearLayout
        android:orientation="vertical"
        android:background="@color/clear"
        android:layout_width="match_parent"
        android:layout_height="match_parent"&gt;
    &lt;/LinearLayout&gt;

    &lt;!---64dp是源码menu的margin,这里设置为65,不然会有一条黑线--&gt;
    &lt;LinearLayout
        android:id="@+id/container_layout"
        android:orientation="vertical"
        android:layout_gravity="end"
        android:layout_marginLeft="-65dp"
        android:background="@color/light_gray"
        android:layout_width="match_parent"
        android:layout_height="match_parent"&gt;
    &lt;/LinearLayout&gt;
&lt;/android.support.v4.widget.DrawerLayout&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p>push 的动画 style</p>

<pre><code>&lt;!--手势返回theme--&gt;
&lt;style name="BackSwipeTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;
    &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt;
    &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt;
    &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt;
    &lt;item name="android:backgroundDimEnabled"&gt;false&lt;/item&gt;
    &lt;item name="android:windowAnimationStyle"&gt;@style/ActivitySwipeBackAnimation&lt;/item&gt;
&lt;/style&gt;
&lt;style name="ActivitySwipeBackAnimation" parent="@android:style/Animation.Activity"&gt;
    &lt;item name="android:activityOpenEnterAnimation"&gt;@anim/activity_swipe_in&lt;/item&gt;
    &lt;item name="android:activityOpenExitAnimation"&gt;@anim/activity_swipe_out&lt;/item&gt;
    &lt;item name="android:activityCloseEnterAnimation"&gt;@anim/activity_swipe_in&lt;/item&gt;
    &lt;item name="android:activityCloseExitAnimation"&gt;@anim/activity_swipe_out&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>使用的话就是让Activity继承BaseSwipeActivity，然后设置Activity的Theme为BackSwipeTheme。</p>

<pre><code>public class ActivitySwipeBack extends BaseSwipeActivity {
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    //要用setMainView，不要用setContentView
    setMainView(R.layout.activity_activity_swipe_back);
  }
}

&lt;activity android:name=".tab0.ActivitySwipeBack"
            android:theme="@style/BackSwipeTheme"/&gt;
</code></pre>

<p>完整Demo请查看<a href="https://github.com/AndyFightting/MyAndroid">MyAndroid</a>中的"手势滑动返回"。</p>

<p><img src="http://andyfightting.github.io/myimg/android/android_swipe.png" alt="imge" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift阅读笔记]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/swift-read/"/>
    <updated>2016-08-04T16:23:05+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/swift-read</id>
    <content type="html"><![CDATA[<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let 声明常量，var 声明变量，会自动进行类型推断(小数推断为Double),一行末尾可不加分号(;)。
</span><span class='line'>值永远不会被隐式转换为其他类型，务必显示强制转换。
</span><span class='line'>if语句的条件不能默认非0为真。 类型后加?号表示可选值，要么有值，要么是nil。
</span><span class='line'>用 if let(或者var) name = optionName 来获取可选值处理。 
</span><span class='line'>switch的case中自带break，switch要保证全部遍历，否则必须要有default选项。
</span><span class='line'>0&lt; x &lt;4 等价 0..&lt;4 , 0&lt; x &lt;=4 等价 0...4 。 
</span><span class='line'>用 func 声明函数，用-&gt;指定返回类型func greet(name: String, day: String) -&gt; String { ... }。 
</span><span class='line'>元组概念，一般用做函数返回值。 
</span><span class='line'>func sumOf(numbers: Int...) -&gt; Int {}，...表示可变个数的参数。 
</span><span class='line'>函数是一等类型，像int float一样，可用作参数或者返回值。 
</span><span class='line'>class 声明类,属性都要赋值，要么在声明直接写死，要么在init方法中赋值。 
</span><span class='line'>重写父类方法必须用 override 标记。 属性可以有get set willGet didSet 等方法。 
</span><span class='line'>mutating关键字用来标记一个会修改结构体(属性)的方法。 
</span><span class='line'>extension来为现有的类型添加功能，比如新的方法和计算属性。
</span><span class='line'>泛型(指定类型)就是java中的泛型。 Bool值是true或false。 
</span><span class='line'>typealies name = 类型 给类型起个别名。 
</span><span class='line'>OC中的nil只用在对象上(int不行)，Swift中nil可指任何东西(对象或int)。
</span><span class='line'>使用!来获取一个不存在的可选值会导致错误。隐式解析可选类型(类型!)就是可选类型，但是可以当做非可选类型来使用(不用!解析,没值时会报错)。 
</span><span class='line'>throws do try catch 的使用。Swift的赋值操作不返回任何值。% 浮点数也可以取余运算。 
</span><span class='line'>空合运算符(a ?? b)对可选类型a进行空判断，如果a包含一个值就进行解封，否则就返回一个默认值b(b和a要类型相同)。逻辑 &&，|| 都是短路计算的。
</span><span class='line'>条件中的下划线 _ 来忽略对值的访问，case 中的下划线 _ 表示所有可能的值,case中可进行值绑定，case条件可用where语句。 
</span><span class='line'>字典的遍历顺序和插入顺序可能不同(字典无序的)。 
</span><span class='line'>Swift语言的repeat-while循环合其他语言中的do-while循环是类似的。
</span><span class='line'>注意循环中switch中的continue(开始下次)和break(跳到switch}后面继续执行)的差别，switch中的fallthrouth进入下一个case时不会再进行条件判断。
</span><span class='line'>guard(守卫)语句总是有一个else分句。 
</span><span class='line'>调用函数时第一个参数名不要，之后的参数名要，用逗号分开(第一个参数省略其外部参数名，第二个以后的参数使用其本地参数名作为自己的外部参数名。
</span><span class='line'>所有参数需要有不同的本地参数名，但可以共享相同的外部参数名。如果你提供了外部参数名，那么函数在被调用时，必须使用外部参数名。如果你不想为第二个及后续的参数设置参数名，用下划线_代替)。
</span><span class='line'>一个函数最多只能有一个可变参数(...),如果函数同时有默认参数和可变参数要把可变参数放最后。 
</span><span class='line'>函数参数默认是常量，修改会报错，但可以用var声明为变量,修改只在函数体内有效。 
</span><span class='line'>inout参数(只能传入变量)会替换原来的值，使用时在变量名前加&符号。 
</span><span class='line'>原数组不会被sort()方法修改。 闭包就是用{}包起来的函数代码块，用in分开返回值和处理代码，参数不能有默认值。如果需要将闭包作为最后一个参数，可变成尾随闭包。
</span><span class='line'>Array的map方法可返回不同类型。 函数和闭包都是引用类型。
</span><span class='line'>结构体和枚举是值类型，所有的基本类型都是值类型，并且都是以结构体的形式在后台所实现。
</span><span class='line'>类是引用类型。常量实例依然可改变其中的变量属性值。
</span><span class='line'>swift指针并不直接指向内存中的某个地址，而且也不要求你使用星号（*）来表明你在创建一个引用。
</span><span class='line'>结构体实例总是通过值传递，类实例总是通过引用传递。
</span><span class='line'>Swift 中字符串（String）,数组（Array）和字典（Dictionary）均以结构体的形式实现的值类型,而在OC中是以类的形式实现的引用类型。
</span><span class='line'>计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。
</span><span class='line'>如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使定义了变量存储属性，由于结构体（struct）属于值类型，当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。
</span><span class='line'>必须将延迟存储属性声明成变量（使用var关键字），因为属性的初始值可能在实例构造完成之后才会得到。
</span><span class='line'>而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。
</span><span class='line'>计算属性不直接存储值，而是提供一个 get和一个可选的set，来间接获取和设置其他属性或变量的值。
</span><span class='line'>必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。
</span><span class='line'>父类的属性在子类的构造器中被赋值时，它在父类中的willSet和didSet观察器会被调用。
</span><span class='line'>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy特性。局部范围的常量或变量不会延迟计算。
</span><span class='line'>必须给存储类型的类属性指定默认值，因为类型本身无法在初始化过程中使用构造器给类型属性赋值。
</span><span class='line'>结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的动画]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/animation/"/>
    <updated>2016-08-04T16:22:41+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/animation</id>
    <content type="html"><![CDATA[<p>动画是作用的UIView的CALayer上的，UIView是CALayer的代理，给CALayer提供数据参数，CALayer负责渲染和动画。UIView是在UIKit框架中，而CALayer是在QuartzCore框架中。UIView可以响应用户事件，而CALayer不可以响应用户事件。CALayer也可以像UIView一样添加子Layer。
<img src="http://andyfightting.github.io/myimg/ios/calayer.png" alt="image" /></p>

<h4>CALayer常用属性</h4>

<pre><code>anchorPoint 和中心点position重合的一个点，称为“锚点”，锚点的描述是相对于x、y位置比例而言的默认在图像中心点(0.5,0.5)的位置
backgroundColor 图层背景颜色  
borderColor 边框颜色    
borderWidth 边框宽度    
bounds  图层大小    
contents    图层显示内容，例如可以将图片作为图层内容显示
contentsRect    图层显示内容的大小和位置    
cornerRadius    圆角半径    
doubleSided 图层背面是否显示，默认为YES 
frame   图层大小和位置，不支持隐式动画，所以CALayer中很少使用frame，通常使用bounds和position代替
hidden  是否隐藏    
mask    图层蒙版    
maskToBounds    子图层是否剪切图层边界，默认为NO 
opacity 透明度 ，类似于UIView的alpha    
position    图层中心点位置，类似于UIView的center
shadowColor 阴影颜色    
shadowOffset    阴影偏移量 
shadowOpacity   阴影透明度，注意默认为0，如果设置阴影必须设置此属性
shadowPath  阴影的形状 
shadowRadius    阴影模糊半径  
sublayers   子图层   
sublayerTransform   子图层形变 
transform   图层形变
</code></pre>

<p>要注意position和anchorPoint的区别：<strong>position是layer中的anchorPoint点在superLayer中的位置坐标！position点是相对suerLayer的，anchorPoint点是相对自身layer的！</strong> 所以说position不变，但anchorPoint改变的话，也会改变layer在superLayer中的位置！</p>

<pre><code>layer=[[CALayer alloc]init];
layer.backgroundColor=[UIColor purpleColor].CGColor;
layer.bounds=CGRectMake(0, 0, 100,100);
layer.shadowColor=[UIColor redColor].CGColor;
layer.shadowOffset=CGSizeMake(5, 5);
layer.shadowOpacity=0.7;
layer.borderColor=[UIColor yellowColor].CGColor;
layer.borderWidth=3;
layer.position=CGPointMake(size.width/2, size.height/2);
[self.view.layer addSublayer:layer];

//layer.anchorPoint=CGPointMake(0, 0); //图一
//layer.anchorPoint=CGPointMake(0, 1); //图二
</code></pre>

<p>图中position一样，但anchorPoint不一样，所以图片位置也不一样。  <br/>
<img src="http://andyfightting.github.io/myimg/ios/layer_position.png" alt="image" />
注意如果要设置圆角，对于图层本身而言可以正常显示，但是对于图层中绘制的图片无法正确显示。如果想要图片正确显示则必须设置masksToBounds=YES，剪切子图层。但设置layer.masksToBounds=YES后，图层的影效果无法和masksToBounds=YES同时使用，因为masksToBounds的目的就是剪切外边框。如果同时要阴影又要圆角的话，就用两个重叠的图层,底部负责绘制阴影，上层负责绘制圆角。</p>

<h4>Core Animation</h4>

<p>iOS的核心动画Core Animation包含在Quartz Core框架中。核心动画分为几类：基础动画、关键帧动画、动画组、转场动画,各个类的关系大致如下：
<img src="http://andyfightting.github.io/myimg/ios/core_animation.png" alt="image" />
*CAAnimation：核心动画的基础类，不能直接使用，负责动画运行时间、速度的控制，本身实现了CAMediaTiming协议。</p>

<p>*CAPropertyAnimation：属性动画的基类，通过属性进行动画设置，不能直接使用。</p>

<p>*CAAnimationGroup：动画组合模式，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</p>

<p>*CATransition：转场动画，主要通过滤镜进行动画效果设置。</p>

<p>*CABasicAnimation：基础动画，通过属性修改进行动画参数控制，只有初始状态和结束状态。</p>

<p>*CAKeyframeAnimation：关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</p>

<p>基础动画、关键帧动画都属于属性动画，就是通过修改属性值产生动画效果，只需要设置初始值和结束值，中间的过程动画由系统自动计算产生。和基础动画不同的是关键帧动画可以设置多个属性值，每两个属性中间的过渡动画由系统自动完成。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的Core Data]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/core-data/"/>
    <updated>2016-08-04T16:22:22+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/core-data</id>
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/library/watchos/documentation/Cocoa/Conceptual/CoreData/index.html">Core Data</a>是一个对sqlite数据库进行封装的ORM(Object Relation Mapping)框架。它主要由以下几部分组成：</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObject_Class/">NSManagedObject</a></h4>

<p>NSManagedObject is a generic class that implements all the basic behavior required of a Core Data model object. It is not possible to use instances of direct subclasses of NSObject (or any other class not inheriting from NSManagedObject) with a managed object context. You may create custom subclasses of NSManagedObject, although this is not always required. If no custom logic is needed, a complete object graph can be formed with NSManagedObject instances.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectModel_Class/">NSManagedObjectModel</a></h4>

<p>An NSManagedObjectModel object describes a schema, a collection of entities (data models) that you use in your application.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/">NSManagedObjectContext</a></h4>

<p>An instance of NSManagedObjectContext represents a single “object space” or scratch pad in an application. Its primary responsibility is to manage a collection of managed objects. These objects form a group of related model objects that represent an internally consistent view of one or more persistent stores. A single managed object instance exists in one and only one context, but multiple copies of an object can exist in different contexts. Thus object uniquing is scoped to a particular context.</p>

<h4><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSPersistentStoreCoordinator_Class/">NSPersistentStoreCoordinator</a></h4>

<p>Instances of NSPersistentStoreCoordinator associate persistent stores (by type) with a model (or more accurately, a configuration of a model) and serve to mediate between the persistent store or stores and the managed object context or contexts. Instances of NSManagedObjectContext use a coordinator to save object graphs to persistent storage and to retrieve model information. A context without a coordinator is not fully functional as it cannot access a model except through a coordinator. The coordinator is designed to present a façade to the managed object contexts such that a group of persistent stores appears as an aggregate store. A managed object context can then create an object graph based on the union of all the data stores the coordinator covers.</p>

<h4><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/CoreDataFramework/Classes/NSFetchRequest_Class/index.html#//apple_ref/occ/cl/NSFetchRequest">NSFetchRequest</a></h4>

<p>An instance of NSFetchRequest describes search criteria used to retrieve data from a persistent store.</p>

<h4><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSPredicate_Class/">NSPredicate</a></h4>

<p>The NSPredicate class is used to define logical conditions used to constrain a search either for a fetch or for in-memory filtering.</p>

<p><img src="http://andyfightting.github.io/myimg/ios/cd_orm.png" alt="image" />
<img src="http://andyfightting.github.io/myimg/ios/cd_table.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的NSURLSession]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/session/"/>
    <updated>2016-08-04T16:22:02+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/session</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的block]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/04/block/"/>
    <updated>2016-08-04T16:21:41+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/04/block</id>
    <content type="html"><![CDATA[<p>block就是一个代码块，闭包，会捕获上下文的匿名函数，它可以作为参数或者返回值进行传递。在objc中，根据对象的定义，凡是首地址是*isa的结构体指针，都可以认为是对象(id)，所以block实际上就算是对象，但它的内存管理又和NSObject有点不一样。</p>

<h4>声明:</h4>

<pre><code>*变量：returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};

*属性：@property (nonatomic, copy) returnType (^blockName)(parameterTypes);

*方法：-(void)someMethod:(returnType (^nullability)(parameterTypes))blockName;

*回调：[object  method:^returnType (parameters) {...}];

*定义：typedef returnType (^TypeName)(parameterTypes); --&gt; TypeName blockName = ^returnType(parameters) {...};
</code></pre>

<p>block中的isa指向的是该block的Class,主要有三种类型：</p>

<pre><code>_NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量。
_NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。
_NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。
</code></pre>

<p>当block第一次被创建时，它是存在于该函数的栈上的，其Class是固定的NSConcreteStackBlock。其捕获的变量是会赋值到结构体的成员上，所以当block初始化完成后，捕获到的变量不能更改。当函数返回时，函数的栈被销毁，这个block的内存也会被清除。所以在函数结束后仍然需要这个block时，就必须用Block_copy()方法将它拷贝到堆上，类型变为NSConcreteMallocBlock，向它发送retain，增加block的引用计数。</p>

<p>默认block捕获到的局部变量，都是赋值给block的结构体的，相当于const不可改。为了让block能访问并修改外面的局部变量，需要加上__block修饰词。</p>

<pre><code>void test(){
 __block int i = 3;
  void(^myBlock)(void) = ^{
     i = 5;//局部变量没有__block修饰的话不可修改
  };
 myBlock();
}
</code></pre>

<h4>捕获规则：</h4>

<pre><code>1.静态存储区的变量,例如全局变量、方法中的static变量:
  引用，可修改。

2.block接受的参数传值:
  可修改，和一般函数的参数相同。

3.栈变量(局部变量):
  常量，不可修改，block会对id类型的变量产生强引用。

4.栈变量(有__block前缀的局部变量):
  引用，可以修改。如果是id类型则不会被block retain、如果该类型是C类型变量，该值会被挪动到堆中。
</code></pre>

<p>在ARC中，block被赋值传递的时候会自动拷贝到堆上，堆上的对象就有可能被释放掉，所以要用copy强引用着,以免野指针crash。</p>

<h4>循环引用:</h4>

<p>当block被copy到堆之后，该block对它捕获的对象产生强引用，所以有时需要避免block copy后产生的循环引用。</p>

<p>如self引用了block，block又捕获了self，这样就会有循环引用,因此，需要用weak来声明self。</p>

<pre><code>- (void)test {
    ViewController * __weak weakSelf = self;
    self.block = ^{
        [weakSelf doSomething]; //用弱引用,打破循环引用
    }
}
</code></pre>

<p>如果捕获到的是对象的成员变量对象，也会间接造成对self的循环引用，同样也要避免。</p>

<pre><code>- (void)test {
    id tempPropertyObj = _propertyObj; //用临时变量,避免了循环引用
    self.block = ^{
        [tempPropertyObj doSomething];
    }
}
</code></pre>

<h4>问题</h4>

<pre><code>[UIView animateWithDuration:0.5 animations:^{
        [self doSomething];
    }];
</code></pre>

<p>上面例子并不会造成循环引用，因为block强引用了self,而self并没有强引用block。如果像下面就会循环引用：self &ndash;> _observer &ndash;> block &ndash;> self 这也是一个循环引用。</p>

<pre><code>//_observer 是self的实例变量
    _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"test"
                                                                  object:nil
                                                                   queue:[NSOperationQueue mainQueue]
                                                              usingBlock:^(NSNotification * _Nonnull note) {
                                                                  [self doSomething];
                                                              }];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的Runloop与Runtime]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/01/runtime/"/>
    <updated>2016-08-01T10:20:14+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/01/runtime</id>
    <content type="html"><![CDATA[<h3><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">Runloop</a></h3>

<p>Runloop与线程息息相关，它是线程的基础架构部分，每个线程都有自己的runloop对象，可以用[NSRunLoop currentRunLoop]来得到它。主线程中的runloop是启动运行状态，而自己创建的线程中的runloop默认是没有启动的，需要的话要手动去启动。Runloop是一个事件处理循环，用来不停的监听输入事件或者定时事件，并将其分配到对应的目标上进行处理。它可以使线程在有工作的时候工作，没有工作的时候休眠。</p>

<p>Runloop同时也负责autorelease pool的创建和释放，每当一个运行循环结束的时候，它都会释放autorelease pool，同时pool中的所有自动释放类型变量都会被释放掉。NSRunloop不是线程安全的，而CFRunLoopRef是线程安全的。RunLoop要指定在特定Mode下Run：</p>

<p>*NSDefaultRunLoopMode：处理大多数的操作，一般情况下用这个。</p>

<p>*NSRunLoopCommonModes：For Cocoa applications, this set includes the default, modal, and event tracking modes by default. Core Foundation includes just the default mode initially.</p>

<p>而且通过scheduleInRunLoop的方式启动的请求，虽然是在主线程中执行！但也会有异步的效果！SDWebImageDownloader 中的 NSURLConnection 就是这样启动请求的！！</p>

<pre><code>- (void)start{
    NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:15];
    self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];
    [connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
    [connection start];
    if (connection){
        self.imageData = [NSMutableData data];
    }else{
        if ([delegate respondsToSelector:@selector(imageDownloader:didFailWithError:)]){
            [delegate performSelector:@selector(imageDownloader:didFailWithError:) withObject:self withObject:nil];
        }
    }
}
</code></pre>

<p>NSURLConnection在代理方法中打印出的线程：
<img src="http://andyfightting.github.io/myimg/ios/sdrunloop.png" alt="iamge" /></p>

<p>runloop监听用户输入事件和定时事件
<img src="http://andyfightting.github.io/myimg/ios/runloop.png" alt="image" /><!--more--></p>

<h3><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Runtime</a></h3>

<p>Runtime是个很重要的概念，iOS之所以是动态语言就是因为它。它的核心是一个用C和编译语言写的Runtime库。它是Objective-C面向对象和动态机制的基石。静态语言是在编译的时候就已经绑定好了某个方法名会执行哪段函数地址。而动态语言不是在编译的时候就已经绑定好了，它是在具体要执行的某个方法的时候，才根据方法名去寻找具体执行的方法地址，所以可以在这时候动态的改变它的绑定。可以在<a href="https://opensource.apple.com/tarballs/objc4/">这里</a>下载源码查看。</p>

<p>&ldquo;计算机界，只要再加一层中间层，就没有解决不了的问题。如果有，那再加一层，直到它解决。"这句话不知道是在哪里看到的了&hellip;不过说的挺有道理的。而Runtime库正是Objective-C之所以为动态语言的中间层！</p>

<p>在Objective-C中，类、对象和方法都是一个C的结构体，从objc/objc.h头文件中，我们可以找到他们的定义：</p>

<pre><code>//---NSObject-----
@interface NSObject &lt;NSObject&gt; {
     Class isa 
}

//---Class-----
typedef struct objc_class *Class;

//---objc_class-----
struct objc_class {
    Class isa 
    Class super_class                                        
    const char *name                                         
    long version                                             
    long info                                                
    long instance_size //对象大小                                      
    struct objc_ivar_list *ivars //属性列表                             
    struct objc_method_list **methodLists //方法列表                   
    struct objc_cache *cache  //方法映射缓存                               
    struct objc_protocol_list *protocols   //代理列表                   
};

//---objc_method----
struct objc_method {  
    SEL method_name //方法名
    char *method_types //a string representing argument/return types
    IMP method_imp  //方法地址
};
</code></pre>

<p>Objective-C的函数调用在编译的时候会被翻译为 -objc_msgSend(执行的对象，方法名，参数&hellip;),先通过isa指针找到它的Class,然后在method list里找方法，没有的话就上superClass中找，一旦找到，就去执行，然后把方法名和对应的方法地址映射保存在objc_cache中，下次就直接从这缓存中取。如果都没找到，会在程序报unrecognized selector sent to&hellip;错误之前还有机会补救，就是动态的给它指定一个执行方法！</p>

<p>首先，Objective-C运行时会调用+resolveInstanceMethod:或者+resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回YES，那运行时系统就会重新启动一次消息发送的过程。下面用当我调用test方法的时候，没有test的实现方法，但把它动态绑定给了newTest方法去执行！</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    [self performSelector:@selector(test) withObject:nil afterDelay:0];
}

void newTest(){
    NSLog(@"success !!");
}

+ (BOOL)resolveInstanceMethod:(SEL)aSEL{
    if(aSEL == @selector(test)){
        class_addMethod([self class], aSEL, (IMP)newTest, nil);
        return YES;
    }
    return [super resolveInstanceMethod:aSEL];
}
</code></pre>

<p>如果resolveInstanceMethod：方法返回NO话，就会转到-forwardingTargetForSelector:方法中去执行,让这个方法在其他对象中去执行！如下面把test方法传递给 viewController2 对象去执行，在 viewController2 对象中实现的 test 方法就会被调用！！</p>

<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)aSEL{
    return NO;
}

- (id)forwardingTargetForSelector:(SEL)aSelector{
    if(aSelector == @selector(test)){
        return viewController2;//传递给viewController2对象去执行 test方法
    }
    return [super forwardingTargetForSelector:aSelector];
}
</code></pre>

<p>如果forwardingTargetForSelector：方法返回nil或者self的时候，就会进入- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector:方法中去执行，如果这方法返回了一个NSMethodSignature对象，这会进入-forwardInvocation:方法中，把消息传给对应的对象去执行！如下将会在viewController2中执行test方法！！</p>

<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)aSEL{
    return NO;
}

- (id)forwardingTargetForSelector:(SEL)aSelector{
    return self;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    NSMethodSignature* signature = [super methodSignatureForSelector:aSelector];
    if (signature==nil) {
        signature = [viewController2 methodSignatureForSelector:aSelector];
    }
    return signature;
}

- (void)forwardInvocation:(NSInvocation *)invocation{
    SEL sel = invocation.selector;
    if([viewController2 respondsToSelector:sel]) {
        [invocation invokeWithTarget:viewController2];
    }else {
        [self doesNotRecognizeSelector:sel];
    }
}
</code></pre>

<p>如果这三个过程下来都没绑定具体的执行方法，则会进入- (void)doesNotRecognizeSelector:(SEL)aSelector方法，然后程序奔溃!!</p>

<p><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>下面的例子中，当调用test1方法的时候，具体执行是跑到test2方法中的！！</p>

<pre><code>@implementation ViewController
+ (void)load {
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    Class class = [self class];

    SEL originalSelector = @selector(test1);
    SEL swizzledSelector = @selector(test2);

    Method originalMethod = class_getInstanceMethod(class, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);

    BOOL didAddMethod =
    class_addMethod(class,
                    originalSelector,
                    method_getImplementation(swizzledMethod),
                    method_getTypeEncoding(swizzledMethod));

    if (didAddMethod) {
        class_replaceMethod(class,
                            swizzledSelector,
                            method_getImplementation(originalMethod),
                            method_getTypeEncoding(originalMethod));
    } else {
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
});
}

- (void)viewDidLoad {
    [super viewDidLoad];
    [self test1];
}
-(void)test1{
    NSLog(@"开始1");
}
-(void)test2{
    NSLog(@"开始2");
}
</code></pre>

<p>Swizzling应该总是在+load中执行,在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。</p>

<p>这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>

<p>Swizzling应该总是在dispatch_once中执行, 因为swizzling会改变全局状态，所以我们需要它确保代码只被执行一次，不管有多少个线程，而GCD的dispatch_once可以确保这种行为。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的CoreText]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/26/core-text/"/>
    <updated>2015-12-26T15:16:23+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/26/core-text</id>
    <content type="html"><![CDATA[<p>CoreText进行图文混排的核心思想是把需要摆放图片的位置用空字符替换原来的字符，并且实现CTRunDelegate，用于动态设置空字符的高度和宽度（代表图片的大小），并且对这些空字符设置一个属性名来区别于其他CTRun，之后进行图片渲染的时候就能通过该属性来区分哪些空字符是代表图片的占位符，哪些是普通的空字符。使用CoreText处理点击事件的关键是判断点击的位置是本文内容中的第几个字符，然后通过判断该字符是否在需要处理点击事件的字符串范围内。</p>

<p><img src="http://andyfightting.github.io/myimg/ios/text2.png" alt="image" /><!--more-->
<img src="http://andyfightting.github.io/myimg/ios/coreText.png" alt="image" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#import "CoreTextView.h"
</span><span class='line'>#import &lt;CoreText/CoreText.h&gt;
</span><span class='line'>
</span><span class='line'>@implementation CoreTextView{
</span><span class='line'>    CTFrameRef ctFrame;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (id)initWithFrame:(CGRect)frame
</span><span class='line'>{
</span><span class='line'>    self = [super initWithFrame:frame];
</span><span class='line'>    if (self) {
</span><span class='line'>        // Initialization code
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)drawRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    //得到当前用于绘制画布的上下文，用于后续将内容绘制在画布上
</span><span class='line'>    CGContextRef context = UIGraphicsGetCurrentContext();
</span><span class='line'>    
</span><span class='line'>    //翻转当前的坐标系, 因为对于底层绘制引擎来说，屏幕左下角为（0，0)
</span><span class='line'>    CGContextSetTextMatrix(context, CGAffineTransformIdentity);
</span><span class='line'>    CGContextTranslateCTM(context, 0, self.bounds.size.height);
</span><span class='line'>    CGContextScaleCTM(context, 1.0, -1.0);
</span><span class='line'>    
</span><span class='line'>    //要绘制的文字
</span><span class='line'>    NSMutableAttributedString* attributedString = [[NSMutableAttributedString alloc] initWithString:@"少年不识愁滋味，爱上层楼。爱上层楼。为赋新词强说愁。而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。"];
</span><span class='line'>    //为所有文本设置字体
</span><span class='line'>    [attributedString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:10] range:NSMakeRange(0, [attributedString length])];
</span><span class='line'>    //设置某些字体更大
</span><span class='line'>    [attributedString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(10, 10)];
</span><span class='line'>    //index 从0开始的2个字符 字体颜色 设置为蓝色
</span><span class='line'>    [attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(0, 2)];
</span><span class='line'>    //index 从2开始的3个字符 字体颜色 设置为红色
</span><span class='line'>    [attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(2, 3)];
</span><span class='line'>    //设置行间距 50
</span><span class='line'>    CGFloat lineSpacing = 50;
</span><span class='line'>    CTParagraphStyleSetting theSettings[3] = {
</span><span class='line'>        {kCTParagraphStyleSpecifierLineSpacingAdjustment, sizeof(CGFloat), &lineSpacing},
</span><span class='line'>        {kCTParagraphStyleSpecifierMaximumLineSpacing, sizeof(CGFloat), &lineSpacing},
</span><span class='line'>        {kCTParagraphStyleSpecifierMinimumLineSpacing, sizeof(CGFloat), &lineSpacing}
</span><span class='line'>    };
</span><span class='line'>    CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, 3);
</span><span class='line'>    [attributedString addAttribute:(id)kCTParagraphStyleAttributeName value:(__bridge id)theParagraphRef range:NSMakeRange(0, attributedString.length)];
</span><span class='line'>    CFRelease(theParagraphRef);
</span><span class='line'>    
</span><span class='line'>    //要插入的图片
</span><span class='line'>    NSString *imageName = @"testImage.png";
</span><span class='line'>    
</span><span class='line'>    //为图片设置CTRunDelegate 计算留给图片的空间大小
</span><span class='line'>    CTRunDelegateCallbacks imageCallbacks;
</span><span class='line'>    imageCallbacks.version = kCTRunDelegateVersion1;
</span><span class='line'>    imageCallbacks.getAscent = GetAscentCallback;
</span><span class='line'>    imageCallbacks.getDescent = GetDescentCallback;
</span><span class='line'>    imageCallbacks.getWidth = GetWidthCallback;
</span><span class='line'>    
</span><span class='line'>    //设置图片位置，大小
</span><span class='line'>    CTRunDelegateRef runDelegate = CTRunDelegateCreate(&imageCallbacks, imageName);
</span><span class='line'>    NSMutableAttributedString *imageAttributedString = [[NSMutableAttributedString alloc] initWithString:@" "];//空格用于给图片留位置
</span><span class='line'>    [imageAttributedString addAttribute:(NSString *)kCTRunDelegateAttributeName value:(id)runDelegate range:NSMakeRange(0, 1)];//用代理设置图片
</span><span class='line'>    CFRelease(runDelegate);
</span><span class='line'>    
</span><span class='line'>    //把图片插入到字符串中
</span><span class='line'>    [imageAttributedString addAttribute:@"imageAttribute" value:imageName range:NSMakeRange(0, 1)];
</span><span class='line'>    [attributedString insertAttributedString:imageAttributedString atIndex:1];//图片插入位置，不能越界
</span><span class='line'>    [attributedString insertAttributedString:imageAttributedString atIndex:3];//图片插入位置，不能越界
</span><span class='line'>    [attributedString insertAttributedString:imageAttributedString atIndex:5];//图片插入位置，不能越界
</span><span class='line'>    
</span><span class='line'>    //根据attributedString生成CTFramesetterRef
</span><span class='line'>    CTFramesetterRef ctFramesetter = CTFramesetterCreateWithAttributedString((CFMutableAttributedStringRef)attributedString);
</span><span class='line'>    CGMutablePathRef path = CGPathCreateMutable();
</span><span class='line'>    CGRect bounds = CGRectMake(0.0, 0.0, self.bounds.size.width, self.bounds.size.height);
</span><span class='line'>    CGPathAddRect(path, NULL, bounds);
</span><span class='line'>    
</span><span class='line'>    //绘制文字
</span><span class='line'>    ctFrame = CTFramesetterCreateFrame(ctFramesetter,CFRangeMake(0, [attributedString length ]), path, NULL);
</span><span class='line'>    CTFrameDraw(ctFrame, context);
</span><span class='line'>    
</span><span class='line'>    //下面都是为了绘制图片
</span><span class='line'>    CFArrayRef lines = CTFrameGetLines(ctFrame);
</span><span class='line'>    CGPoint lineOrigins[CFArrayGetCount(lines)];
</span><span class='line'>    CTFrameGetLineOrigins(ctFrame, CFRangeMake(0, 0), lineOrigins);
</span><span class='line'>    
</span><span class='line'>    //遍历每个CTLine
</span><span class='line'>    for (int i = 0; i &lt; CFArrayGetCount(lines); i++) {
</span><span class='line'>        CTLineRef line = CFArrayGetValueAtIndex(lines, i);
</span><span class='line'>        CGFloat lineAscent;
</span><span class='line'>        CGFloat lineDescent;
</span><span class='line'>        CGFloat lineLeading;
</span><span class='line'>        CTLineGetTypographicBounds(line, &lineAscent, &lineDescent, &lineLeading);
</span><span class='line'>        
</span><span class='line'>        CFArrayRef runs = CTLineGetGlyphRuns(line);
</span><span class='line'>        for (int j = 0; j &lt; CFArrayGetCount(runs); j++) {
</span><span class='line'>            CGFloat runAscent;
</span><span class='line'>            CGFloat runDescent;
</span><span class='line'>            CGPoint lineOrigin = lineOrigins[i];
</span><span class='line'>            CTRunRef run = CFArrayGetValueAtIndex(runs, j);
</span><span class='line'>            NSDictionary* attributes = (NSDictionary*)CTRunGetAttributes(run);
</span><span class='line'>            
</span><span class='line'>            CGRect runRect;
</span><span class='line'>            runRect.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0,0), &runAscent, &runDescent, NULL);
</span><span class='line'>            runRect=CGRectMake(lineOrigin.x + CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL), lineOrigin.y - runDescent, runRect.size.width, runAscent + runDescent);
</span><span class='line'>            
</span><span class='line'>            NSString *isImage = [attributes objectForKey:@"imageAttribute"];
</span><span class='line'>            //图片渲染逻辑
</span><span class='line'>            if (isImage) {
</span><span class='line'>                UIImage *image = [UIImage imageNamed:imageName];
</span><span class='line'>                if (image) {
</span><span class='line'>                    CGRect imageDrawRect;
</span><span class='line'>                    imageDrawRect.size = image.size;
</span><span class='line'>                    imageDrawRect.origin.x = runRect.origin.x + lineOrigin.x;
</span><span class='line'>                    imageDrawRect.origin.y = lineOrigin.y;
</span><span class='line'>                    CGContextDrawImage(context, imageDrawRect, image.CGImage);
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    //释放资源
</span><span class='line'>    //    CFRelease(ctFrame); //因为点击要用ctFrame，所以放dealloc里释放
</span><span class='line'>    CFRelease(path);
</span><span class='line'>    CFRelease(ctFramesetter);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//接受触摸事件
</span><span class='line'>-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
</span><span class='line'>    UITouch *touch = [touches anyObject];
</span><span class='line'>    CGPoint location = [touch locationInView:self];
</span><span class='line'>    
</span><span class='line'>    //获取每一行
</span><span class='line'>    CFArrayRef lines = CTFrameGetLines(ctFrame);
</span><span class='line'>    CGPoint origins[CFArrayGetCount(lines)];
</span><span class='line'>    //获取每行的原点坐标
</span><span class='line'>    CTFrameGetLineOrigins(ctFrame, CFRangeMake(0, 0), origins);
</span><span class='line'>    CTLineRef line = NULL;
</span><span class='line'>    CGPoint lineOrigin = CGPointZero;
</span><span class='line'>    for (int i= 0; i &lt; CFArrayGetCount(lines); i++){
</span><span class='line'>        CGPoint origin = origins[i];
</span><span class='line'>        CGPathRef path = CTFrameGetPath(ctFrame);
</span><span class='line'>        //获取整个CTFrame的大小
</span><span class='line'>        CGRect rect = CGPathGetBoundingBox(path);
</span><span class='line'>        //坐标转换，把每行的原点坐标转换为uiview的坐标体系
</span><span class='line'>        CGFloat y = rect.origin.y + rect.size.height - origin.y;
</span><span class='line'>        //判断点击的位置处于那一行范围内
</span><span class='line'>        if ((location.y &lt;= y) && (location.x &gt;= origin.x)){
</span><span class='line'>            line = CFArrayGetValueAtIndex(lines, i);
</span><span class='line'>            lineOrigin = origin;
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    location.x -= lineOrigin.x;
</span><span class='line'>    //获取点击位置所处的字符位置，就是相当于点击了第几个字符
</span><span class='line'>    CFIndex index = CTLineGetStringIndexForPosition(line, location)-1;//index从0开始
</span><span class='line'>    UIAlertView* alert = [[UIAlertView alloc]initWithTitle:@"提示" message:[NSString stringWithFormat:@"点击了第 %d 个字符！！",(int)index] delegate:self cancelButtonTitle:@"ok" otherButtonTitles:nil, nil];
</span><span class='line'>    [alert show];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void)dealloc{
</span><span class='line'>    [super dealloc];
</span><span class='line'>    CFRelease(ctFrame);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>#pragma mark CTRunDelegate Callbacks
</span><span class='line'>CGFloat GetAscentCallback( void *refCon ){
</span><span class='line'>    NSString *imageName = (NSString *)refCon;
</span><span class='line'>    return [UIImage imageNamed:imageName].size.height;
</span><span class='line'>}
</span><span class='line'>CGFloat GetDescentCallback(void *refCon){
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>CGFloat GetWidthCallback(void *refCon){
</span><span class='line'>    NSString *imageName = (NSString *)refCon;
</span><span class='line'>    return [UIImage imageNamed:imageName].size.width;
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>运行结果
<img src="http://andyfightting.github.io/myimg/ios/coreResult.png" alt="image" /></p>

<h3>*TextKit</h3>

<p>由于用CoreText是用绘图方式实现图文混排，复杂难用。所以在iOS7新推出了新的文字排版技术 &ndash; TextKit。使用TextKit可以很方便的实现富文本、表情混排和图文混排等效果。它是UIKit framework中定义的一组用于提供高性能的排版、布局和展示文字的类和协议，比如展示特别的字间距、行间距、断行规则。从上面图2可知，它是基于CoreText的，且UILabel,UITextField,UITextView又都是基于TextKit的。</p>

<pre><code>UILabel* label = [[UILabel alloc]initWithFrame:self.view.bounds];
label.text = @"少年不识愁滋味，爱上层楼。爱上层楼。为赋新词强说愁。而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。";
label.numberOfLines = 0;
label.userInteractionEnabled = YES;
[self.view addSubview:label];

NSMutableAttributedString * attributeString = [label.attributedText mutableCopy];
[attributeString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, 10)];//设置颜色
[attributeString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:25] range:NSMakeRange(0, 5)];//设置字体
[attributeString addAttribute:NSUnderlineStyleAttributeName value:@(NSUnderlineStyleSingle) range:NSMakeRange(0, 15)];//设置下划线
[attributeString addAttribute:NSStrokeWidthAttributeName value:@(2) range:NSMakeRange(0, 3)];//设置空心字

//插入图片1
UIImage * image1 = [UIImage imageNamed:@"fengye.png"];
NSTextAttachment * attachment1 = [[NSTextAttachment alloc] init];
attachment1.bounds = CGRectMake(0, 0, 60, 60);
attachment1.image = image1;
NSAttributedString * attachStr1 = [NSAttributedString attributedStringWithAttachment:attachment1];
[attributeString insertAttributedString:attachStr1 atIndex:1];

//插入图片2
UIImage * image2 = [UIImage imageNamed:@"fengye.png"];
NSTextAttachment * attachment2 = [[NSTextAttachment alloc] init];
attachment2.bounds = CGRectMake(0, 0, 30, 30);
attachment2.image = image2;
NSAttributedString * attachStr2 = [NSAttributedString attributedStringWithAttachment:attachment2];
[attributeString insertAttributedString:attachStr2 atIndex:5];

label.attributedText = [attributeString copy];

//    TextView 通过如下可以设置环绕图片的文字
//    UIBezierPath * path = [UIBezierPath bezierPathWithRect:rect];
//    textView.textContainer.exclusionPaths = @[path];
</code></pre>

<p><img src="http://andyfightting.github.io/myimg/ios/textkit1.png" alt="image" /></p>

<pre><code> NSAttributedString属性key的说明
 NSFontAttributeName                设置字体属性，默认值：字体：Helvetica(Neue) 字号：12
 NSForegroundColorAttributeName     设置字体颜色，取值为 UIColor对象，默认值为黑色
 NSBackgroundColorAttributeName     设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色
 NSLigatureAttributeName            设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符
 NSKernAttributeName                设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄
 NSStrikethroughStyleAttributeName  设置删除线，取值为 NSNumber 对象（整数）
 NSStrikethroughColorAttributeName  设置删除线颜色，取值为 UIColor 对象，默认值为黑色
 NSUnderlineStyleAttributeName      设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似
 NSUnderlineColorAttributeName      设置下划线颜色，取值为 UIColor 对象，默认值为黑色
 NSStrokeWidthAttributeName         设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果
 NSStrokeColorAttributeName         填充部分颜色，不是字体颜色，取值为 UIColor 对象
 NSShadowAttributeName              设置阴影属性，取值为 NSShadow 对象
 NSTextEffectAttributeName          设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：
 NSBaselineOffsetAttributeName      设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏
 NSObliquenessAttributeName         设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾
 NSExpansionAttributeName           设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本
 NSWritingDirectionAttributeName    设置文字书写方向，从左向右书写或者从右向左书写
 NSVerticalGlyphFormAttributeName   设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本
 NSLinkAttributeName                设置链接属性，点击后调用浏览器打开指定URL地址
 NSAttachmentAttributeName          设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排
 NSParagraphStyleAttributeName      设置文本段落排版格式，取值为 NSParagraphStyle 对象
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的SQLite]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/25/ios-sqlite/"/>
    <updated>2015-12-25T10:44:52+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/25/ios-sqlite</id>
    <content type="html"><![CDATA[<p><img src="http://andyfightting.github.io/myimg/ios/sqlite.png" alt="image" /></p>

<p><a href="http://www.sqlite.org/">SQLite</a>是一个轻量级的关系型数据库，在iOS和Android手机中都有用到，C语言的面向过程的函数式编程。<a href="https://github.com/woooooojianjie/SQLitePersistentObject">SQLitePersistentObject</a>和<a href="https://github.com/ccgus/fmdb">FMDB</a>框架都是基于SQLite开发的。SQLitePersistentObject更像是个ORM框架，它是由Jeff LaMarche在2008年开发的，所以不是ARC的，要用的请加上<strong>-fno-objc-arc</strong>，且作者已经没有维护了，所以还是推荐使用更加广泛的FMDB。<!--more--></p>

<h3>*SQLite</h3>

<p>添加依赖库libsqlite3.tbd，用SQLite来个原生的增删改查。下面一次性完成了创建并打开数据库，创建表，插入一条数据，查询数据，最后关闭数据库。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString* docsdir = [NSSearchPathForDirectoriesInDomains( NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
</span><span class='line'>NSString* dbpath = [docsdir stringByAppendingPathComponent:@"user.sqlite"];
</span><span class='line'>sqlite3 *database;
</span><span class='line'>//创建并打开数据库*****************
</span><span class='line'>if (sqlite3_open([dbpath UTF8String], &database) != SQLITE_OK) { //SQLITE_OK == 0
</span><span class='line'>   sqlite3_close(database);
</span><span class='line'>   NSAssert(0,@"数据库打开失败"); //若状态不是0就打开失败
</span><span class='line'>}
</span><span class='line'>//创建表格*****************
</span><span class='line'>NSString *createSql = @"CREATE TABLE IF NOT EXISTS student (student_id INTEGER PRIMARY KEY ,student_name TEXT);";
</span><span class='line'>char *createError;
</span><span class='line'>//sqlite3_exec这个方法可以执行那些没有返回结果的操作，例如创建、插入、删除、修改等。这个函数包含了sqlite3_prepare这个函数的操作，目的是将UTF-8格式的SQL语句转换为编译后的语句
</span><span class='line'>if (sqlite3_exec(database, [createSql UTF8String], NULL, NULL, &createError) != SQLITE_OK) {
</span><span class='line'>    sqlite3_close(database);
</span><span class='line'>    NSAssert(0,@"创建表错误：%s", createError);
</span><span class='line'>}
</span><span class='line'>//插入或修改数据*****************  
</span><span class='line'>char *update = "INSERT OR REPLACE INTO student VALUES (?,?)";  
</span><span class='line'>sqlite3_stmt *statement;  
</span><span class='line'>if (sqlite3_prepare_v2(database, update, -1, &statement, nil) == SQLITE_OK) {  
</span><span class='line'>    //将值保存到指定的列,列从1开始！！  
</span><span class='line'>    sqlite3_bind_int(statement, 1, 4);//1是列，4是student_id  
</span><span class='line'>    //第四个参数代表第三个参数中需要传递的长度。对于C字符串来说，-1表示传递全部字符串。第五个参数是一个回调函数，比如执行后做内存清除工作。  
</span><span class='line'>    sqlite3_bind_text(statement, 2, [@"studentName" UTF8String], -1, NULL);  
</span><span class='line'>}    
</span><span class='line'>if (sqlite3_step(statement) != SQLITE_DONE) {  
</span><span class='line'>    NSAssert(0,@"更新数据出错");  
</span><span class='line'>}  
</span><span class='line'>sqlite3_finalize(statement);  
</span><span class='line'>//查询数据库***************** 
</span><span class='line'>NSString *querySql = @"SELECT * FROM student;";
</span><span class='line'>sqlite3_stmt *selectStmt;
</span><span class='line'>if (sqlite3_prepare_v2(database, [querySql UTF8String], -1, &selectStmt, nil) == SQLITE_OK) {
</span><span class='line'>    while (sqlite3_step(selectStmt) == SQLITE_ROW) {
</span><span class='line'>        int studentId = sqlite3_column_int(selectStmt, 0);//后面的数字对应每一列
</span><span class='line'>        char *cString = (char *)sqlite3_column_text(selectStmt, 1);
</span><span class='line'>        NSString* studentName = [[NSString alloc]initWithUTF8String:cString];
</span><span class='line'>        NSLog(@"student_id = %d   student_name = %@",studentId,studentName);
</span><span class='line'>    }
</span><span class='line'>    sqlite3_finalize(selectStmt);
</span><span class='line'>}
</span><span class='line'>sqlite3_close(database);//最后关闭数据库</span></code></pre></td></tr></table></div></figure>


<p><img src="http://andyfightting.github.io/myimg/ios/select.png" alt="image" />
<img src="http://andyfightting.github.io/myimg/ios/table.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的多线程]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/22/thread/"/>
    <updated>2015-12-22T14:28:22+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/22/thread</id>
    <content type="html"><![CDATA[<p>1.什么是进程</p>

<p>进程是指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。
<img src="http://andyfightting.github.io/myimg/ios/jincheng.png" alt="image" /><!--more--></p>

<p>2.什么是线程</p>

<p>进程要想执行任务必须通过线程来执行，1个进程至少会有1条线程(主线程)，进程的所有任务都在线程中执行。
<img src="http://andyfightting.github.io/myimg/ios/xiancheng.png" alt="image" /></p>

<p>线程中任务的执行是按顺序执行的，后面的任务要等前面的任务执行完了才能执行。但1个进程里可以开启多个线程来同时执行不同的任务，可以提高任务的执行效率。
<img src="http://andyfightting.github.io/myimg/ios/duox.png" alt="image" /></p>

<p>iOS中每个进程都会有一个主线程(UI线程)，<strong>只能在主线程中更新UI</strong>。如果在这个主线程里做了过多的耗时操作，就会造成UI卡顿，所以用多线程来处理耗时操作。常用的开启多线程方式有三种：NSThread, NSOperation, GCD。</p>

<h3>*NSThread</h3>

<p>NSThread是轻量级的多线程开发，用起来也不复杂。</p>

<p>初始化方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;
</span><span class='line'>- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;</span></code></pre></td></tr></table></div></figure>


<p>其他方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)start;//启动一个线程，并非立即执行，而是处于就绪状态，当系统调度时才真正执行
</span><span class='line'>- (void)cancel;//取消
</span><span class='line'>+ (BOOL)isMainThread;//当前线程是不是主线程
</span><span class='line'>+ (NSThread *)mainThread //获取主线程
</span><span class='line'>+ (NSThread *)currentThread;//返回当前线程
</span><span class='line'>+ (BOOL)isMultiThreaded;//是不是多线程
</span><span class='line'>+ (void)sleepUntilDate:(NSDate *)date;//休眠
</span><span class='line'>+ (void)sleepForTimeInterval:(NSTimeInterval)ti;//休眠
</span><span class='line'>+ (void)exit;//退出
</span><span class='line'>+ (double)threadPriority;//优先级
</span><span class='line'>+ (BOOL)setThreadPriority:(double)p;//设置优先级 0~1
</span><span class='line'>- (BOOL)isExecuting;//正在执行
</span><span class='line'>- (BOOL)isFinished;//执行完毕
</span><span class='line'>- (BOOL)isCancelled;//已经取消</span></code></pre></td></tr></table></div></figure>


<p>在子线程里要调用主线程来更新UI,可以用NSObject类别中的 OnMainThread 方法(前两个)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface NSObject (NSThreadPerformAdditions)
</span><span class='line'>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;
</span><span class='line'>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;
</span><span class='line'>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array ;
</span><span class='line'>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait ;
</span><span class='line'>- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg ;
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>按顺序启动（start）的线程不一定是按顺序执行，由系统调度资源决定的，同样的代码多运行几次顺序就不一样了。
<img src="http://andyfightting.github.io/myimg/ios/shunxv.png" alt="image" />
<img src="http://andyfightting.github.io/myimg/ios/shunxv2.png" alt="image" /></p>

<h3>*NSOperation</h3>

<p>NSOperation是个抽象类，使用的话要<strong>继承它然后实现main方法</strong>。但它有两个现成子类：NSInvocationOperation和NSBlockOperation，后者使用Block形式进行代码组织，使用相对方便。</p>

<p>NSOperation要和NSOperationQueue一起使用，只要将一个NSOperation子类对象
放到NSOperationQueue队列中，线程就会依次启动。NSOperationQueue负责管理、执行所有的NSOperation，可以更加容易的管理线程总数和控制线程之间的依赖关系。可以通过监听<strong>isFinished</strong>属性来得到线程执行完毕通知。</p>

<p>NSOperation类中的方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)start;
</span><span class='line'>- (void)cancel;
</span><span class='line'>- (void)main;//继承后要实现具体操作
</span><span class='line'>- (void)addDependency:(NSOperation *)op;//添加线程间的依赖关系，A依赖B，所以要B先执行完再执行A(切记不要循环依赖...)
</span><span class='line'>- (void)removeDependency:(NSOperation *)op;//移除依赖关系
</span><span class='line'>- (void)waitUntilFinished;</span></code></pre></td></tr></table></div></figure>


<p>几个属性</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property (readonly, getter=isCancelled) BOOL cancelled;
</span><span class='line'>@property (readonly, getter=isExecuting) BOOL executing;
</span><span class='line'>@property (readonly, getter=isFinished) BOOL finished;
</span><span class='line'>@property (readonly, getter=isConcurrent) BOOL concurrent;//已经弃用，用下面的'asynchronous'
</span><span class='line'>@property (readonly, getter=isAsynchronous) BOOL asynchronous;//是否异步执行
</span><span class='line'>@property (readonly, getter=isReady) BOOL ready;</span></code></pre></td></tr></table></div></figure>


<p>为什么说<strong>NSOperation要和NSOperationQueue一起使用</strong>呢？因为如果NSOperation子类对象直接start启动的话，它其实是在主线程中执行的！
<img src="http://andyfightting.github.io/myimg/ios/error.png" alt="image" />
如果把NSOperation子类对象加到NSOperationQueue中,这就不是在主线程中执行了。
<img src="http://andyfightting.github.io/myimg/ios/right.png" alt="image" /></p>

<p>NSInvocationOperation就两个初始化方法，两个属性&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;
</span><span class='line'>- (instancetype)initWithInvocation:(NSInvocation *)inv;
</span><span class='line'>@property (readonly, retain) NSInvocation *invocation;
</span><span class='line'>@property (nullable, readonly, retain) id result;</span></code></pre></td></tr></table></div></figure>


<p>NSBlockOperation就两个方法，一个属性&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (instancetype)blockOperationWithBlock:(void (^)(void))block;//初始化
</span><span class='line'>- (void)addExecutionBlock:(void (^)(void))block;//创建一个新的线程来执行任务
</span><span class='line'>@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;//任务数组</span></code></pre></td></tr></table></div></figure>


<p><strong>addExecutionBlock</strong>会创建一个新的线程来执行任务，而不是在同一个子线程中。
<img src="http://andyfightting.github.io/myimg/ios/blockThread.png" alt="image" /></p>

<p>NSOperationQueue中的方法及属性，都很少&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)cancelAllOperations;//取消线程
</span><span class='line'>- (void)waitUntilAllOperationsAreFinished;
</span><span class='line'>+ (nullable NSOperationQueue *)currentQueue;
</span><span class='line'>+ (NSOperationQueue *)mainQueue;//获取主线程
</span><span class='line'>- (void)addOperation:(NSOperation *)op;//添加线程
</span><span class='line'>- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait;//添加线程数组
</span><span class='line'>- (void)addOperationWithBlock:(void (^)(void))block;//添加线程block
</span><span class='line'>@property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;
</span><span class='line'>@property (readonly) NSUInteger operationCount;//池子里几个线程
</span><span class='line'>@property NSInteger maxConcurrentOperationCount;//最大并发线程数
</span><span class='line'>@property (getter=isSuspended) BOOL suspended;//延迟
</span><span class='line'>@property (nullable, copy) NSString *name;//线程名字
</span><span class='line'>@property NSQualityOfService qualityOfService;// ??
</span><span class='line'>@property (nullable, assign) dispatch_queue_t underlyingQueue;// ??</span></code></pre></td></tr></table></div></figure>


<h3>*GCD</h3>

<p>GCD(Grand Central Dispatch)是基于C语言开发的一套多线程开发机制，也是苹果官方推荐的多线程开发方法。抽象层次最高，当然是用起来也最简单，只是它基于C语言开发，并不像NSOperation是面向对象的开发，而是完全面向过程的，最显著的优点就是它对于多核运算更加有效。</p>

<p>GCD中的队列分为<strong>串行队列</strong>和<strong>并发队列</strong>两类，都是异步的：</p>

<p>串行队列：只有一个子线程，加入到队列中的操作按添加顺序依次执行。</p>

<p>并发队列：有多个子线程，操作进来之后它会将这些队列安排在可用的处理器上，同时保证先进来的任务优先处理。</p>

<p><strong>1. 串行队列, 在同一个子线程里, 顺序执行！</strong> 关键字 <em>DISPATCH_QUEUE_SERIAL</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t serialQueue = dispatch_queue_create("myThreadQueue", DISPATCH_QUEUE_SERIAL);
</span><span class='line'>    for (int i=0; i&lt;5; ++i) {
</span><span class='line'>        dispatch_async(serialQueue, ^{
</span><span class='line'>            [self doSomething:i];
</span><span class='line'>        });
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p><img src="http://andyfightting.github.io/myimg/ios/gcd1.png" alt="image" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//更新UI界面,此处调用了GCD主线程队列的方法
</span><span class='line'>dispatch_queue_t mainQueue = dispatch_get_main_queue();
</span><span class='line'>  dispatch_sync(mainQueue, ^{
</span><span class='line'>    [self updateUI];
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p><strong>2. 并发队列, 在不同的子线程里, 并发执行</strong> 关键字 <em>DISPATCH_QUEUE_CONCURRENT</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> //方式一：dispatch_queue_t serialQueue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span><span class='line'> dispatch_queue_t serialQueue=dispatch_queue_create("myThreadQueue", DISPATCH_QUEUE_CONCURRENT);
</span><span class='line'>    for (int i=0; i&lt;5; ++i) {
</span><span class='line'>        dispatch_async(serialQueue, ^{
</span><span class='line'>            [self doSomething:i];
</span><span class='line'>        });
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p><img src="http://andyfightting.github.io/myimg/ios/ybbf.png" alt="image" />
若把上面的<strong>dispatch_async</strong>改成<strong>dispatch_sync</strong>,这就是在主线程中顺序执行了！即使在异步并发队列中！
<img src="http://andyfightting.github.io/myimg/ios/hah.png" alt="image" />
所以，GCD若要<strong>异步多线程</strong>执行必须：使用异步队列<strong>DISPATCH_QUEUE_CONCURRENT</strong> 并且 方法是异步方法(dispatch_async)!! 否则，要么在<strong>子线程</strong>里顺序执行(串行队列，异步方法(dispatch_async))，要么在<strong>主线程</strong>里顺序执行！！(同步方法(dispatch_sync)，不管串行还是并发队列)</p>

<p>解决异步情况下抢占资源问题，可以加锁<strong>NSLock</strong>。获取资源时lock住，获取完资源后unlock。或者用<strong>@synchronized</strong>包裹获取资源代码。</p>

<p>几个线程执行完后得到通知</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_t group = dispatch_group_create();
</span><span class='line'>dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^{
</span><span class='line'>    //并发执行的任务一
</span><span class='line'>});
</span><span class='line'>dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^{
</span><span class='line'>    //并发执行的任务二
</span><span class='line'>});
</span><span class='line'>dispatch_group_notify(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^{
</span><span class='line'>    //所有任务都执行完了得到通知
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSOperationQueue *queue = [[NSOperationQueue alloc]init];
</span><span class='line'>NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>     //并发执行的任务一
</span><span class='line'> }];
</span><span class='line'> [blockOperation addExecutionBlock:^{
</span><span class='line'>     //并发执行的任务二
</span><span class='line'> }];
</span><span class='line'> [blockOperation setCompletionBlock:^{
</span><span class='line'>     //所有任务都执行完了
</span><span class='line'> }];
</span><span class='line'> [queue addOperation:blockOperation];</span></code></pre></td></tr></table></div></figure>


<h3>*总结</h3>

<p>1.无论使用哪种方法进行多线程开发，每个线程启动后并不一定立即执行相应的操作，具体什么时候由系统调度，CPU空闲时就会执行。</p>

<p>2.更新UI应该在主线程（UI线程）中进行，常用的方法如下：</p>

<p>-(void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait</p>

<p>-(void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL) wait;//传递[NSThread mainThread]</p>

<p>[[NSOperationQueue mainQueue] addOperationWithBlock:^{ }];</p>

<p>dispatch_sync(dispatch_get_main_queue(), ^{ });</p>

<p>3.NSThread适合轻量级多线程开发，要手动控制线程，线程总数无法控制，无法线程依赖。</p>

<p>4.对于简单的多线程开发建议使用NSObject的扩展方法完成，而不必使用NSThread。</p>

<p>5.可以使用NSThread的currentThread方法取得当前线程，使用 sleepForTimeInterval:方法让当前线程休眠。</p>

<p>6.NSOperation进行多线程开发可以控制线程总数及线程依赖关系。</p>

<p>7.创建一个NSOperation不应该直接调用start方法, 如果直接start则会在主线程中调用, 而是应该放到NSOperationQueue中启动。</p>

<p>8.相比NSInvocationOperation推荐使用NSBlockOperation，代码简单，同时由于闭包性使它没有传参问题。</p>

<p>9.NSOperation是对GCD面向对象的封装，但是GCD基于C语言开发，效率却更高. 建议如果任务之间有依赖关系或者想要监听任务完成状态的情况下优先选择NSOperation否则使用GCD。</p>

<p>10.在GCD中串行队列中的任务被安排到一个单一的子线程中，可以方便地控制执行顺序；并发队列在多个线程中执行（前提是使用异步方法），顺序控制相对复杂，但是更高效。</p>

<p>11.在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并发队列并且使用异步方法执行时才能在多个线程中并发执行。</p>

<p>12.相比使用NSLock，@synchronized更加简单。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/19/desigin-pattern/"/>
    <updated>2015-12-19T21:51:06+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/19/desigin-pattern</id>
    <content type="html"><![CDATA[<p>我理解的设计模式都是为了让代码模块化，结构化，各司其职，再把各个模块通过"接口"组合起来。封装变化；多用组合少用继承；针对接口编程，不针对实现编程；为交互对象之间的松耦合设计而努力；对扩展开放，对修改关闭。</p>

<h3>1.MVC模式</h3>

<p>看图就可以了，简洁明了~
<img src="http://andyfightting.github.io/myimg/other/mvc.png" alt="image" /><!--more--></p>

<h3>2.策略模式</h3>

<p>比如有个父类有飞行功能，然后有很多子类的飞行功能各不一样，如果去继承父类然后分别实现不同的飞行行为，这就坑爹了&hellip;具体做法应该是：把飞行行为完全独立出来成一个Interface，然后不同的飞行行为再在单独的类中实现，不同的子类要不同的飞行行为的话就取对应的行为实现对象。</p>

<p>父类：</p>

<pre><code>public class Duck {//父类

public FlyInterface flyInterface;//行为的接口成员变量

public void performFly(){//统一调用的飞行方法
    flyInterface.fly();
}

public void setFlyInterface(FlyInterface fi){//动态改变飞行行为
    flyInterface = fi;
  }
}
</code></pre>

<p>行为接口：</p>

<pre><code>public interface FlyInterface { //行为接口
void fly();//要实现的行为方法
}
</code></pre>

<p>行为的一种具体实现：</p>

<pre><code>public class FlyPatternOne implements FlyInterface {//飞行行为的一种实现，可以有很多个不同的实现
@Override
public void fly() {
    //这里是具体飞行行为代码

  }
}
</code></pre>

<p>某一个子类：</p>

<pre><code>public class SubDuck extends Duck{
public SubDuck(){
    //默认的飞行行为，不同的子类有不同的飞行行为，如 FlyPatternTwo FlyPatternThree...等
    flyInterface = new FlyPatternOne();
  }
}
</code></pre>

<p><img src="http://andyfightting.github.io/myimg/other/chelue.png" alt="image" /></p>

<p>1,找出可能需要变化之处，把它们独立封装起来，不要和那些不需要变化的代码混合在一起。</p>

<p>2.针对接口编程，而不是针对实现编程。</p>

<p>3.多用组合，少用继承。</p>

<h3>3.观察者模式</h3>

<p>好好看图吧，把它转化为具体代码加深理解
<img src="http://andyfightting.github.io/myimg/other/guanCha0.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha1.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha2.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha3.jpg" alt="image" /></p>

<p>看完上面例子，下面的设计图也更好理解了。
<img src="http://andyfightting.github.io/myimg/other/guanCha4.jpg" alt="image" /></p>

<p>使用Java内置的观察者模式
<img src="http://andyfightting.github.io/myimg/other/guanCha5.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha6.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha7.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha8.jpg" alt="image" /></p>

<p>Swing中的观察者模式
<img src="http://andyfightting.github.io/myimg/other/guanCha9.jpg" alt="image" /></p>

<p>要点
<img src="http://andyfightting.github.io/myimg/other/guanCha10.jpg" alt="image" /></p>

<h3>4.装饰模式</h3>

<p>动态的将责任附加到对象上，用对象组合的方式来解决继承滥用的问题。利用继承设计子类的行为是在编译时静态决定的，而且所有的子类都会继承到相同的行为。如果利用组合的做法扩展对象的行为，就可以在运行时动态的进行扩展。类应该多扩展开放，对修改关闭。即在不修改现有代码的情况下可以添加新的行为。</p>

<p>装饰着和被装饰着必须是同一类型，所以通过继承来实现。这里的继承是用来达到“类型一致”的，而不是为了通过继承得到“行为”。“行为”来自装饰着和基础组件，其他与装饰着之间的组合关系。
<img src="http://andyfightting.github.io/myimg/other/zhuangShi.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi0.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi1.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi2.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi3.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi4.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi5.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi6.jpg" alt="image" /></p>

<h3>5.工厂模式</h3>

<p>当每次“new”的时候都会实例化一个类，所以这是用的实现编程而不是接口编程。“工厂”就是一个专门负责产生对象的一个类。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android基本存储]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/23/androidsave/"/>
    <updated>2015-11-23T19:48:52+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/23/androidsave</id>
    <content type="html"><![CDATA[<p>Android数据保存方式有： 文件存储, SharedPreference, Sqlite, SD卡存储。</p>

<h3>* 文件存储</h3>

<p>不对存储数据做任何格式化处理，原封不动的保存到文件中。使用于保存简单的文本数据或者二进制数据。</p>

<p>Context有个<code>openFileOutput()</code>方法接受两个参数，第一个：文件名，<strong>不要包含路径</strong>，第二个：操作方式，有两种，<code>MODE_PRIVATE</code>(覆盖原文件内容),<code>MODE_APPEND</code>(在原文件尾部追加内容)，默认第一种。文件默认保存在：<code>/data/data/packageName/files/</code>这个目录里。</p>

<pre><code> public static void saveText(Context context,String fileName,String text){
    FileOutputStream outputStream ;
    BufferedWriter bufferedWriter = null;
    try {
       outputStream = context.openFileOutput(fileName,Context.MODE_PRIVATE);
        bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write(text);
    }catch (IOException e){
        e.printStackTrace();
    }finally {
        try {
            if (bufferedWriter != null){
                bufferedWriter.close();
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre>

<!--more-->


<p>在我调用 <code>MyTool.saveText(this,"myFile","Hello World!");</code>后出现了如下文件，点画圈圈的地方可以导出到电脑上打开查看。
<img src="http://andyfightting.github.io/myimg/android/helloSave.png" alt="img" /></p>

<p>读文件</p>

<pre><code>public static String getText(Context context,String fileName){
    FileInputStream inputStream;
    BufferedReader bufferReader = null;
    StringBuilder contentBuilder = new StringBuilder();
    try {
        inputStream = context.openFileInput(fileName);
        bufferReader = new BufferedReader(new InputStreamReader(inputStream));
        String lineText = "";
        while ((lineText = bufferReader.readLine()) != null){
            contentBuilder.append(lineText);
        }
    }catch (IOException e){
        e.printStackTrace();
    }finally {
       if (bufferReader != null){
           try {
               bufferReader.close();
           }catch (IOException e){
               e.printStackTrace();
           }
       }
    }
    return contentBuilder.toString();
}
</code></pre>

<p>删除文件</p>

<pre><code>public static void deleteFile(Context context, String fileName) {
    String filePath = context.getFilesDir()+"/"+fileName;
    File file = new File(filePath);
    if (file.exists()){
        file.delete();
    }
}
</code></pre>

<h3>* SharedPreference</h3>

<p>用key-value键值对的方式保存数据，适用于保存应用配置之类的简单信息。有以下三种方式得到<code>SharedPreferences</code>对象，得到实例后调用实例的<code>edit()</code>方法得到<code>SharedPreferences.Editor</code>对象，用该<code>Editor</code>对象<code>putBoolean("key",value)``putString("key",value)</code>等方法添加数据，然后调用<code>apply()</code>即可。获取数据就调用对应的<code>getBoolean("key")``getString("key")</code>。文件保存在<code>/data/data/packageName/shared_prefs/</code>目录下。</p>

<ol>
<li><p>Context中的<code>getSharedPreferences()</code>方法接收两个参数，一个文件名(不要包含路径)，一个操作模式，有<code>MODE_PRIVATE</code>(覆盖原文件),<code>MODE_MULTI_PROCESS</code>(多个进程对文件进行读写情况)默认第一种。</p></li>
<li><p>Activity中也有个一个类似的方法<code>getSharedPreferences()</code>，它只接收一个操作模式作为参数，<strong>自动将类名作为文件名</strong>。</p></li>
<li><p>PreferenceManager类中的<code>getDefaultSharedPreferences()</code>，这是一个静态方法，接收一个参数<code>Context</code>,自动将应用程序的<code>packageName</code>为前缀的文件名,如我的包名是<code>com.suguiming.myandroid</code>,生成的文件名就是<code>com.suguiming.myandroid_preferences.xml</code>。</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SharedPreferences sharedPreferences =    PreferenceManager.getDefaultSharedPreferences(context);
</span><span class='line'>  SharedPreferences.Editor editor = sharedPreferences.edit();
</span><span class='line'>    editor.putString("name","guimingsu");
</span><span class='line'>    editor.putInt("age", 18);
</span><span class='line'>    editor.apply();</span></code></pre></td></tr></table></div></figure>


<p><img src="http://andyfightting.github.io/myimg/android/shareP.png" alt="img" />
<img src="http://andyfightting.github.io/myimg/android/shareV.png" alt="img" /></p>

<p>一般都把它做成一个工具类</p>

<pre><code>public class SharedPreUtil {

public static final String FILE_NAME = "shared_preference";

public static void put(Context context, String key, Object value) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPreferences.edit();

    if (value instanceof String) {
        editor.putString(key, (String) value);
    } else if (value instanceof Integer) {
        editor.putInt(key, (Integer) value);
    } else if (value instanceof Boolean) {
        editor.putBoolean(key, (Boolean) value);
    } else if (value instanceof Float) {
        editor.putFloat(key, (Float) value);
    } else if (value instanceof Long) {
        editor.putLong(key, (Long) value);
    } else {
        editor.putString(key, value.toString());
    }
    editor.apply();
}

public static Object get(Context context, String key, Object defaultValue) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);

    if (defaultValue instanceof String) {
        return sharedPreferences.getString(key, (String) defaultValue);
    } else if (defaultValue instanceof Integer) {
        return sharedPreferences.getInt(key, (Integer) defaultValue);
    } else if (defaultValue instanceof Boolean) {
        return sharedPreferences.getBoolean(key, (Boolean) defaultValue);
    } else if (defaultValue instanceof Float) {
        return sharedPreferences.getFloat(key, (Float) defaultValue);
    } else if (defaultValue instanceof Long) {
        return sharedPreferences.getLong(key, (Long) defaultValue);
    }
    return null;
}

public static void remove(Context context, String key) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPreferences.edit();
    editor.remove(key);
    editor.apply();
}

public static void removeAll(Context context) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPreferences.edit();
    editor.clear();
    editor.apply();
}

}
</code></pre>

<h3>* SQLite</h3>

<p>关系型的轻量级数据库，保存复杂或者大数据用这个，支持标准的SQL语法。</p>

<p>创建数据库：Android提供了一个抽象类<code>SQLiteOpenHelper</code>，我们继承它重写里面的两个方法<code>onCreate()</code>,<code>onUpdate()</code>来创建和更新数据库表结构。创建的数据库会保存在 <code>/data/data/packageName/databases/</code>目录下。通过<code>getReadableDatabase</code>或者<code>getWritableDatabase</code>都可得到可读写的数据库，但如果数据库不可写时(如磁盘已满)，<code>getWritableDatabase</code>会报错，<code>getReadableDatabase</code>不会。</p>

<p>调用<code>MySqliteHelper.getHelper(mainActivity).getReadableDatabase();</code>一下数据库就建好了，下次再调用就不会再创建了。</p>

<pre><code>public class MyDatabaseHelper extends SQLiteOpenHelper {

private static MyDatabaseHelper helper;
private static final String DB_NAME = "myAndroid.db";

public MyDatabaseHelper(Context context){
    super(context, DB_NAME, null, 2);//2 数据库version,修改数据库用
}

@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL(create_dog);
    db.execSQL(create_cat);
}

@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    //更新表才用,这里假设在 版本2 中要添加 cat 表,注意：switch 不要 break !!
    switch (newVersion){
        case 2:
            db.execSQL(create_cat);
        default:
    }
}
//获取 helper 单例
public static synchronized MyDatabaseHelper getHelper(Context context) {
    context = context.getApplicationContext();
    if (helper == null) {
        synchronized (MyDatabaseHelper.class) {
            if (helper == null)
                helper = new MyDatabaseHelper(context);
        }
    }
    return helper;
}

//-------------sql----------------------------
    public static final String create_dog = "create table dog ("
            +"id integer primary key autoincrement,"
            +"name text,"
            +"age integer,"
            +"weight real)";

    public static final String create_cat = "create table cat ("
            +"id integer primary key autoincrement,"
            +"name text,"
            +"age integer,"
            +"weight real)";
}
</code></pre>

<p><img src="http://andyfightting.github.io/myimg/android/mydb.png" alt="img" />  <br/>
把数据库导出到桌面，用<a href="http://www.sqlitemanager.org/">SQLiteManager</a>打开查看
<img src="http://andyfightting.github.io/myimg/android/mytable.png" alt="img" /></p>

<p>数据增，删，改，查的最简单的例子</p>

<pre><code>public class DogDao {
private static final String TABLE_NAME = "dog";

public static void add(Context context,Dog dog){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("name",dog.getName());
    values.put("age",dog.getAge());
    values.put("weight",dog.getWeight());
    db.insert(TABLE_NAME, null, values);
}

public static void update(Context context,Dog dog){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("name",dog.getName());
    values.put("age",dog.getAge());
    values.put("weight",dog.getWeight());
    db.update(TABLE_NAME, values, null, null);
}

public static void deleteAll(Context context){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    db.delete(TABLE_NAME, null, null);
}

public static List&lt;Dog&gt; getAll(Context context){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    Cursor cursor = db.query(TABLE_NAME, null, null, null, null, null, null);
    List&lt;Dog&gt; dogList = new ArrayList&lt;&gt;();
    if (cursor.moveToFirst()){
        do {
            Dog dog = new Dog();
            dog.setName(cursor.getString(cursor.getColumnIndex("name")));
            dog.setAge(cursor.getInt(cursor.getColumnIndex("age")));
            dog.setWeight(cursor.getFloat(cursor.getColumnIndex("weight")));
            dogList.add(dog);
        }while (cursor.moveToNext());
    }
    cursor.close();
    return dogList;
}

//事务，要么都成功，要么都失败。
public static void transactionTest(Context context){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    db.beginTransaction();
    try {
        //数据处理....

        db.setTransactionSuccessful();
    }catch (Exception e){
        e.printStackTrace();
    }finally {
        db.endTransaction();
    }
}
}
</code></pre>

<p>也可以用 Android SDK <code>/platform-tools</code>文件夹中自带的<code>adb</code>工具来操作链接在电脑的手机或者模拟器里的数据库。</p>

<p>但要先配置一下，Mac的配置如下，在终端依次输入 <code>cd ~</code> <code>touch .bash_profile</code> <code>open -e .bash_profile</code>这时会打开一个文本文件，在里面添加<code>export PATH=${PATH}:这里是platform-tools文件的路径</code>保存关闭，
然后<code>source .bash-profile</code>刷新，然后输入<code>adb shell</code>就可以开始用了。
<img src="http://andyfightting.github.io/myimg/android/pzadb.png" alt="img" />
<img src="http://andyfightting.github.io/myimg/android/pzadb2.png" alt="img" />
如查看数据库<code>cd /data/data/packageName/databases</code> <code>l</code>列出所有数据库
<img src="http://andyfightting.github.io/myimg/android/adbtable.png" alt="img" /></p>

<h3>* SD卡存储</h3>

<p>SD卡存储和文件存储差不多，只不过是手机外部的存储空间，容量更大，不过在使用的时候要判断SD卡可不可以用。</p>

<pre><code>public class SDCardUtil {

// 默认都保存在这个文件夹下
private static final String DEFAULT_DIR = "ProData/";

public static boolean isEnable() {
    return Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED);
}

public static long getTotalMB() {
    if (!isEnable())
        return 0;
    File path = Environment.getExternalStorageDirectory();
    StatFs stat = new StatFs(path.getPath());
    long blockSize = stat.getBlockSizeLong();
    long availableBlocks = stat.getBlockCountLong();
    return (availableBlocks * blockSize) / 1024 / 1024;
}

public static long getAvailableMB() {
    if (!isEnable())
        return 0;
    File path = Environment.getExternalStorageDirectory();
    StatFs stat = new StatFs(path.getPath());
    long blockSize = stat.getBlockSizeLong();
    long availableBlocks = stat.getAvailableBlocksLong();
    return (availableBlocks * blockSize) / 1024 / 1024;
}

public static long getAvailableByte() {
    if (!isEnable())
        return 0;
    File path = Environment.getExternalStorageDirectory();
    StatFs stat = new StatFs(path.getPath());
    long blockSize = stat.getBlockSizeLong();
    long availableBlocks = stat.getAvailableBlocksLong();
    return availableBlocks * blockSize;
}

// 路径：/storage/sdcard0/
public static String getSDCardPath() {
    if (!isEnable())
        return "";
    return Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator;
}


public static File createDir(String directoryName) {
    //建默认文件夹
    String defaultDir = getSDCardPath() + DEFAULT_DIR;
    File defaultFile = new File(defaultDir);
    if (!defaultFile.exists()) {
        defaultFile.mkdir();
    }

    String dirPath = getFilePath(directoryName);
    File dirFile = new File(dirPath);
    if (!dirFile.exists()) {
        dirFile.mkdir();
    }
    return dirFile;
}

public static File createFile(String fileName) {
    try {
        //建默认文件夹
        String dirPath = getSDCardPath() + DEFAULT_DIR;
        File directory = new File(dirPath);
        if (!directory.exists()) {
            directory.mkdir();
        }

        //再在默认文件夹里建文件
        File file = new File(getFilePath(fileName));
        if (!file.exists()) {
            file.createNewFile();
        }
        return file;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}

public static String getFilePath(String fileName) {
    return getSDCardPath() + DEFAULT_DIR + fileName;
}

public static boolean isFileExist(String fileName) {
    File file = new File(getFilePath(fileName));
    return file.exists();
}

public static boolean saveByte(String fileName, byte[] bytes) {
    if (bytes == null) {
        return false;
    }

    OutputStream output = null;
    try {
        if (bytes.length &lt; getAvailableByte()) {
            File file = createFile(fileName);//这里面已经建了默认文件夹
            output = new BufferedOutputStream(new FileOutputStream(file));
            output.write(bytes);
            output.flush();
            return true;
        }
    } catch (IOException e1) {
        e1.printStackTrace();
    } finally {
        try {
            if (output != null) {
                output.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return false;
}

public static byte[] getByte(String fileName) {
    File file = new File(getFilePath(fileName));
    if (!file.exists()) {
        return null;
    }
    InputStream inputStream = null;
    try {
        inputStream = new BufferedInputStream(new FileInputStream(file));
        byte[] data = new byte[inputStream.available()];
        inputStream.read(data);
        return data;
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (inputStream != null) {
                inputStream.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return null;
}

public static boolean saveBitmap(Bitmap bitmap, String bitmapName) {
    if (bitmap == null) {
        return false;
    }
    //建默认文件夹
    String dirPath = getSDCardPath() + DEFAULT_DIR;
    File directory = new File(dirPath);
    if (!directory.exists()) {
        directory.mkdir();
    }

    File file = new File(getFilePath(bitmapName));
    BufferedOutputStream output = null;
    try {
        output = new BufferedOutputStream(new FileOutputStream(file));
        bitmap.compress(Bitmap.CompressFormat.JPEG, 80, output);
        output.flush();
        output.close();
        return true;
    } catch (IOException e1) {
        e1.printStackTrace();
    } finally {
        try {
            if (output != null) {
                output.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return false;
}

public static Bitmap getBitmap(String bitmapName) {
    String myJpgPath = getFilePath(bitmapName);
    BitmapFactory.Options options = new BitmapFactory.Options();
    return BitmapFactory.decodeFile(myJpgPath, options);
}

public static void removeFile(String fileName) {
    String filePath = getFilePath(fileName);
    File file = new File(filePath);
    if (file.exists()) {
        file.delete();
    }
}

public static void removeFile(File file) {
    if (file.isFile()) {
        file.delete();
        return;
    }
    if (file.isDirectory()) {
        File[] childFiles = file.listFiles();
        if (childFiles == null || childFiles.length == 0) {
            file.delete();
            return;
        }

        for (int i = 0; i &lt; childFiles.length; i++) {
            removeFile(childFiles[i]);
        }
        file.delete();
    }
}

public static void removeAll() {
    String filePath = getSDCardPath() + DEFAULT_DIR;
    File file = new File(filePath);
    if (file.exists()) {
        removeFile(file);
    }

    //再建一个空文件夹
    File directory = new File(filePath);
    if (!directory.exists()) {
        directory.mkdir();
    }
  }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio插件]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/22/studioplugin/"/>
    <updated>2015-11-22T14:10:45+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/22/studioplugin</id>
    <content type="html"><![CDATA[<h3>* Logger</h3>

<p>推荐一款打印工具<a href="https://github.com/orhanobut/logger">Logger</a>,比自带的打印效果更好，主要是json打印是格式化的！Github上写的地址<code>compile 'com.github.orhanobut:logger:1.12'</code>我下载失败，我用的是<code>compile 'com.orhanobut:logger:1.11'</code>。
<img src="http://andyfightting.github.io/myimg/android/logger.png" alt="img" />
打印颜色可以在preference里设置，要先<code>Save as</code>保存一下，然后把右边的<code>Use inherited attributes</code>取消，然后就可以选择颜色了<!--more-->
<img src="http://andyfightting.github.io/myimg/android/logColor.png" alt="img" /></p>

<h3>* Sexy Editor</h3>

<p>设置编辑区域背景图的, 这样敲代码也更有力气拉~~哈哈</p>

<p><img src="http://andyfightting.github.io/myimg/android/screen.png" alt="img" /></p>

<p>怎么添加插件？有如下三种方式<code>install JetBrains plugin</code>,<code>Browse repositories</code>,<code>install plugin from disk</code>。<code>Sexy Editor</code>是用第二种方式添加。</p>

<p><img src="http://andyfightting.github.io/myimg/android/add_plugin.png" alt="img" /></p>

<p>我的<code>sexy editor</code>设置</p>

<p><img src="http://andyfightting.github.io/myimg/android/sexy_editor.png" alt="img" /></p>

<h3>* Mac下的快捷键</h3>

<p>Mac中的标识：<code>⌘:command</code>, <code>⌃:control</code>, <code>⇧:shift</code>, <code>⌥:alt/option</code></p>

<p><code>⌘ + ⌥ + L</code>: 代码对齐格式化</p>

<p><code>^ + ⌥ + O</code>: 除去无效的import引用</p>

<p><code>F1</code>: 查看文档</p>

<p><code>F2</code>: 定位到未被使用的成员</p>

<p><code>F3</code>: 添加书签</p>

<p><code>F4</code>: 定位到声明处</p>

<p><code>⇧ + F6</code>: 文件重命名</p>

<p><code>⌘ + F12</code>: 显示内部成员</p>

<p><code>⌘ + ⇧ + F7</code>: 代码高亮</p>

<p><code>⌥ + ⏎</code>: 添加缺少的import</p>

<p><code>⌘ + delete</code>: 删除整行</p>

<p><code>⌘ + N</code>: 生成代码，getter setter 等</p>

<p><code>⌃ + H</code>: 查看类的层级关系</p>

<p><code>⌘ + U</code>: 查看父类的同名方法</p>

<p><code>⌘ + J</code>: 快捷插入常用代码片段</p>

<p><code>⌥ + ⇧ + ↑或↓</code>: 上下移动光标所在的行</p>

<p><code>⌘ + ⇧ + ↑或↓</code>: 上下移动整个方法块</p>

<p><code>⌘ + ⌥ + ⏎</code>: 当前行上面插入一行</p>

<p><code>⌘ + ⇧ + U</code>: 大小写转化</p>

<p><code>⌘ + E</code>: 查看打开过的文件</p>

<p><code>⌃ + T</code>: 重构面板</p>

<p><code>⌃ + O</code>: 选择要重写或者要实现的方法</p>

<p><code>⌘ + O</code>: 快速搜索class</p>

<p><code>⌘ + ⇧ + O</code>: 快速搜索file</p>

<p><code>⌘ + ⇧ + F</code>: 全局搜索</p>

<p><code>⌘ + ⇧ + R</code>: 全局替换</p>

<p><code>⌘ + +或-</code>: 展开或者收起代码块</p>

<p><code>⌘ + /</code>: 注释 //</p>

<p><code>⌘ + ⌥ + /</code>: 注释 /**/</p>

<p><code>⌥ + ⏎</code>: 提示错误解决方法</p>

<p>可能会有人觉得为啥重命名<code>⇧ + F6</code>没反应呢？跟 F1 ~ F12 有关的都没反应&hellip;</p>

<p>因为Mac系统默认没有启用它们&hellip;在系统设置，键盘选项里选中就可以了。</p>

<p><img src="http://andyfightting.github.io/myimg/android/keyf.png" alt="img" /></p>

<p>当然可以设置自己喜欢的快捷键，我自己把运行和调试改成了<code>⌘ + R</code>和<code>⌘ + D</code></p>

<p><img src="http://andyfightting.github.io/myimg/android/keymap.png" alt="img" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 基础知识]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/21/androidBase0/"/>
    <updated>2015-11-21T09:26:15+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/21/androidBase0</id>
    <content type="html"><![CDATA[<h3>* Activity启动模式</h3>

<p>在AndroidMainfest.xml里的activity里设置android:launchMode = “xxx”</p>

<p><strong>standard:</strong> 默认模式，每次都会创建一个新的放在栈顶，即使栈里已经有了</p>

<p><strong>singleTop:</strong> 已经在<strong>栈顶</strong>了就不创建，否则还是会创建，即使栈里已经有了</p>

<p><strong>singleTask:</strong> 在活动栈中有了就不创建，直接推到栈顶，<strong>在它之前的全部会被挤出栈</strong>，若活动栈中没有就创建</p>

<p><strong>singleInstance:</strong> 会创建一个<strong>新的活动栈</strong>把自己放进去</p>

<h3>* 随时随地退出程序</h3>

<p>在任何页面都可以被踢下线的实现技巧</p>

<p>创建一个收集Activity的管理类，在BaseActivity的<code>onCreate()</code>方法中添加<code>ActivityManager.addActivity(this)</code>,在<code>onDestroy</code>方法中添加<code>ActivityManager.removeActivity(this)</code>。然后在任何要强退的地方调用<code>ActivityManager.finishAllActivity()</code>。<!--more--></p>

<pre><code>public class ActivityManager {

public static List&lt;Activity&gt; activityList = new ArrayList&lt;&gt;();

public static void addActivity(Activity activity){
    activityList.add(activity);
  }

public static void removeActivity(Activity activity){
    activityList.remove(activity);
  }

public static void finishAllActivity(){
    for (Activity activity : activityList){
        if (!activity.isFinishing()){
            activity.finish();
        }
    }
    activityList.clear();
  }
}
</code></pre>

<h3>* Activity跳转</h3>

<p>一般我们是用如下的方式跳转，需要知道下一个Activity要用哪些参数，多人开发可能有些不便。</p>

<pre><code>Intent intent = new Intent(OneActivity.thi,TwoActivity.class);
intent.putExtra("key","value");
startActivity(intent);
</code></pre>

<p>可以在下一个Activity中把需要的参数暴露出来。</p>

<pre><code>public static void actionStart(Activity activity,String param){
  Intent intent = new Intent(activity,TwoActivity.class);
  intent.putExtra("key","param");
  activity.startActivity(intent);
  activity.finish();
}
</code></pre>

<h3>* ListView的正确使用方式</h3>

<p>实现了item的复用，这样效率最好，ArrayAdapter源码中就是这样弄的。ArrayAdapter把BaseAdapter包装了一遍，实现了<code>getCount</code>,<code>getItem</code>,<code>getItemId</code>，所以这些我们就可以不用再写了，只重写个<code>getView</code>就可以。</p>

<pre><code>public class UserAdapter extends ArrayAdapter&lt;User&gt; {

private int layoutId;
public UserAdapter(Context context, int resourceId, List&lt;User&gt; objects){
      super(context,resourceId,objects);
      layoutId = resourceId;
}

@Override
public View getView(int position, View convertView, ViewGroup parent){

    User user = getItem(position);
    ViewHolder viewHolder;
    View layoutView;

    if (convertView == null){
        layoutView = LayoutInflater.from(getContext()).inflate(layoutId,null);
        viewHolder = new ViewHolder();
        viewHolder.headImage = (ImageView)layoutView.findViewById(R.id.head_img);
        viewHolder.nameTv = (TextView)layoutView.findViewById(R.id.name_tv);
        layoutView.setTag(viewHolder);
    }else {
       layoutView = convertView;
       viewHolder = (ViewHolder)layoutView.getTag();
    }
    //--------在下面赋值 ----------------
    viewHolder.headImage.setImageResource(user.getHeadImgId());
    viewHolder.nameTv.setText(user.getName());

    return layoutView;
}

class ViewHolder{
    ImageView headImage;
    TextView nameTv;
  }
}
</code></pre>

<h3>* px,dpi,dp,density</h3>

<p>Android规定：如果手机一英寸长度上有160个px，那么手机的dpi就是160,此时1dp==1px，即density=1。所以如果一英寸长度上有320个px的话，那么手机的dpi就是320，此时1dp==2px,即density=2。</p>

<p>结论：即相同大小的手机上的dp个数是不变的，如果相同大小的手机像素不同的话，只会影响dip和density的值,所以我们适配手机的时候用的长度单位要用 &mdash;- <code>dp</code></p>

<pre><code>public static int getScreenWidthPx(Context context){
    return  context.getResources().getDisplayMetrics().widthPixels;
}

public static int getScreenHeightPx(Context context){
    return  context.getResources().getDisplayMetrics().heightPixels;
}

public static float getXdpi(Context context){
    return  context.getResources().getDisplayMetrics().xdpi;
}

public static float getYdpi(Context context){
    return  context.getResources().getDisplayMetrics().ydpi;
}

public static float getDensity(Context context){
   return context.getResources().getDisplayMetrics().density;
}
</code></pre>

<h3>* 9-patch图片</h3>

<p>1，在<code>上</code>边绘制的<code>垂直区域</code>会被<code>水平拉伸</code>，在<code>左</code>边绘制的<code>横向区域</code>会被<code>垂直拉伸</code>。</p>

<p>2，在<code>下</code>边和<code>右</code>边绘制的<code>交叉区域</code>是内容放置的区域。</p>

<p><img src="http://andyfightting.github.io/myimg/android/9patch.jpg" alt="img" /></p>

<h3>* Fragment</h3>

<p>在fragment里可以用<code>getActivity()</code>得到与之关联的Activity。<code>FragmentTransaction</code>的实例可以调用<code>addToBackStack(null)</code>方法把这个事务添加到返回栈中，这样点击返回就是回到事务处理之前的状态,而不是退出Activity。fragment之间的通信可以通过与之共同关联的Activity来转达。</p>

<p>fragment的生命周期与Activity类似，只不过比Activity多了<code>onAttach()</code>,<code>onCreateView()</code>,<code>onActivityCreated()</code>,<code>onDestroyView()</code>,<code>onDetach()</code>。</p>

<p>由生到死依次是：<code>onAttach()</code>, <code>onCreate()</code>,<code>onCreateView()</code>,<code>onActivityCreated()</code>,<code>onStart()</code>,<code>onResume()</code>,<code>onPause()</code>,<code>onStop()</code>,<code>onDestroyView()</code>,<code>onDestroy()</code>,<code>onDetach()</code>。</p>

<p>从返回栈回来后执行的第一个方法是<code>onActivityCreated()</code>,而Activity的轮回后执行的第一个方法是<code>onRestart()</code>,然后再<code>onStart()</code>,<code>onResume()</code>。</p>

<p>同一个Activity怎样让它在不同大小的设备自动加载不同的布局文件呢？用<code>限定符</code>,即在<code>res</code>下建<code>layout-large</code>文件夹或者不同限定符的文件夹，在里面放<code>同名</code>的布局文件。限定符有：<code>small</code>,<code>normal</code>,<code>large</code>,<code>xlarge</code>以及分辨率限定符：<code>ldpi</code>:120dpi以下，<code>mdpi</code>:120-160dpi，<code>hdpi</code>:160-240dpi,<code>xhdpi</code>:240-320dpi，以及方向限定符：<code>land</code>:横屏,<code>port</code>:竖屏。</p>

<p>还有个问题，<code>large</code>，大，到底多大算大呢？可以自己定义这个边界值。如<code>layout-sm600</code>,就是<code>宽度</code>大于600<code>dp</code>的设备叫大，否则叫小。<code>sm</code>的意思是：<code>smallest width</code>。</p>

<h3>* Broadcast 广播</h3>

<p>见名知意，即发一下消息，很多地方都可以收到。广播有两种：异步执行的广播 和 按顺序执行的同步广播。异步广播接收没有先后之分，可看做同时收到，这种广播发出之后不可被拦截。同步广播是按顺序一个一个执行，可以设置接收的优先级(设置<code>IntentFilter</code>的<code>priority</code>值,越大越优先)，这种广播可以被拦截(在<code>onReceive()</code>方法里调用<code>abortBroadcast()</code>废掉这条广播)。</p>

<p>注册接收广播有两种方式：一种是用代码注册，也叫动态注册，动态注册(在<code>onCreate()</code>里调用Activity的方法<code>registerReceiver()</code>)的广播接收一定要在<code>onDestroy</code>中移除注册(调用Activity的<code>unregisterReceiver()</code>)。另一种叫静态注册，是在xml中配置的，这种注册不用移除。</p>

<p>怎么写广播接收器？写个类继承<code>BroadcastReceiver</code>,它是个抽象类，然后重写<code>onReceive()</code>即可，可以通过<code>intent.getAction()</code>来区分不同广播，<strong>在<code>onReceive()</code>方法中不能开启线程</strong>。下面是一个监听网络变化的广播接收器。</p>

<pre><code>class NetWorkChangeReceiver extends BroadcastReceiver{
    @Override
    public void onReceive(Context context,Intent intent){
        ConnectivityManager connectivityManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
        if (networkInfo != null &amp;&amp; networkInfo.isAvailable()){
            Toast.makeText(context,"网络可用",Toast.LENGTH_SHORT).show();
        }else {
            Toast.makeText(context,"网络不可用",Toast.LENGTH_SHORT).show();
        }
    }
}
</code></pre>

<p>用Activity里的方法发送异步广播<code>sendBroadcaset(intent)</code>,和发送同步广播<code>sendOrderedBroadCaset(intent,null)</code>。这样发送的广播都是<code>跨应用</code>的，即A应用发出的广播，B应用也可以收到的！应为这些都是全局广播。</p>

<p>本地广播，即发出的广播只会被<code>本身应用</code>接收到,手机里的其他应用就收不到了。本地广播要用<code>LocalBroadcastManager</code>这个类来管理，即注册和移除的时候不能用<code>Activity</code>的<code>registerReceiver()</code>和<code>unregisterReceiver()</code>方法，而应该用<code>LocalBroadcastManager</code>实例的<code>registerReceiver()</code>和<code>unregisterReceiver()</code>方法，简单吧！<strong>本地广播不会被静态注册的接收器收到！</strong>要接收本地广播，接收器都得用动态注册的方式。</p>

<h3>* ContentProvider / ContentResolver</h3>

<p>这个是用于在手机中<code>不同应用程序</code>间的数据传递，可以自己选择那些数据可暴露出来给其他应用获取。有些系统的应用程序已经提供这样的接口了，可以直接通过这种方式获取数据，如 短信应用，通讯录应用等，而我们自己写的应用程序则要自己写这个数据提供接口。</p>

<p>获取数据通过<code>ContentResolver</code>类，可以通过Context 的 <code>getContentResolver()</code>得到实例，然后数据处理就是 <code>insert()</code>,<code>update()</code>,<code>delete()</code>,<code>quert()</code>,和<code>SQLiteDatabase</code>很像，但不是传<code>表名</code>而是传<code>Uri</code>。</p>

<p>提供数据，要继承抽象类<code>ContentProvider</code>然后重写里面的六个方法：<code>onCreate()</code>,<code>quert()</code>,<code>insert()</code>,<code>update()</code>,<code>delete()</code>,<code>getType()</code>。</p>

<h3>* NotificationManager</h3>

<p>Notification 在手机顶部提示用户的通知，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress搭建个人博客]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/14/jiaocheng/"/>
    <updated>2015-11-14T11:21:39+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/14/jiaocheng</id>
    <content type="html"><![CDATA[<p>本人的博客刚刚搭建好，并绑定了个人域名(<a href="http://guimingsu.com">guimingsu.com</a>)，现将该过程记录下来。</p>

<p><a href="https://pages.github.com/">Github Pages</a>是Github提供的一个免费空间，相当于我们博客的免费托管服务器，我们写的博客就是放这上面的。它可以拥有一个独立的二级域名如xxx.github.io(如果有自己的个人域名，可以用自己的个人域名指向它)，允许开发者提交静态网页文件，用于介绍自己，或者自己的开源项目，可以看作是个人或项目主页。</p>

<p><a href="http://octopress.org/">Octopress</a>“A blogging framework for hackers”，即像写代码似的写博客。一个博客网页生成框架，我们按照它要求的格式写博客内容，然后敲命令<code>rake generate</code>,<code>rake deploy</code>,就可以把网页放到Github服务器上，然后我们就可以看到了啊，它就是一个写博客的工具可以这样理解。</p>

<p>个人域名，这个要自己买了，可以上<a href="http://wanwang.aliyun.com/">阿里云</a>上买，一年几十块，配置后面再讲。在注册阿里云的时候我用的QQ邮箱，就是收不到邮件，换成Gmail就收到了。不知道是我网络问题还是大公司间的任性撕逼，如果你也收不到邮件就换个邮箱注册吧。<!--more--></p>

<ul>
<li><p>在<a href="https://github.com">Github</a>上New repository, 名字为<code>yourNmae.github.io</code>确定提交，这里报错是因为我已经建好了。
<img src="http://andyfightting.github.io/myimg/other/creat_rep.png" alt="creat_rep" />
之后会生成一个HTTPS连接如 <a href="https://github.com/yourName/yourName.github.io.git">https://github.com/yourName/yourName.github.io.git</a> ,这个连接在之后的Octopress绑定配置中要用。</p></li>
<li><p><a href="http://octopress.org/docs/setup/">Octopress</a>这个步骤比较多一点, 我用的系统是 OS X10.10.5。Octopress要用到ruby环境，且ruby版本要大于等于<code>1.9.3</code>。可以用<code>ruby -v</code>命令看一下ruby版本，我的是版本是<code>2.0.0p643</code>, 没有的话可以看<a href="https://ruby-china.org/wiki/install_ruby_guide">这里</a>安装ruby环境。</p></li>
</ul>


<p>环境装好后从网上下载Octopress框架到本地电脑上，这里我保存到octopress文件夹且放在桌面上</p>

<p>下载： <code>git clone git://github.com/imathis/octopress.git /Users/suguiming/Desktop/octopress</code></p>

<p>然后进入该文件夹：<code>cd  /Users/suguiming/Desktop/octopress</code></p>

<p>然后：  <code>gem install bundler</code></p>

<p>这里可能会报错，说缺少xxx依赖包，可以用<code>gem dependency</code>查看要依赖的包，然后把包都装上再敲上面的命令</p>

<p>然后： <code>bundle install</code></p>

<p>再然后：  <code>rake install</code></p>

<p>这里Octopress就下载安装好了，之后要进行关联配置,把Octopress和Github关联起来，我们就可以把博客放到之前建的Github项目<code>yourNmae.github.io</code>里了。</p>

<p>但关联前还有一个步骤就是SSH key处理。新建一个命令窗口<code>cd ~/.ssh</code>进入目录，<code>ls -a</code>查看内容，这时候一般没有<code>id_rsa</code>及<code>id_rsa.pub</code>这两个文件的，我们现在要创建这两个文件。<code>ssh-keygen -t rsa -C "Github登录账号邮箱@qq.com"</code>,然后按回车回车再回车就生成那两个文件了。然后把<code>id_rsa.pub</code>里的东西全选复制，在<a href="https://github.com/settings/ssh">这里</a>添加一个SSH key即可。</p>

<p>回到octopress的命令窗口，输入命令<code>rake setup_github_pages</code> 此时要求输入Github项目<code>yourNmae.github.io</code>的地址，即前面得到的<code>https://github.com/yourName/yourName.github.io.git</code>,也可在Github中项目里的右下角的HTTPS链接复制过来然后</p>

<pre><code>rake generate
rake deploy
git add .
git commit -m 'say something'
git push origin source
</code></pre>

<ul>
<li>写博客，<code>rake new_post["file name"]</code>新建一个写博客的文件，它会在<code>/source/_posts</code>文件夹里生成,打开它在里面写博客内容就可以了。它是用markdown的方式写，可以在<a href="http://wowubuntu.com/markdown/">这里</a>和<a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">这里</a>查看markdown的使用规则，常用的就那几个，熟悉就可以了,大概长这样。推荐使用<a href="http://mouapp.com/">Mou</a>来编写markdown文件，<a href="https://maxiang.io/">马克飞象</a>这个在线编写工具也很好。
  <img src="http://andyfightting.github.io/myimg/other/write_blog.png" alt="write_blog" />
  写好后保存，<code>rake generate</code>生成博客，<code>rake preview</code>预览博客，在地址栏输入<code>http://localhost:4000/</code>查看，退出预览<code>control+C</code></li>
</ul>


<p>然后提交，之后在地址栏输入<code>yourName.github.io</code>就可以查看了</p>

<pre><code>rake deploy
git add .
git commit -m 'say something'
git push origin source
</code></pre>

<ul>
<li><p>域名绑定，在<code>yourName.github.io</code>项目里新建一个文件，文件名必须是大写的<code>CNAME</code>,内容是你购买的域名如我的域名<code>guimingsu.com</code>,前面不要加www或http,参考<a href="https://help.github.com/articles/adding-a-cname-file-to-your-repository/">这里</a>,然后<code>git pull</code>把刚才建的文件同步到本地。
然后在域名购买的服务商那里设置，我用的是<a href="http://www.aliyun.com/">阿里云</a>。登录账号，在控制管理，域名解析中添加域名指向,把图中的<code>andyfightting.github.io</code>换成你自己的，其他的不变,这样域名就配置好了
<img src="http://andyfightting.github.io/myimg/other/yuming.png" alt="img" />
参考<a href="https://help.github.com/articles/my-custom-domain-isn-t-working/">这里</a>
<img src="http://andyfightting.github.io/myimg/other/dns_error.png" alt="img" /></p></li>
<li><p>其他个性化配置，如在浏览器显示的icon替换，在source文件夹里面有个文件叫favicon.png，做一个16*16图片替换进去提交，可能不会立即有反应。还有博客的评论系统是用的第三方<a href="https://disqus.com">disqus</a>。在该网站上注册一个账号，然后把账号名填写在<code>/octopress/_config.yml</code>文件中对应的地方，把false改成true。</p></li>
</ul>


<p><img src="http://andyfightting.github.io/myimg/other/discus.png" alt="img" /></p>

<p>由于访问国外disqus比较慢，我又把评论部分改用国内的<a href="http://duoshuo.com/">多说</a>了，使用方法都类似的，具体配置请看<a href="http://www.tuicool.com/articles/VbqYNjn">这里</a>,里面还说了性能优化可以跟着改改，提高网页的响应速度。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Octopress]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/13/my-octopress/"/>
    <updated>2015-11-13T21:03:44+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/13/my-octopress</id>
    <content type="html"><![CDATA[<p>Hello World !!
<img src="http://andyfightting.github.io/myimg/other/octopress.png" alt="img" /></p>
]]></content>
  </entry>
  
</feed>
