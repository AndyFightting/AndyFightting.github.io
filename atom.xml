<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[阿贵]]></title>
  <link href="http://andyfightting.github.io/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-08-02T09:00:17+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS中的Runloop与Runtime]]></title>
    <link href="http://andyfightting.github.io/blog/2016/08/01/runtime/"/>
    <updated>2016-08-01T10:20:14+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/08/01/runtime</id>
    <content type="html"><![CDATA[<h3><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">Runloop</a></h3>

<p>Runloop与线程息息相关，它是线程的基础架构部分，每个线程都有自己的runloop对象，可以用[NSRunLoop currentRunLoop]来得到它。主线程中的runloop是启动运行状态，而自己创建的线程中的runloop默认是没有启动的，需要的话要手动去启动。Runloop是一个事件处理循环，用来不停的监听输入事件或者定时事件，并将其分配到对应的目标上进行处理。它可以使线程在有工作的时候工作，没有工作的时候休眠。</p>

<p>Runloop同时也负责autorelease pool的创建和释放，每当一个运行循环结束的时候，它都会释放autorelease pool，同时pool中的所有自动释放类型变量都会被释放掉。NSRunloop不是线程安全的，而CFRunLoopRef是线程安全的。RunLoop要指定在特定Mode下Run：</p>

<p>*NSDefaultRunLoopMode：处理大多数的操作，一般情况下用这个。</p>

<p>*NSRunLoopCommonModes：For Cocoa applications, this set includes the default, modal, and event tracking modes by default. Core Foundation includes just the default mode initially.</p>

<p>而且通过scheduleInRunLoop的方式启动的请求，虽然是在主线程中执行！但也会有异步的效果！SDWebImageDownloader 中的 NSURLConnection 就是这样启动请求的！！</p>

<pre><code>- (void)start{
    NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:15];
    self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];
    [connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
    [connection start];
    if (connection){
        self.imageData = [NSMutableData data];
    }else{
        if ([delegate respondsToSelector:@selector(imageDownloader:didFailWithError:)]){
            [delegate performSelector:@selector(imageDownloader:didFailWithError:) withObject:self withObject:nil];
        }
    }
}
</code></pre>

<p>NSURLConnection在代理方法中打印出的线程：
<img src="http://andyfightting.github.io/myimg/ios/sdrunloop.png" alt="iamge" /></p>

<p>runloop监听用户输入事件和定时事件
<img src="http://andyfightting.github.io/myimg/ios/runloop.png" alt="image" /><!--more--></p>

<h3><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Runtime</a></h3>

<p>Runtime是个很重要的概念，iOS之所以是动态语言就是因为它。它的核心是一个用C和编译语言写的Runtime库。它是Objective-C面向对象和动态机制的基石。静态语言是在编译的时候就已经绑定好了某个方法名会执行哪段函数地址。而动态语言不是在编译的时候就已经绑定好了，它是在具体要执行的某个方法的时候，才根据方法名去寻找具体执行的方法地址，所以可以在这时候动态的改变它的绑定。可以在<a href="https://opensource.apple.com/tarballs/objc4/">这里</a>下载源码查看。</p>

<p>&ldquo;计算机界，只要再加一层中间层，就没有解决不了的问题。如果有，那再加一层，直到它解决。"这句话不知道是在哪里看到的了&hellip;不过说的挺有道理的。而Runtime库正是Objective-C之所以为动态语言的中间层！</p>

<p>在Objective-C中，类、对象和方法都是一个C的结构体，从objc/objc.h头文件中，我们可以找到他们的定义：</p>

<pre><code>//---NSObject-----
@interface NSObject &lt;NSObject&gt; {
     Class isa 
}

//---Class-----
typedef struct objc_class *Class;

//---objc_class-----
struct objc_class {
    Class isa 
    Class super_class                                        
    const char *name                                         
    long version                                             
    long info                                                
    long instance_size //对象大小                                      
    struct objc_ivar_list *ivars //属性列表                             
    struct objc_method_list **methodLists //方法列表                   
    struct objc_cache *cache  //方法映射缓存                               
    struct objc_protocol_list *protocols   //代理列表                   
};

//---objc_method----
struct objc_method {  
    SEL method_name //方法名
    char *method_types //a string representing argument/return types
    IMP method_imp  //方法地址
};
</code></pre>

<p>Objective-C的函数调用在编译的时候会被翻译为 -objc_msgSend(执行的对象，方法名，参数&hellip;),先通过isa指针找到它的Class,然后在method list里找方法，没有的话就上superClass中找，一旦找到，就去执行，然后把方法名和对应的方法地址映射保存在objc_cache中，下次就直接从这缓存中取。如果都没找到，会在程序报unrecognized selector sent to&hellip;错误之前还有机会补救，就是动态的给它指定一个执行方法！</p>

<p>首先，Objective-C运行时会调用+resolveInstanceMethod:或者+resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回YES，那运行时系统就会重新启动一次消息发送的过程。下面用当我调用test方法的时候，没有test的实现方法，但把它动态绑定给了newTest方法去执行！</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    [self performSelector:@selector(test) withObject:nil afterDelay:0];
}

void newTest(){
    NSLog(@"success !!");
}

+ (BOOL)resolveInstanceMethod:(SEL)aSEL{
    if(aSEL == @selector(test)){
        class_addMethod([self class], aSEL, (IMP)newTest, nil);
        return YES;
    }
    return [super resolveInstanceMethod:aSEL];
}
</code></pre>

<p>如果resolveInstanceMethod：方法返回NO话，就会转到-forwardingTargetForSelector:方法中去执行,让这个方法在其他对象中去执行！如下面把test方法传递给 viewController2 对象去执行，在 viewController2 对象中实现的 test 方法就会被调用！！</p>

<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)aSEL{
    return NO;
}

- (id)forwardingTargetForSelector:(SEL)aSelector{
    if(aSelector == @selector(test)){
        return viewController2;//传递给viewController2对象去执行 test方法
    }
    return [super forwardingTargetForSelector:aSelector];
}
</code></pre>

<p>如果forwardingTargetForSelector：方法返回nil或者self的时候，就会进入- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector:方法中去执行，如果这方法返回了一个NSMethodSignature对象，这会进入-forwardInvocation:方法中，把消息传给对应的对象去执行！如下将会在viewController2中执行test方法！！</p>

<pre><code>+ (BOOL)resolveInstanceMethod:(SEL)aSEL{
    return NO;
}

- (id)forwardingTargetForSelector:(SEL)aSelector{
    return self;
}

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{
    NSMethodSignature* signature = [super methodSignatureForSelector:aSelector];
    if (signature==nil) {
        signature = [viewController2 methodSignatureForSelector:aSelector];
    }
    return signature;
}

- (void)forwardInvocation:(NSInvocation *)invocation{
    SEL sel = invocation.selector;
    if([viewController2 respondsToSelector:sel]) {
        [invocation invokeWithTarget:viewController2];
    }else {
        [self doesNotRecognizeSelector:sel];
    }
}
</code></pre>

<p>如果这三个过程下来都没绑定具体的执行方法，则会进入- (void)doesNotRecognizeSelector:(SEL)aSelector方法，然后程序奔溃!!</p>

<p>Method Swizzling,下面的例子中，当调用test1方法的时候，具体执行是跑到test2方法中的！！</p>

<pre><code>@implementation ViewController
+ (void)load {
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    Class class = [self class];

    SEL originalSelector = @selector(test1);
    SEL swizzledSelector = @selector(test2);

    Method originalMethod = class_getInstanceMethod(class, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);

    BOOL didAddMethod =
    class_addMethod(class,
                    originalSelector,
                    method_getImplementation(swizzledMethod),
                    method_getTypeEncoding(swizzledMethod));

    if (didAddMethod) {
        class_replaceMethod(class,
                            swizzledSelector,
                            method_getImplementation(originalMethod),
                            method_getTypeEncoding(originalMethod));
    } else {
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
});
}

- (void)viewDidLoad {
    [super viewDidLoad];
    [self test1];
}
-(void)test1{
    NSLog(@"开始1");
}
-(void)test2{
    NSLog(@"开始2");
}
</code></pre>

<p>Swizzling应该总是在+load中执行,在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。</p>

<p>这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>

<p>Swizzling应该总是在dispatch_once中执行, 因为swizzling会改变全局状态，所以我们需要它确保代码只被执行一次，不管有多少个线程，而GCD的dispatch_once可以确保这种行为。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[韩语]]></title>
    <link href="http://andyfightting.github.io/blog/2016/06/22/hanyu/"/>
    <updated>2016-06-22T18:46:52+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/06/22/hanyu</id>
    <content type="html"><![CDATA[<p>모음元音:ㅏ ㅓ ㅗ ㅜ ㅣ ㅡ ㅐ ㅔ ㅚ ㅟ ㅑ ㅕ ㅛ ㅠ ㅒ ㅖ ㅘ ㅙ ㅞ ㅢ</p>

<p>자음子音:ㅂ ㅍ ㅃ ㅁ ㄷ ㅌ ㄸ ㄴ ㄹ ㅈ ㅊ ㅉ ㅅ ㅆ ㄱ ㅋ ㄲ ㅎ</p>

<p>받침收音:ㄱ ㄴ ㄷ ㄹ ㅁ ㅂ ㅇ 实际收音只有这7种，双收音就发其中一种！</p>

<p>ㅅ ㅈ ㅊ ㅌ ㅎ ㅆ 都收 ㄷ 音。</p>

<h4>第一到十课</h4>

<p>아이小孩， 아우弟弟， 어이怎么，오이黄瓜，이牙齿，바보傻瓜，비雨，삐삐BB机，아빠阿爸，파葱，피血，무萝卜，모苗，나무树，다리腿 桥，또又，오리鸭子，머리头，나비蝴蝶，토마토西红柿，따다采摘，배梨，애나무小树，누르다压，모으다聚集， 베麻布，모래沙子，누에蚕，위胃，뇌脑，뒤后，되다成为，부르다叫，지구地球，바지裤子，치마裙子，마차马车，찌다蒸，짜다咸，사자狮子，수저勺 筷子，아저씨大叔，쏘다射击，구두皮鞋，가구歌手，까치喜鹊，코끼리大象，코鼻子，카메라相机，호수湖，휴지废纸，야구棒球，야자椰子，여자女子，소녀少女，요리菜，차표车票，유리玻璃，뉴스新闻，얘喂，걔那孩子，예从前，시계钟表，과자点心饼干，기와瓦，더하기相加，추수秋收，돼지猪，궤柜子，궤도轨道，의사医生，의자椅子，국汤，목脖子，눈眼睛，문门，걷다走路，굳다硬，밀小麦，달月亮，마음心， 남别人，밥饭，입嘴，공장工厂，강江，맛味道，낮白天，낫镰刀，팥小豆，끝结束，좋다好，쌓다堆，밖外面，동녘东方，옆旁边</p>

<p>안녕하세요你好，안녕히 가세요再见，안녕히 계세요再见，또 만나요回见，누구세요谁呀，저예요我啊，어서 오세요快请进， 반갑습니다见到你很高兴，여기에 앉으세요请坐这里，감사합니다谢谢，네 고맙습니다好的 谢谢，괜찮습니다没关系，신문 주세요请给我报纸，어느 신문요什么报纸，중국 신문요中国报纸，여기가 어디예요这是什么地方，중국대사관이 멀어요这儿离中国大使馆远吗，안 멀어요,가까워요不远，很近，어디 가세요去哪儿，학교에 가요去学校白天，</p>

<h4>第十一到二十课</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[日语]]></title>
    <link href="http://andyfightting.github.io/blog/2016/03/27/japanese/"/>
    <updated>2016-03-27T18:46:52+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/03/27/japanese</id>
    <content type="html"><![CDATA[<h2>一</h2>

<p><strong>平假名：</strong></p>

<p>あa いi うu えe おo 、かka きki くku けke こko 、さsa しsi すsu せse そso 、たta ちchi つtsu てte とto 、なna にni ぬnu ねne のno 、はha ひhi ふfu へhe ほho 、まma みmi むmu めme もmo 、やya ゆyu よyo 、らra りri るru れre ろro 、わwa をwo 、んn 。</p>

<p><strong>片假名：</strong></p>

<p>アイウエオ、カキクケコ、サシスセソ、タチツテト、ナニヌネノ、ハヒフヘホ、マミムメモ、ヤユヨ、ラリルレロ、ワヲ、ン。</p>

<!--more-->


<p><strong>生疏单词：</strong></p>

<p>出迎え：でむかえ　迎接。手帳：てちょう　记事本。デパート：百货商店。マンション：公寓。レストラン：餐馆。受付：うけつけ　接待处。バーゲン会場：大卖场。エスカレーター：自动扶梯。スイッチ：开关。ビデオ：录像机。サッカーボール：足球。ビール：啤酒。交番：こうばん　派出所。警察署：けいさつしょ　警察局。八百屋：やおや　蔬菜店。床屋：とこや　理发店。浴室　よくしつ。台所　だいどころ　厨房。ベランダ　阳台。エアコン 空调。リモコン　遥控器。まな板　まないた　切菜板。包丁　ほうちょう　菜刀。 流し　ながし 洗碗池。オーブン　烤箱。電子レンジ 微波炉。ドライヤ　吹风机。 タオル　毛巾。せっけん　香皂。 シャンプー　洗发水。トイレットペーパー　卫生纸。枕　まくら　枕头。掛け布団　かけぶとん　被子。電気スタンド　台灯。 目覚まし時計　めざましどけい　闹钟。押し入れ　おしいれ　壁橱。 座布団　ざぶとん　坐垫。 畳　たたみ　草席。</p>

<p><strong>语法：</strong></p>

<p>〜は〜です。〜は〜ではありません。〜は〜ですか。〜の〜。〜に〜があります/います。〜は〜にあります/います。〜と〜。？＋も＋否定。誰もいません。何もいません。</p>

<p><strong>常用句子：</strong></p>

<p>おはようございます。こんにちは。さようなら。こんばんは。おやすみなさい。すみません。ありがとうございます、いいえ、どういたしまして。いただきます。ごちそうさまでした。はい、そうです。いいえ、ちがいます。どうも、すみまえん。どうぞ、よろしく。こちらこそ。これは何ですか。トイレはどこですか。これはおいくらですか。それおください。ご趣味は何ですか。失礼ですが、お仕事は何ですか。ご出身はどちらですか。すみませんですが。</p>

<p><strong>亲属称谓</strong></p>

<p>祖父　そふ。祖母　そぼ。父　ちち。母　はは。息子　むすこ。娘　むすめ。兄弟　きょうだい。兄　あに。姉　あね。弟　おとうと。妹　いもうと。おじ、おば。</p>

<p><strong>数字</strong></p>

<p>れい、ぜろ0　いち1　に2　さん3　し、よん4　ご5　ろく6　しち、なな7　はち8　く、きゅう9 じゅう10 ひゃく百　せん千　まん万　おく亿　れいてんいち0.1　さんぶんのに2/3　</p>

<p>さんびゃく300  ろっぴゃく600　 はっぴゃく800  　</p>

<p>さんぜん3000　はっせん8000 　いっせんまん一千万 　 いちおく一亿</p>

<h2>二</h2>

<p><strong>生疏单词</strong></p>

<p>ゆうべ。あさって。　毎月まいつき。毎年まいとし。フェリー渡轮。髪をとかします。歯をみがきます。靴をはきます。靴を脱ぎます。かぎを開けます。かぎをかけます。電話おかけます。切手をはります。ファックスを送ります。お金を払います。電気をつけます、消します。料理を作ります。シャワーを浴びます。申込書　もうしこみしょ　申请书。プレゼント。パンルレト。チケット。ボールペン。速達そくたつ。チョコレート。届きます　とどきます　收到。習います　ならいます、教えます　おしえます。チンジャオロース。ゆでる　煲汤。チャーハン。</p>

<p><strong>语法</strong></p>

<p>〜ます/ません。　〜ました/ませんでした。时间+に+动。 〜から〜まで。〜は〜。〜ごろ。〜へ行きます。〜から来ます。〜で+动。 名+と。　〜から〜まで。たしか〜。まっすぐ〜。〜はいつですか。たしか〜だろです。地で〜します。〜か〜。动作对象を。 动作场所で。〜に〜をあげます。〜に〜をもらいます。〜に〜を送ります。〜にあいます。工具で〜を动。〜からもらいます。</p>

<p><strong>常用句子</strong></p>

<p>いまなんじですか。何時から何時まで働きますか。いつ始まりますか。来週の土曜日です。お宅はどちらですか。何で行きますか。うちには子供がいません。お先に失礼します。お疲れ様でした。〜をください。〜を食べますか。何をしますか。いらっしゃいませ。行ってきます、いってまいります。いってらっしゃい。いらっしゃいませ。かしこまりました。お邪魔します。これからひる昼ごはんですか。いっしょにいきます。日本語で手紙を書きます。太りますよ。さっき、たった今。よっかたです。切符売り場はどこですか。〜までいくらですか。何時発ですか。〜までどのぐらいかかりますか。</p>

<p><strong>时间和星期</strong></p>

<p>いちじ1时　いっふん1分　にじ2时　にふん2分　さんじ3时　さんぷん3分　よじ4时　よんぷん4分　ごじ5时　ごふん5分　ろくじ6时　ろっぷん6分　しちじ7时　ななふん7分　はちじ8时　はっぷん8分　くじ9时　きゅうふん9分　じゅうじ10时　じゅっぷん10分　なんぷん几分</p>

<p>月曜日げつようび　火曜日かようび　水曜日すいようび　木曜日もくようび　金曜日きんにょうび　土曜日どようび　日曜日にちようび　何曜日なんょうび</p>

<p>月都是读がつ、但　每月：まいつき</p>

<p>いち1　に2　さん3　し4　ご5　ろく6　しち7　はち8　く9　じゅう10　じゅういち11　じゅうに12</p>

<p>特殊号</p>

<p>ついたち1号　ふつか2号　みっか3号　よっか4号　いつか5号　むいか6号　なのか7号　ようか8号　ここのか9号　とおか10号　はつか20号 じゅうよっか14号　なんにち何日 其他的就是〜にち。</p>

<h2>三</h2>

<p><strong>生疏单词</strong></p>

<p>梅雨つゆ。霧きり。雷かみなり。虹にじ。蒸し暑い　むしあつい。汚い　きたない。ヒマワリ。バラ。座ります　すわります。かたち　形。ネクタイ。布　ぬの。片づけます　かたづけます 整理。短い　みじかい。まじめ。唇　くちびる。舌　した。首くび。肩かた。腕うで。ベンチ。点字ブロック。階段　台阶。自動改札口。自動券売機。運賃表　票价表。網棚　あみだな。</p>

<p><strong>语法</strong></p>

<p>あまり＋否定。あつい&ndash;>あつくない。あつい&ndash;>あつかった&ndash;>あつくなかった。〜すきです。韓国語がわかります。１は２より〜です。１より２のほが〜です。中国は日本より広いです。日本より中国のほが広いです。１は２ほど+否定。神戸は大坂ほどにぎやかではありません。</p>

<p><strong>常用句子</strong></p>

<p>ちょうどいいです。すばらしいながめですね。本当に。どんなお土産をかいますか。いかがですか。今結構です。気に入りますか。運転ができませんから、いつも電車です。迷いますね。お入り下さい。かまいません。いくらぐらいかかりますか。そこお左(ひだり)に曲(ま)がってください。ここで止めて下さい。〜どこにあるか知らない。すぐにいきます。</p>

<p><strong>程度副词</strong></p>

<p>とても。たいへん。すこし。ちょっと。あまり。ぜんぜん。</p>

<p><strong>10以内特殊量词</strong></p>

<p>ひ1　ふ2　み3　よ4　いつ5　む6　なな7　や8　ここ9　とお10
ひとつ　ふたつ　みっつ　よっつ　いつつ　むっつ　ななつ　やっつ　ここのつ　とお</p>

<p><strong>形态变化</strong></p>

<p>一类形容词的过去式：い变成かった。楽しい　————》楽しかった、楽しくなかった。</p>

<p>动词ます形：把末尾ます去掉。</p>

<p>动词て形：这个稍微复杂点&hellip;</p>

<p>1.一类动词一般是去掉ます后加て。但有几个特殊情况：きーーいて　ぎーーいで　び、み、にーーんで　ち、り、いーーって　しーーして。</p>

<p>2.二类和三类动词都是ます去掉加て。</p>

<p>3.口诀：う、つ、る促音变，ぬ、ふ、む拨音变，く、ぐ结尾い音变，以し结尾して变，特殊いく促音变。</p>

<p>~て或~てから表示动作相继发生。</p>

<p>~てください。表请求。</p>

<p>~ています。正在进行。</p>

<p>~てもいいです。&hellip;也可以</p>

<p>~てはいけません。&hellip;不可以</p>

<p>一类形容词的て形：いーーくて、二类形容词+で　表并列。</p>

<p>〜ています。表动作结束后留下的持续结果的状态。比如我有一辆车，我认识某人。</p>

<p>名+が欲しいです。想要。。。</p>

<p>名+をたいです。想。。。</p>

<p>形+なります・します。</p>

<p>ない形：</p>

<p>1.一类动词：去掉ます、最后一个音变成あ段+ ない。（い要变成わ）</p>

<p>2.去掉ます＋ない。</p>

<p>2.きますーーこない、　しますーーしない。</p>

<p>ないでください。不要   なければなりません。必须。 なくてもいいです。不&hellip;也可以。</p>

<p>动词基本型：最后的发音为う段：う、く、す、つ、ぬ、ふ、む、ゆ、る。如かきーーかく。きますーーくる。しますーーしる。</p>

<p>动词基本型+ことができます。会什么&hellip;</p>

<p>动词た形：动词て形的てーーた、でーーだ。た形表示过去。</p>

<p>日语的简体形和敬体形：</p>

<p>敬体即~ます。〜です。简体不用。“基本型”“ない形”“た形”不加ます、です都是简体形。</p>

<p>动たり、动たり　します。举例</p>

<p>一形かったり　一形かったりです。二形だったり　二形だったりです。名だったり　名だったりです。</p>

<p>简体+と思います。认为&hellip;</p>

<p>动词简体+の：名词化。手紙を出すのを忘れました。　</p>

<p>修饰名词的小句中的主语用が不用は。私が知らない人から手紙が来ました。</p>

<p>动词去掉ます+ながら：边做某事。李さんはテリビを見ながら食事をしています。</p>

<p>名词のとき、动基時、一形時、二形な時。&hellip;的时候。一次性个别的用 時に。</p>

<p>あげます、もらいます、くれます。给。 动て+あげます、もらいます、くれます。给某人做某事。</p>

<p>命令型：一类动词基本型最后变成え段上的音。二类动词基本型る变ろ。三类くる&ndash;こい、する&ndash;しろ。</p>

<p>请&hellip;.：去掉ます＋なさい。</p>

<p>禁止：基本型+な。</p>

<p>意志形：当场表示决心或者意志。一类动词基本型最后因变お段加长音う。二类动词る变よう。三类こよう、しよう。</p>

<p>说话之前已经形成的意志：动基+つもりです、ことにします、ことになります、そうです。</p>

<p>动+ておきます。准备&hellip;</p>

<p><strong>单词</strong></p>

<p>简体+かもしれません　也许。仲（なか）がいいですね。关系好。もしかしたら　也许。つい一不小心。お久（ひさ）しぶりです　好久不见。ご無沙汰しています　久疏问候。あいさつ　寒暄。について　关于。そう言えば　话说&hellip; 売り上げ　销售额。 取り引き　交易。お年寄り　老年人。 通います　かよいます　上学，往来。踊ります　おどります　跳舞。しばらく　好久。それに　累加关系 而且。引っ越し　搬迁。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[黄山之旅]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/31/huang-shan/"/>
    <updated>2015-12-31T13:31:16+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/31/huang-shan</id>
    <content type="html"><![CDATA[<p>黄山~向往已久，这次终于成行~哈哈~先来感受一下大自然的神奇魅力吧~是不是让人心旷神怡~~
<img src="http://andyfightting.github.io/myimg/other/IMG_1182.jpg" alt="image" /><!--more-->
<img src="http://andyfightting.github.io/myimg/other/IMG_1183.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/IMG_1185.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/IMG_1229.jpg" alt="image" />
上山路上遇到的猴子，呲牙咧嘴的好凶&hellip;连吃东西的姿势都这么霸气&hellip;
<img src="http://andyfightting.github.io/myimg/other/IMG_0952.jpg" alt="image" />
日落~~能明显的感觉到气温随着太阳的下降而下降&hellip;
<img src="http://andyfightting.github.io/myimg/other/IMG_1082.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/IMG_1102.jpg" alt="image" />
在山脚下遇到的小伙伴，我们一起爬山，一起游玩，一起欣赏美景
<img src="http://andyfightting.github.io/myimg/other/IMG_1201.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/IMG_1199.jpg" alt="image" />
来几张自拍&hellip;
<img src="http://andyfightting.github.io/myimg/other/IMG_1225.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/IMG_1031.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/IMG_1040.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/IMG_1055.jpg" alt="image" />
最后消失在云雾里
<img src="http://andyfightting.github.io/myimg/other/IMG_1245.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/IMG_1254.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/IMG_1260.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的CoreText]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/26/core-text/"/>
    <updated>2015-12-26T15:16:23+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/26/core-text</id>
    <content type="html"><![CDATA[<p>CoreText进行图文混排的核心思想是把需要摆放图片的位置用空字符替换原来的字符，并且实现CTRunDelegate，用于动态设置空字符的高度和宽度（代表图片的大小），并且对这些空字符设置一个属性名来区别于其他CTRun，之后进行图片渲染的时候就能通过该属性来区分哪些空字符是代表图片的占位符，哪些是普通的空字符。使用CoreText处理点击事件的关键是判断点击的位置是本文内容中的第几个字符，然后通过判断该字符是否在需要处理点击事件的字符串范围内。</p>

<p><img src="http://andyfightting.github.io/myimg/ios/text2.png" alt="image" /><!--more-->
<img src="http://andyfightting.github.io/myimg/ios/coreText.png" alt="image" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#import "CoreTextView.h"
</span><span class='line'>#import &lt;CoreText/CoreText.h&gt;
</span><span class='line'>
</span><span class='line'>@implementation CoreTextView{
</span><span class='line'>    CTFrameRef ctFrame;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (id)initWithFrame:(CGRect)frame
</span><span class='line'>{
</span><span class='line'>    self = [super initWithFrame:frame];
</span><span class='line'>    if (self) {
</span><span class='line'>        // Initialization code
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)drawRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    //得到当前用于绘制画布的上下文，用于后续将内容绘制在画布上
</span><span class='line'>    CGContextRef context = UIGraphicsGetCurrentContext();
</span><span class='line'>    
</span><span class='line'>    //翻转当前的坐标系, 因为对于底层绘制引擎来说，屏幕左下角为（0，0)
</span><span class='line'>    CGContextSetTextMatrix(context, CGAffineTransformIdentity);
</span><span class='line'>    CGContextTranslateCTM(context, 0, self.bounds.size.height);
</span><span class='line'>    CGContextScaleCTM(context, 1.0, -1.0);
</span><span class='line'>    
</span><span class='line'>    //要绘制的文字
</span><span class='line'>    NSMutableAttributedString* attributedString = [[NSMutableAttributedString alloc] initWithString:@"少年不识愁滋味，爱上层楼。爱上层楼。为赋新词强说愁。而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。"];
</span><span class='line'>    //为所有文本设置字体
</span><span class='line'>    [attributedString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:10] range:NSMakeRange(0, [attributedString length])];
</span><span class='line'>    //设置某些字体更大
</span><span class='line'>    [attributedString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(10, 10)];
</span><span class='line'>    //index 从0开始的2个字符 字体颜色 设置为蓝色
</span><span class='line'>    [attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(0, 2)];
</span><span class='line'>    //index 从2开始的3个字符 字体颜色 设置为红色
</span><span class='line'>    [attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(2, 3)];
</span><span class='line'>    //设置行间距 50
</span><span class='line'>    CGFloat lineSpacing = 50;
</span><span class='line'>    CTParagraphStyleSetting theSettings[3] = {
</span><span class='line'>        {kCTParagraphStyleSpecifierLineSpacingAdjustment, sizeof(CGFloat), &lineSpacing},
</span><span class='line'>        {kCTParagraphStyleSpecifierMaximumLineSpacing, sizeof(CGFloat), &lineSpacing},
</span><span class='line'>        {kCTParagraphStyleSpecifierMinimumLineSpacing, sizeof(CGFloat), &lineSpacing}
</span><span class='line'>    };
</span><span class='line'>    CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, 3);
</span><span class='line'>    [attributedString addAttribute:(id)kCTParagraphStyleAttributeName value:(__bridge id)theParagraphRef range:NSMakeRange(0, attributedString.length)];
</span><span class='line'>    CFRelease(theParagraphRef);
</span><span class='line'>    
</span><span class='line'>    //要插入的图片
</span><span class='line'>    NSString *imageName = @"testImage.png";
</span><span class='line'>    
</span><span class='line'>    //为图片设置CTRunDelegate 计算留给图片的空间大小
</span><span class='line'>    CTRunDelegateCallbacks imageCallbacks;
</span><span class='line'>    imageCallbacks.version = kCTRunDelegateVersion1;
</span><span class='line'>    imageCallbacks.getAscent = GetAscentCallback;
</span><span class='line'>    imageCallbacks.getDescent = GetDescentCallback;
</span><span class='line'>    imageCallbacks.getWidth = GetWidthCallback;
</span><span class='line'>    
</span><span class='line'>    //设置图片位置，大小
</span><span class='line'>    CTRunDelegateRef runDelegate = CTRunDelegateCreate(&imageCallbacks, imageName);
</span><span class='line'>    NSMutableAttributedString *imageAttributedString = [[NSMutableAttributedString alloc] initWithString:@" "];//空格用于给图片留位置
</span><span class='line'>    [imageAttributedString addAttribute:(NSString *)kCTRunDelegateAttributeName value:(id)runDelegate range:NSMakeRange(0, 1)];//用代理设置图片
</span><span class='line'>    CFRelease(runDelegate);
</span><span class='line'>    
</span><span class='line'>    //把图片插入到字符串中
</span><span class='line'>    [imageAttributedString addAttribute:@"imageAttribute" value:imageName range:NSMakeRange(0, 1)];
</span><span class='line'>    [attributedString insertAttributedString:imageAttributedString atIndex:1];//图片插入位置，不能越界
</span><span class='line'>    [attributedString insertAttributedString:imageAttributedString atIndex:3];//图片插入位置，不能越界
</span><span class='line'>    [attributedString insertAttributedString:imageAttributedString atIndex:5];//图片插入位置，不能越界
</span><span class='line'>    
</span><span class='line'>    //根据attributedString生成CTFramesetterRef
</span><span class='line'>    CTFramesetterRef ctFramesetter = CTFramesetterCreateWithAttributedString((CFMutableAttributedStringRef)attributedString);
</span><span class='line'>    CGMutablePathRef path = CGPathCreateMutable();
</span><span class='line'>    CGRect bounds = CGRectMake(0.0, 0.0, self.bounds.size.width, self.bounds.size.height);
</span><span class='line'>    CGPathAddRect(path, NULL, bounds);
</span><span class='line'>    
</span><span class='line'>    //绘制文字
</span><span class='line'>    ctFrame = CTFramesetterCreateFrame(ctFramesetter,CFRangeMake(0, [attributedString length ]), path, NULL);
</span><span class='line'>    CTFrameDraw(ctFrame, context);
</span><span class='line'>    
</span><span class='line'>    //下面都是为了绘制图片
</span><span class='line'>    CFArrayRef lines = CTFrameGetLines(ctFrame);
</span><span class='line'>    CGPoint lineOrigins[CFArrayGetCount(lines)];
</span><span class='line'>    CTFrameGetLineOrigins(ctFrame, CFRangeMake(0, 0), lineOrigins);
</span><span class='line'>    
</span><span class='line'>    //遍历每个CTLine
</span><span class='line'>    for (int i = 0; i &lt; CFArrayGetCount(lines); i++) {
</span><span class='line'>        CTLineRef line = CFArrayGetValueAtIndex(lines, i);
</span><span class='line'>        CGFloat lineAscent;
</span><span class='line'>        CGFloat lineDescent;
</span><span class='line'>        CGFloat lineLeading;
</span><span class='line'>        CTLineGetTypographicBounds(line, &lineAscent, &lineDescent, &lineLeading);
</span><span class='line'>        
</span><span class='line'>        CFArrayRef runs = CTLineGetGlyphRuns(line);
</span><span class='line'>        for (int j = 0; j &lt; CFArrayGetCount(runs); j++) {
</span><span class='line'>            CGFloat runAscent;
</span><span class='line'>            CGFloat runDescent;
</span><span class='line'>            CGPoint lineOrigin = lineOrigins[i];
</span><span class='line'>            CTRunRef run = CFArrayGetValueAtIndex(runs, j);
</span><span class='line'>            NSDictionary* attributes = (NSDictionary*)CTRunGetAttributes(run);
</span><span class='line'>            
</span><span class='line'>            CGRect runRect;
</span><span class='line'>            runRect.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0,0), &runAscent, &runDescent, NULL);
</span><span class='line'>            runRect=CGRectMake(lineOrigin.x + CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL), lineOrigin.y - runDescent, runRect.size.width, runAscent + runDescent);
</span><span class='line'>            
</span><span class='line'>            NSString *isImage = [attributes objectForKey:@"imageAttribute"];
</span><span class='line'>            //图片渲染逻辑
</span><span class='line'>            if (isImage) {
</span><span class='line'>                UIImage *image = [UIImage imageNamed:imageName];
</span><span class='line'>                if (image) {
</span><span class='line'>                    CGRect imageDrawRect;
</span><span class='line'>                    imageDrawRect.size = image.size;
</span><span class='line'>                    imageDrawRect.origin.x = runRect.origin.x + lineOrigin.x;
</span><span class='line'>                    imageDrawRect.origin.y = lineOrigin.y;
</span><span class='line'>                    CGContextDrawImage(context, imageDrawRect, image.CGImage);
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    //释放资源
</span><span class='line'>    //    CFRelease(ctFrame); //因为点击要用ctFrame，所以放dealloc里释放
</span><span class='line'>    CFRelease(path);
</span><span class='line'>    CFRelease(ctFramesetter);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//接受触摸事件
</span><span class='line'>-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
</span><span class='line'>    UITouch *touch = [touches anyObject];
</span><span class='line'>    CGPoint location = [touch locationInView:self];
</span><span class='line'>    
</span><span class='line'>    //获取每一行
</span><span class='line'>    CFArrayRef lines = CTFrameGetLines(ctFrame);
</span><span class='line'>    CGPoint origins[CFArrayGetCount(lines)];
</span><span class='line'>    //获取每行的原点坐标
</span><span class='line'>    CTFrameGetLineOrigins(ctFrame, CFRangeMake(0, 0), origins);
</span><span class='line'>    CTLineRef line = NULL;
</span><span class='line'>    CGPoint lineOrigin = CGPointZero;
</span><span class='line'>    for (int i= 0; i &lt; CFArrayGetCount(lines); i++){
</span><span class='line'>        CGPoint origin = origins[i];
</span><span class='line'>        CGPathRef path = CTFrameGetPath(ctFrame);
</span><span class='line'>        //获取整个CTFrame的大小
</span><span class='line'>        CGRect rect = CGPathGetBoundingBox(path);
</span><span class='line'>        //坐标转换，把每行的原点坐标转换为uiview的坐标体系
</span><span class='line'>        CGFloat y = rect.origin.y + rect.size.height - origin.y;
</span><span class='line'>        //判断点击的位置处于那一行范围内
</span><span class='line'>        if ((location.y &lt;= y) && (location.x &gt;= origin.x)){
</span><span class='line'>            line = CFArrayGetValueAtIndex(lines, i);
</span><span class='line'>            lineOrigin = origin;
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    location.x -= lineOrigin.x;
</span><span class='line'>    //获取点击位置所处的字符位置，就是相当于点击了第几个字符
</span><span class='line'>    CFIndex index = CTLineGetStringIndexForPosition(line, location)-1;//index从0开始
</span><span class='line'>    UIAlertView* alert = [[UIAlertView alloc]initWithTitle:@"提示" message:[NSString stringWithFormat:@"点击了第 %d 个字符！！",(int)index] delegate:self cancelButtonTitle:@"ok" otherButtonTitles:nil, nil];
</span><span class='line'>    [alert show];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>-(void)dealloc{
</span><span class='line'>    [super dealloc];
</span><span class='line'>    CFRelease(ctFrame);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>#pragma mark CTRunDelegate Callbacks
</span><span class='line'>CGFloat GetAscentCallback( void *refCon ){
</span><span class='line'>    NSString *imageName = (NSString *)refCon;
</span><span class='line'>    return [UIImage imageNamed:imageName].size.height;
</span><span class='line'>}
</span><span class='line'>CGFloat GetDescentCallback(void *refCon){
</span><span class='line'>    return 0;
</span><span class='line'>}
</span><span class='line'>CGFloat GetWidthCallback(void *refCon){
</span><span class='line'>    NSString *imageName = (NSString *)refCon;
</span><span class='line'>    return [UIImage imageNamed:imageName].size.width;
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>运行结果
<img src="http://andyfightting.github.io/myimg/ios/coreResult.png" alt="image" /></p>

<h3>*TextKit</h3>

<p>由于用CoreText是用绘图方式实现图文混排，复杂难用。所以在iOS7新推出了新的文字排版技术 &ndash; TextKit。使用TextKit可以很方便的实现富文本、表情混排和图文混排等效果。它是UIKit framework中定义的一组用于提供高性能的排版、布局和展示文字的类和协议，比如展示特别的字间距、行间距、断行规则。从上面图2可知，它是基于CoreText的，且UILabel,UITextField,UITextView又都是基于TextKit的。</p>

<pre><code>UILabel* label = [[UILabel alloc]initWithFrame:self.view.bounds];
label.text = @"少年不识愁滋味，爱上层楼。爱上层楼。为赋新词强说愁。而今识尽愁滋味，欲说还休。欲说还休。却道天凉好个秋。";
label.numberOfLines = 0;
label.userInteractionEnabled = YES;
[self.view addSubview:label];

NSMutableAttributedString * attributeString = [label.attributedText mutableCopy];
[attributeString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, 10)];//设置颜色
[attributeString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:25] range:NSMakeRange(0, 5)];//设置字体
[attributeString addAttribute:NSUnderlineStyleAttributeName value:@(NSUnderlineStyleSingle) range:NSMakeRange(0, 15)];//设置下划线
[attributeString addAttribute:NSStrokeWidthAttributeName value:@(2) range:NSMakeRange(0, 3)];//设置空心字

//插入图片1
UIImage * image1 = [UIImage imageNamed:@"fengye.png"];
NSTextAttachment * attachment1 = [[NSTextAttachment alloc] init];
attachment1.bounds = CGRectMake(0, 0, 60, 60);
attachment1.image = image1;
NSAttributedString * attachStr1 = [NSAttributedString attributedStringWithAttachment:attachment1];
[attributeString insertAttributedString:attachStr1 atIndex:1];

//插入图片2
UIImage * image2 = [UIImage imageNamed:@"fengye.png"];
NSTextAttachment * attachment2 = [[NSTextAttachment alloc] init];
attachment2.bounds = CGRectMake(0, 0, 30, 30);
attachment2.image = image2;
NSAttributedString * attachStr2 = [NSAttributedString attributedStringWithAttachment:attachment2];
[attributeString insertAttributedString:attachStr2 atIndex:5];

label.attributedText = [attributeString copy];

//    TextView 通过如下可以设置环绕图片的文字
//    UIBezierPath * path = [UIBezierPath bezierPathWithRect:rect];
//    textView.textContainer.exclusionPaths = @[path];
</code></pre>

<p><img src="http://andyfightting.github.io/myimg/ios/textkit1.png" alt="image" /></p>

<pre><code> NSAttributedString属性key的说明
 NSFontAttributeName                设置字体属性，默认值：字体：Helvetica(Neue) 字号：12
 NSForegroundColorAttributeName     设置字体颜色，取值为 UIColor对象，默认值为黑色
 NSBackgroundColorAttributeName     设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色
 NSLigatureAttributeName            设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符
 NSKernAttributeName                设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄
 NSStrikethroughStyleAttributeName  设置删除线，取值为 NSNumber 对象（整数）
 NSStrikethroughColorAttributeName  设置删除线颜色，取值为 UIColor 对象，默认值为黑色
 NSUnderlineStyleAttributeName      设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似
 NSUnderlineColorAttributeName      设置下划线颜色，取值为 UIColor 对象，默认值为黑色
 NSStrokeWidthAttributeName         设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果
 NSStrokeColorAttributeName         填充部分颜色，不是字体颜色，取值为 UIColor 对象
 NSShadowAttributeName              设置阴影属性，取值为 NSShadow 对象
 NSTextEffectAttributeName          设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：
 NSBaselineOffsetAttributeName      设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏
 NSObliquenessAttributeName         设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾
 NSExpansionAttributeName           设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本
 NSWritingDirectionAttributeName    设置文字书写方向，从左向右书写或者从右向左书写
 NSVerticalGlyphFormAttributeName   设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本
 NSLinkAttributeName                设置链接属性，点击后调用浏览器打开指定URL地址
 NSAttachmentAttributeName          设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排
 NSParagraphStyleAttributeName      设置文本段落排版格式，取值为 NSParagraphStyle 对象
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的SQLite]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/25/ios-sqlite/"/>
    <updated>2015-12-25T10:44:52+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/25/ios-sqlite</id>
    <content type="html"><![CDATA[<p><img src="http://andyfightting.github.io/myimg/ios/sqlite.png" alt="image" /></p>

<p><a href="http://www.sqlite.org/">SQLite</a>是一个轻量级的关系型数据库，在iOS和Android手机中都有用到，C语言的面向过程的函数式编程。<a href="https://github.com/woooooojianjie/SQLitePersistentObject">SQLitePersistentObject</a>和<a href="https://github.com/ccgus/fmdb">FMDB</a>框架都是基于SQLite开发的。SQLitePersistentObject更像是个ORM框架，它是由Jeff LaMarche在2008年开发的，所以不是ARC的，要用的请加上<strong>-fno-objc-arc</strong>，且作者已经没有维护了，所以还是推荐使用更加广泛的FMDB。<!--more--></p>

<h3>*SQLite</h3>

<p>添加依赖库libsqlite3.tbd，用SQLite来个原生的增删改查。下面一次性完成了创建并打开数据库，创建表，插入一条数据，查询数据，最后关闭数据库。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString* docsdir = [NSSearchPathForDirectoriesInDomains( NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
</span><span class='line'>NSString* dbpath = [docsdir stringByAppendingPathComponent:@"user.sqlite"];
</span><span class='line'>sqlite3 *database;
</span><span class='line'>//创建并打开数据库*****************
</span><span class='line'>if (sqlite3_open([dbpath UTF8String], &database) != SQLITE_OK) { //SQLITE_OK == 0
</span><span class='line'>   sqlite3_close(database);
</span><span class='line'>   NSAssert(0,@"数据库打开失败"); //若状态不是0就打开失败
</span><span class='line'>}
</span><span class='line'>//创建表格*****************
</span><span class='line'>NSString *createSql = @"CREATE TABLE IF NOT EXISTS student (student_id INTEGER PRIMARY KEY ,student_name TEXT);";
</span><span class='line'>char *createError;
</span><span class='line'>//sqlite3_exec这个方法可以执行那些没有返回结果的操作，例如创建、插入、删除、修改等。这个函数包含了sqlite3_prepare这个函数的操作，目的是将UTF-8格式的SQL语句转换为编译后的语句
</span><span class='line'>if (sqlite3_exec(database, [createSql UTF8String], NULL, NULL, &createError) != SQLITE_OK) {
</span><span class='line'>    sqlite3_close(database);
</span><span class='line'>    NSAssert(0,@"创建表错误：%s", createError);
</span><span class='line'>}
</span><span class='line'>//插入或修改数据*****************  
</span><span class='line'>char *update = "INSERT OR REPLACE INTO student VALUES (?,?)";  
</span><span class='line'>sqlite3_stmt *statement;  
</span><span class='line'>if (sqlite3_prepare_v2(database, update, -1, &statement, nil) == SQLITE_OK) {  
</span><span class='line'>    //将值保存到指定的列,列从1开始！！  
</span><span class='line'>    sqlite3_bind_int(statement, 1, 4);//1是列，4是student_id  
</span><span class='line'>    //第四个参数代表第三个参数中需要传递的长度。对于C字符串来说，-1表示传递全部字符串。第五个参数是一个回调函数，比如执行后做内存清除工作。  
</span><span class='line'>    sqlite3_bind_text(statement, 2, [@"studentName" UTF8String], -1, NULL);  
</span><span class='line'>}    
</span><span class='line'>if (sqlite3_step(statement) != SQLITE_DONE) {  
</span><span class='line'>    NSAssert(0,@"更新数据出错");  
</span><span class='line'>}  
</span><span class='line'>sqlite3_finalize(statement);  
</span><span class='line'>//查询数据库***************** 
</span><span class='line'>NSString *querySql = @"SELECT * FROM student;";
</span><span class='line'>sqlite3_stmt *selectStmt;
</span><span class='line'>if (sqlite3_prepare_v2(database, [querySql UTF8String], -1, &selectStmt, nil) == SQLITE_OK) {
</span><span class='line'>    while (sqlite3_step(selectStmt) == SQLITE_ROW) {
</span><span class='line'>        int studentId = sqlite3_column_int(selectStmt, 0);//后面的数字对应每一列
</span><span class='line'>        char *cString = (char *)sqlite3_column_text(selectStmt, 1);
</span><span class='line'>        NSString* studentName = [[NSString alloc]initWithUTF8String:cString];
</span><span class='line'>        NSLog(@"student_id = %d   student_name = %@",studentId,studentName);
</span><span class='line'>    }
</span><span class='line'>    sqlite3_finalize(selectStmt);
</span><span class='line'>}
</span><span class='line'>sqlite3_close(database);//最后关闭数据库</span></code></pre></td></tr></table></div></figure>


<p><img src="http://andyfightting.github.io/myimg/ios/select.png" alt="image" />
<img src="http://andyfightting.github.io/myimg/ios/table.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的多线程]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/22/thread/"/>
    <updated>2015-12-22T14:28:22+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/22/thread</id>
    <content type="html"><![CDATA[<p>1.什么是进程</p>

<p>进程是指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。
<img src="http://andyfightting.github.io/myimg/ios/jincheng.png" alt="image" /><!--more--></p>

<p>2.什么是线程</p>

<p>进程要想执行任务必须通过线程来执行，1个进程至少会有1条线程(主线程)，进程的所有任务都在线程中执行。
<img src="http://andyfightting.github.io/myimg/ios/xiancheng.png" alt="image" /></p>

<p>线程中任务的执行是按顺序执行的，后面的任务要等前面的任务执行完了才能执行。但1个进程里可以开启多个线程来同时执行不同的任务，可以提高任务的执行效率。
<img src="http://andyfightting.github.io/myimg/ios/duox.png" alt="image" /></p>

<p>iOS中每个进程都会有一个主线程(UI线程)，<strong>只能在主线程中更新UI</strong>。如果在这个主线程里做了过多的耗时操作，就会造成UI卡顿，所以用多线程来处理耗时操作。常用的开启多线程方式有三种：NSThread, NSOperation, GCD。</p>

<h3>*NSThread</h3>

<p>NSThread是轻量级的多线程开发，用起来也不复杂。</p>

<p>初始化方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;
</span><span class='line'>- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument;</span></code></pre></td></tr></table></div></figure>


<p>其他方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)start;//启动一个线程，并非立即执行，而是处于就绪状态，当系统调度时才真正执行
</span><span class='line'>- (void)cancel;//取消
</span><span class='line'>+ (BOOL)isMainThread;//当前线程是不是主线程
</span><span class='line'>+ (NSThread *)mainThread //获取主线程
</span><span class='line'>+ (NSThread *)currentThread;//返回当前线程
</span><span class='line'>+ (BOOL)isMultiThreaded;//是不是多线程
</span><span class='line'>+ (void)sleepUntilDate:(NSDate *)date;//休眠
</span><span class='line'>+ (void)sleepForTimeInterval:(NSTimeInterval)ti;//休眠
</span><span class='line'>+ (void)exit;//退出
</span><span class='line'>+ (double)threadPriority;//优先级
</span><span class='line'>+ (BOOL)setThreadPriority:(double)p;//设置优先级 0~1
</span><span class='line'>- (BOOL)isExecuting;//正在执行
</span><span class='line'>- (BOOL)isFinished;//执行完毕
</span><span class='line'>- (BOOL)isCancelled;//已经取消</span></code></pre></td></tr></table></div></figure>


<p>在子线程里要调用主线程来更新UI,可以用NSObject类别中的 OnMainThread 方法(前两个)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface NSObject (NSThreadPerformAdditions)
</span><span class='line'>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;
</span><span class='line'>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;
</span><span class='line'>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array ;
</span><span class='line'>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait ;
</span><span class='line'>- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg ;
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>按顺序启动（start）的线程不一定是按顺序执行，由系统调度资源决定的，同样的代码多运行几次顺序就不一样了。
<img src="http://andyfightting.github.io/myimg/ios/shunxv.png" alt="image" />
<img src="http://andyfightting.github.io/myimg/ios/shunxv2.png" alt="image" /></p>

<h3>*NSOperation</h3>

<p>NSOperation是个抽象类，使用的话要<strong>继承它然后实现main方法</strong>。但它有两个现成子类：NSInvocationOperation和NSBlockOperation，后者使用Block形式进行代码组织，使用相对方便。</p>

<p>NSOperation要和NSOperationQueue一起使用，只要将一个NSOperation子类对象
放到NSOperationQueue队列中，线程就会依次启动。NSOperationQueue负责管理、执行所有的NSOperation，可以更加容易的管理线程总数和控制线程之间的依赖关系。可以通过监听<strong>isFinished</strong>属性来得到线程执行完毕通知。</p>

<p>NSOperation类中的方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)start;
</span><span class='line'>- (void)cancel;
</span><span class='line'>- (void)main;//继承后要实现具体操作
</span><span class='line'>- (void)addDependency:(NSOperation *)op;//添加线程间的依赖关系，A依赖B，所以要B先执行完再执行A(切记不要循环依赖...)
</span><span class='line'>- (void)removeDependency:(NSOperation *)op;//移除依赖关系
</span><span class='line'>- (void)waitUntilFinished;</span></code></pre></td></tr></table></div></figure>


<p>几个属性</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property (readonly, getter=isCancelled) BOOL cancelled;
</span><span class='line'>@property (readonly, getter=isExecuting) BOOL executing;
</span><span class='line'>@property (readonly, getter=isFinished) BOOL finished;
</span><span class='line'>@property (readonly, getter=isConcurrent) BOOL concurrent;//已经弃用，用下面的'asynchronous'
</span><span class='line'>@property (readonly, getter=isAsynchronous) BOOL asynchronous;//是否异步执行
</span><span class='line'>@property (readonly, getter=isReady) BOOL ready;</span></code></pre></td></tr></table></div></figure>


<p>为什么说<strong>NSOperation要和NSOperationQueue一起使用</strong>呢？因为如果NSOperation子类对象直接start启动的话，它其实是在主线程中执行的！
<img src="http://andyfightting.github.io/myimg/ios/error.png" alt="image" />
如果把NSOperation子类对象加到NSOperationQueue中,这就不是在主线程中执行了。
<img src="http://andyfightting.github.io/myimg/ios/right.png" alt="image" /></p>

<p>NSInvocationOperation就两个初始化方法，两个属性&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;
</span><span class='line'>- (instancetype)initWithInvocation:(NSInvocation *)inv;
</span><span class='line'>@property (readonly, retain) NSInvocation *invocation;
</span><span class='line'>@property (nullable, readonly, retain) id result;</span></code></pre></td></tr></table></div></figure>


<p>NSBlockOperation就两个方法，一个属性&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (instancetype)blockOperationWithBlock:(void (^)(void))block;//初始化
</span><span class='line'>- (void)addExecutionBlock:(void (^)(void))block;//创建一个新的线程来执行任务
</span><span class='line'>@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;//任务数组</span></code></pre></td></tr></table></div></figure>


<p><strong>addExecutionBlock</strong>会创建一个新的线程来执行任务，而不是在同一个子线程中。
<img src="http://andyfightting.github.io/myimg/ios/blockThread.png" alt="image" /></p>

<p>NSOperationQueue中的方法及属性，都很少&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)cancelAllOperations;//取消线程
</span><span class='line'>- (void)waitUntilAllOperationsAreFinished;
</span><span class='line'>+ (nullable NSOperationQueue *)currentQueue;
</span><span class='line'>+ (NSOperationQueue *)mainQueue;//获取主线程
</span><span class='line'>- (void)addOperation:(NSOperation *)op;//添加线程
</span><span class='line'>- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait;//添加线程数组
</span><span class='line'>- (void)addOperationWithBlock:(void (^)(void))block;//添加线程block
</span><span class='line'>@property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;
</span><span class='line'>@property (readonly) NSUInteger operationCount;//池子里几个线程
</span><span class='line'>@property NSInteger maxConcurrentOperationCount;//最大并发线程数
</span><span class='line'>@property (getter=isSuspended) BOOL suspended;//延迟
</span><span class='line'>@property (nullable, copy) NSString *name;//线程名字
</span><span class='line'>@property NSQualityOfService qualityOfService;// ??
</span><span class='line'>@property (nullable, assign) dispatch_queue_t underlyingQueue;// ??</span></code></pre></td></tr></table></div></figure>


<h3>*GCD</h3>

<p>GCD(Grand Central Dispatch)是基于C语言开发的一套多线程开发机制，也是苹果官方推荐的多线程开发方法。抽象层次最高，当然是用起来也最简单，只是它基于C语言开发，并不像NSOperation是面向对象的开发，而是完全面向过程的，最显著的优点就是它对于多核运算更加有效。</p>

<p>GCD中的队列分为<strong>串行队列</strong>和<strong>并发队列</strong>两类，都是异步的：</p>

<p>串行队列：只有一个子线程，加入到队列中的操作按添加顺序依次执行。</p>

<p>并发队列：有多个子线程，操作进来之后它会将这些队列安排在可用的处理器上，同时保证先进来的任务优先处理。</p>

<p><strong>1. 串行队列, 在同一个子线程里, 顺序执行！</strong> 关键字 <em>DISPATCH_QUEUE_SERIAL</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t serialQueue = dispatch_queue_create("myThreadQueue", DISPATCH_QUEUE_SERIAL);
</span><span class='line'>    for (int i=0; i&lt;5; ++i) {
</span><span class='line'>        dispatch_async(serialQueue, ^{
</span><span class='line'>            [self doSomething:i];
</span><span class='line'>        });
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p><img src="http://andyfightting.github.io/myimg/ios/gcd1.png" alt="image" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//更新UI界面,此处调用了GCD主线程队列的方法
</span><span class='line'>dispatch_queue_t mainQueue = dispatch_get_main_queue();
</span><span class='line'>  dispatch_sync(mainQueue, ^{
</span><span class='line'>    [self updateUI];
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p><strong>2. 并发队列, 在不同的子线程里, 并发执行</strong> 关键字 <em>DISPATCH_QUEUE_CONCURRENT</em></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> //方式一：dispatch_queue_t serialQueue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span><span class='line'> dispatch_queue_t serialQueue=dispatch_queue_create("myThreadQueue", DISPATCH_QUEUE_CONCURRENT);
</span><span class='line'>    for (int i=0; i&lt;5; ++i) {
</span><span class='line'>        dispatch_async(serialQueue, ^{
</span><span class='line'>            [self doSomething:i];
</span><span class='line'>        });
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p><img src="http://andyfightting.github.io/myimg/ios/ybbf.png" alt="image" />
若把上面的<strong>dispatch_async</strong>改成<strong>dispatch_sync</strong>,这就是在主线程中顺序执行了！即使在异步并发队列中！
<img src="http://andyfightting.github.io/myimg/ios/hah.png" alt="image" />
所以，GCD若要<strong>异步多线程</strong>执行必须：使用异步队列<strong>DISPATCH_QUEUE_CONCURRENT</strong> 并且 方法是异步方法(dispatch_async)!! 否则，要么在<strong>子线程</strong>里顺序执行(串行队列，异步方法(dispatch_async))，要么在<strong>主线程</strong>里顺序执行！！(同步方法(dispatch_sync)，不管串行还是并发队列)</p>

<p>解决异步情况下抢占资源问题，可以加锁<strong>NSLock</strong>。获取资源时lock住，获取完资源后unlock。或者用<strong>@synchronized</strong>包裹获取资源代码。</p>

<p>几个线程执行完后得到通知</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_t group = dispatch_group_create();
</span><span class='line'>dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^{
</span><span class='line'>    //并发执行的任务一
</span><span class='line'>});
</span><span class='line'>dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^{
</span><span class='line'>    //并发执行的任务二
</span><span class='line'>});
</span><span class='line'>dispatch_group_notify(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0), ^{
</span><span class='line'>    //所有任务都执行完了得到通知
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSOperationQueue *queue = [[NSOperationQueue alloc]init];
</span><span class='line'>NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>     //并发执行的任务一
</span><span class='line'> }];
</span><span class='line'> [blockOperation addExecutionBlock:^{
</span><span class='line'>     //并发执行的任务二
</span><span class='line'> }];
</span><span class='line'> [blockOperation setCompletionBlock:^{
</span><span class='line'>     //所有任务都执行完了
</span><span class='line'> }];
</span><span class='line'> [queue addOperation:blockOperation];</span></code></pre></td></tr></table></div></figure>


<h3>*总结</h3>

<p>1.无论使用哪种方法进行多线程开发，每个线程启动后并不一定立即执行相应的操作，具体什么时候由系统调度，CPU空闲时就会执行。</p>

<p>2.更新UI应该在主线程（UI线程）中进行，常用的方法如下：</p>

<p>-(void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait</p>

<p>-(void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL) wait;//传递[NSThread mainThread]</p>

<p>[[NSOperationQueue mainQueue] addOperationWithBlock:^{ }];</p>

<p>dispatch_sync(dispatch_get_main_queue(), ^{ });</p>

<p>3.NSThread适合轻量级多线程开发，要手动控制线程，线程总数无法控制，无法线程依赖。</p>

<p>4.对于简单的多线程开发建议使用NSObject的扩展方法完成，而不必使用NSThread。</p>

<p>5.可以使用NSThread的currentThread方法取得当前线程，使用 sleepForTimeInterval:方法让当前线程休眠。</p>

<p>6.NSOperation进行多线程开发可以控制线程总数及线程依赖关系。</p>

<p>7.创建一个NSOperation不应该直接调用start方法, 如果直接start则会在主线程中调用, 而是应该放到NSOperationQueue中启动。</p>

<p>8.相比NSInvocationOperation推荐使用NSBlockOperation，代码简单，同时由于闭包性使它没有传参问题。</p>

<p>9.NSOperation是对GCD面向对象的封装，但是GCD基于C语言开发，效率却更高. 建议如果任务之间有依赖关系或者想要监听任务完成状态的情况下优先选择NSOperation否则使用GCD。</p>

<p>10.在GCD中串行队列中的任务被安排到一个单一的子线程中，可以方便地控制执行顺序；并发队列在多个线程中执行（前提是使用异步方法），顺序控制相对复杂，但是更高效。</p>

<p>11.在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并发队列并且使用异步方法执行时才能在多个线程中并发执行。</p>

<p>12.相比使用NSLock，@synchronized更加简单。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式]]></title>
    <link href="http://andyfightting.github.io/blog/2015/12/19/desigin-pattern/"/>
    <updated>2015-12-19T21:51:06+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/12/19/desigin-pattern</id>
    <content type="html"><![CDATA[<p>我理解的设计模式都是为了让代码模块化，结构化，各司其职，再把各个模块通过"接口"组合起来。封装变化；多用组合少用继承；针对接口编程，不针对实现编程；为交互对象之间的松耦合设计而努力；对扩展开放，对修改关闭。</p>

<h3>1.MVC模式</h3>

<p>看图就可以了，简洁明了~
<img src="http://andyfightting.github.io/myimg/other/mvc.png" alt="image" /><!--more--></p>

<h3>2.策略模式</h3>

<p>比如有个父类有飞行功能，然后有很多子类的飞行功能各不一样，如果去继承父类然后分别实现不同的飞行行为，这就坑爹了&hellip;具体做法应该是：把飞行行为完全独立出来成一个Interface，然后不同的飞行行为再在单独的类中实现，不同的子类要不同的飞行行为的话就取对应的行为实现对象。</p>

<p>父类：</p>

<pre><code>public class Duck {//父类

public FlyInterface flyInterface;//行为的接口成员变量

public void performFly(){//统一调用的飞行方法
    flyInterface.fly();
}

public void setFlyInterface(FlyInterface fi){//动态改变飞行行为
    flyInterface = fi;
  }
}
</code></pre>

<p>行为接口：</p>

<pre><code>public interface FlyInterface { //行为接口
void fly();//要实现的行为方法
}
</code></pre>

<p>行为的一种具体实现：</p>

<pre><code>public class FlyPatternOne implements FlyInterface {//飞行行为的一种实现，可以有很多个不同的实现
@Override
public void fly() {
    //这里是具体飞行行为代码

  }
}
</code></pre>

<p>某一个子类：</p>

<pre><code>public class SubDuck extends Duck{
public SubDuck(){
    //默认的飞行行为，不同的子类有不同的飞行行为，如 FlyPatternTwo FlyPatternThree...等
    flyInterface = new FlyPatternOne();
  }
}
</code></pre>

<p><img src="http://andyfightting.github.io/myimg/other/chelue.png" alt="image" /></p>

<p>1,找出可能需要变化之处，把它们独立封装起来，不要和那些不需要变化的代码混合在一起。</p>

<p>2.针对接口编程，而不是针对实现编程。</p>

<p>3.多用组合，少用继承。</p>

<h3>3.观察者模式</h3>

<p>好好看图吧，把它转化为具体代码加深理解
<img src="http://andyfightting.github.io/myimg/other/guanCha0.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha1.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha2.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha3.jpg" alt="image" /></p>

<p>看完上面例子，下面的设计图也更好理解了。
<img src="http://andyfightting.github.io/myimg/other/guanCha4.jpg" alt="image" /></p>

<p>使用Java内置的观察者模式
<img src="http://andyfightting.github.io/myimg/other/guanCha5.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha6.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha7.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/guanCha8.jpg" alt="image" /></p>

<p>Swing中的观察者模式
<img src="http://andyfightting.github.io/myimg/other/guanCha9.jpg" alt="image" /></p>

<p>要点
<img src="http://andyfightting.github.io/myimg/other/guanCha10.jpg" alt="image" /></p>

<h3>4.装饰模式</h3>

<p>动态的将责任附加到对象上，用对象组合的方式来解决继承滥用的问题。利用继承设计子类的行为是在编译时静态决定的，而且所有的子类都会继承到相同的行为。如果利用组合的做法扩展对象的行为，就可以在运行时动态的进行扩展。类应该多扩展开放，对修改关闭。即在不修改现有代码的情况下可以添加新的行为。</p>

<p>装饰着和被装饰着必须是同一类型，所以通过继承来实现。这里的继承是用来达到“类型一致”的，而不是为了通过继承得到“行为”。“行为”来自装饰着和基础组件，其他与装饰着之间的组合关系。
<img src="http://andyfightting.github.io/myimg/other/zhuangShi.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi0.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi1.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi2.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi3.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi4.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi5.jpg" alt="image" />
<img src="http://andyfightting.github.io/myimg/other/zhuangShi6.jpg" alt="image" /></p>

<h3>5.工厂模式</h3>

<p>当每次“new”的时候都会实例化一个类，所以这是用的实现编程而不是接口编程。“工厂”就是一个专门负责产生对象的一个类。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android基本存储]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/23/androidsave/"/>
    <updated>2015-11-23T19:48:52+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/23/androidsave</id>
    <content type="html"><![CDATA[<p>Android数据保存方式有： 文件存储, SharedPreference, Sqlite, SD卡存储。</p>

<h3>* 文件存储</h3>

<p>不对存储数据做任何格式化处理，原封不动的保存到文件中。使用于保存简单的文本数据或者二进制数据。</p>

<p>Context有个<code>openFileOutput()</code>方法接受两个参数，第一个：文件名，<strong>不要包含路径</strong>，第二个：操作方式，有两种，<code>MODE_PRIVATE</code>(覆盖原文件内容),<code>MODE_APPEND</code>(在原文件尾部追加内容)，默认第一种。文件默认保存在：<code>/data/data/packageName/files/</code>这个目录里。</p>

<pre><code> public static void saveText(Context context,String fileName,String text){
    FileOutputStream outputStream ;
    BufferedWriter bufferedWriter = null;
    try {
       outputStream = context.openFileOutput(fileName,Context.MODE_PRIVATE);
        bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write(text);
    }catch (IOException e){
        e.printStackTrace();
    }finally {
        try {
            if (bufferedWriter != null){
                bufferedWriter.close();
            }
        }catch (IOException e){
            e.printStackTrace();
        }
    }
}
</code></pre>

<!--more-->


<p>在我调用 <code>MyTool.saveText(this,"myFile","Hello World!");</code>后出现了如下文件，点画圈圈的地方可以导出到电脑上打开查看。
<img src="http://andyfightting.github.io/myimg/android/helloSave.png" alt="img" /></p>

<p>读文件</p>

<pre><code>public static String getText(Context context,String fileName){
    FileInputStream inputStream;
    BufferedReader bufferReader = null;
    StringBuilder contentBuilder = new StringBuilder();
    try {
        inputStream = context.openFileInput(fileName);
        bufferReader = new BufferedReader(new InputStreamReader(inputStream));
        String lineText = "";
        while ((lineText = bufferReader.readLine()) != null){
            contentBuilder.append(lineText);
        }
    }catch (IOException e){
        e.printStackTrace();
    }finally {
       if (bufferReader != null){
           try {
               bufferReader.close();
           }catch (IOException e){
               e.printStackTrace();
           }
       }
    }
    return contentBuilder.toString();
}
</code></pre>

<p>删除文件</p>

<pre><code>public static void deleteFile(Context context, String fileName) {
    String filePath = context.getFilesDir()+"/"+fileName;
    File file = new File(filePath);
    if (file.exists()){
        file.delete();
    }
}
</code></pre>

<h3>* SharedPreference</h3>

<p>用key-value键值对的方式保存数据，适用于保存应用配置之类的简单信息。有以下三种方式得到<code>SharedPreferences</code>对象，得到实例后调用实例的<code>edit()</code>方法得到<code>SharedPreferences.Editor</code>对象，用该<code>Editor</code>对象<code>putBoolean("key",value)``putString("key",value)</code>等方法添加数据，然后调用<code>apply()</code>即可。获取数据就调用对应的<code>getBoolean("key")``getString("key")</code>。文件保存在<code>/data/data/packageName/shared_prefs/</code>目录下。</p>

<ol>
<li><p>Context中的<code>getSharedPreferences()</code>方法接收两个参数，一个文件名(不要包含路径)，一个操作模式，有<code>MODE_PRIVATE</code>(覆盖原文件),<code>MODE_MULTI_PROCESS</code>(多个进程对文件进行读写情况)默认第一种。</p></li>
<li><p>Activity中也有个一个类似的方法<code>getSharedPreferences()</code>，它只接收一个操作模式作为参数，<strong>自动将类名作为文件名</strong>。</p></li>
<li><p>PreferenceManager类中的<code>getDefaultSharedPreferences()</code>，这是一个静态方法，接收一个参数<code>Context</code>,自动将应用程序的<code>packageName</code>为前缀的文件名,如我的包名是<code>com.suguiming.myandroid</code>,生成的文件名就是<code>com.suguiming.myandroid_preferences.xml</code>。</p></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SharedPreferences sharedPreferences =    PreferenceManager.getDefaultSharedPreferences(context);
</span><span class='line'>  SharedPreferences.Editor editor = sharedPreferences.edit();
</span><span class='line'>    editor.putString("name","guimingsu");
</span><span class='line'>    editor.putInt("age", 18);
</span><span class='line'>    editor.apply();</span></code></pre></td></tr></table></div></figure>


<p><img src="http://andyfightting.github.io/myimg/android/shareP.png" alt="img" />
<img src="http://andyfightting.github.io/myimg/android/shareV.png" alt="img" /></p>

<p>一般都把它做成一个工具类</p>

<pre><code>public class SharedPreUtil {

public static final String FILE_NAME = "shared_preference";

public static void put(Context context, String key, Object value) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPreferences.edit();

    if (value instanceof String) {
        editor.putString(key, (String) value);
    } else if (value instanceof Integer) {
        editor.putInt(key, (Integer) value);
    } else if (value instanceof Boolean) {
        editor.putBoolean(key, (Boolean) value);
    } else if (value instanceof Float) {
        editor.putFloat(key, (Float) value);
    } else if (value instanceof Long) {
        editor.putLong(key, (Long) value);
    } else {
        editor.putString(key, value.toString());
    }
    editor.apply();
}

public static Object get(Context context, String key, Object defaultValue) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);

    if (defaultValue instanceof String) {
        return sharedPreferences.getString(key, (String) defaultValue);
    } else if (defaultValue instanceof Integer) {
        return sharedPreferences.getInt(key, (Integer) defaultValue);
    } else if (defaultValue instanceof Boolean) {
        return sharedPreferences.getBoolean(key, (Boolean) defaultValue);
    } else if (defaultValue instanceof Float) {
        return sharedPreferences.getFloat(key, (Float) defaultValue);
    } else if (defaultValue instanceof Long) {
        return sharedPreferences.getLong(key, (Long) defaultValue);
    }
    return null;
}

public static void remove(Context context, String key) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPreferences.edit();
    editor.remove(key);
    editor.apply();
}

public static void removeAll(Context context) {
    SharedPreferences sharedPreferences = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
    SharedPreferences.Editor editor = sharedPreferences.edit();
    editor.clear();
    editor.apply();
}

}
</code></pre>

<h3>* SQLite</h3>

<p>关系型的轻量级数据库，保存复杂或者大数据用这个，支持标准的SQL语法。</p>

<p>创建数据库：Android提供了一个抽象类<code>SQLiteOpenHelper</code>，我们继承它重写里面的两个方法<code>onCreate()</code>,<code>onUpdate()</code>来创建和更新数据库表结构。创建的数据库会保存在 <code>/data/data/packageName/databases/</code>目录下。通过<code>getReadableDatabase</code>或者<code>getWritableDatabase</code>都可得到可读写的数据库，但如果数据库不可写时(如磁盘已满)，<code>getWritableDatabase</code>会报错，<code>getReadableDatabase</code>不会。</p>

<p>调用<code>MySqliteHelper.getHelper(mainActivity).getReadableDatabase();</code>一下数据库就建好了，下次再调用就不会再创建了。</p>

<pre><code>public class MyDatabaseHelper extends SQLiteOpenHelper {

private static MyDatabaseHelper helper;
private static final String DB_NAME = "myAndroid.db";

public MyDatabaseHelper(Context context){
    super(context, DB_NAME, null, 2);//2 数据库version,修改数据库用
}

@Override
public void onCreate(SQLiteDatabase db) {
    db.execSQL(create_dog);
    db.execSQL(create_cat);
}

@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    //更新表才用,这里假设在 版本2 中要添加 cat 表,注意：switch 不要 break !!
    switch (newVersion){
        case 2:
            db.execSQL(create_cat);
        default:
    }
}
//获取 helper 单例
public static synchronized MyDatabaseHelper getHelper(Context context) {
    context = context.getApplicationContext();
    if (helper == null) {
        synchronized (MyDatabaseHelper.class) {
            if (helper == null)
                helper = new MyDatabaseHelper(context);
        }
    }
    return helper;
}

//-------------sql----------------------------
    public static final String create_dog = "create table dog ("
            +"id integer primary key autoincrement,"
            +"name text,"
            +"age integer,"
            +"weight real)";

    public static final String create_cat = "create table cat ("
            +"id integer primary key autoincrement,"
            +"name text,"
            +"age integer,"
            +"weight real)";
}
</code></pre>

<p><img src="http://andyfightting.github.io/myimg/android/mydb.png" alt="img" />  <br/>
把数据库导出到桌面，用<a href="http://www.sqlitemanager.org/">SQLiteManager</a>打开查看
<img src="http://andyfightting.github.io/myimg/android/mytable.png" alt="img" /></p>

<p>数据增，删，改，查的最简单的例子</p>

<pre><code>public class DogDao {
private static final String TABLE_NAME = "dog";

public static void add(Context context,Dog dog){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("name",dog.getName());
    values.put("age",dog.getAge());
    values.put("weight",dog.getWeight());
    db.insert(TABLE_NAME, null, values);
}

public static void update(Context context,Dog dog){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("name",dog.getName());
    values.put("age",dog.getAge());
    values.put("weight",dog.getWeight());
    db.update(TABLE_NAME, values, null, null);
}

public static void deleteAll(Context context){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    db.delete(TABLE_NAME, null, null);
}

public static List&lt;Dog&gt; getAll(Context context){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    Cursor cursor = db.query(TABLE_NAME, null, null, null, null, null, null);
    List&lt;Dog&gt; dogList = new ArrayList&lt;&gt;();
    if (cursor.moveToFirst()){
        do {
            Dog dog = new Dog();
            dog.setName(cursor.getString(cursor.getColumnIndex("name")));
            dog.setAge(cursor.getInt(cursor.getColumnIndex("age")));
            dog.setWeight(cursor.getFloat(cursor.getColumnIndex("weight")));
            dogList.add(dog);
        }while (cursor.moveToNext());
    }
    cursor.close();
    return dogList;
}

//事务，要么都成功，要么都失败。
public static void transactionTest(Context context){
    SQLiteDatabase db =  MyDatabaseHelper.getHelper(context).getWritableDatabase();
    db.beginTransaction();
    try {
        //数据处理....

        db.setTransactionSuccessful();
    }catch (Exception e){
        e.printStackTrace();
    }finally {
        db.endTransaction();
    }
}
}
</code></pre>

<p>也可以用 Android SDK <code>/platform-tools</code>文件夹中自带的<code>adb</code>工具来操作链接在电脑的手机或者模拟器里的数据库。</p>

<p>但要先配置一下，Mac的配置如下，在终端依次输入 <code>cd ~</code> <code>touch .bash_profile</code> <code>open -e .bash_profile</code>这时会打开一个文本文件，在里面添加<code>export PATH=${PATH}:这里是platform-tools文件的路径</code>保存关闭，
然后<code>source .bash-profile</code>刷新，然后输入<code>adb shell</code>就可以开始用了。
<img src="http://andyfightting.github.io/myimg/android/pzadb.png" alt="img" />
<img src="http://andyfightting.github.io/myimg/android/pzadb2.png" alt="img" />
如查看数据库<code>cd /data/data/packageName/databases</code> <code>l</code>列出所有数据库
<img src="http://andyfightting.github.io/myimg/android/adbtable.png" alt="img" /></p>

<h3>* SD卡存储</h3>

<p>SD卡存储和文件存储差不多，只不过是手机外部的存储空间，容量更大，不过在使用的时候要判断SD卡可不可以用。</p>

<pre><code>public class SDCardUtil {

// 默认都保存在这个文件夹下
private static final String DEFAULT_DIR = "ProData/";

public static boolean isEnable() {
    return Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED);
}

public static long getTotalMB() {
    if (!isEnable())
        return 0;
    File path = Environment.getExternalStorageDirectory();
    StatFs stat = new StatFs(path.getPath());
    long blockSize = stat.getBlockSizeLong();
    long availableBlocks = stat.getBlockCountLong();
    return (availableBlocks * blockSize) / 1024 / 1024;
}

public static long getAvailableMB() {
    if (!isEnable())
        return 0;
    File path = Environment.getExternalStorageDirectory();
    StatFs stat = new StatFs(path.getPath());
    long blockSize = stat.getBlockSizeLong();
    long availableBlocks = stat.getAvailableBlocksLong();
    return (availableBlocks * blockSize) / 1024 / 1024;
}

public static long getAvailableByte() {
    if (!isEnable())
        return 0;
    File path = Environment.getExternalStorageDirectory();
    StatFs stat = new StatFs(path.getPath());
    long blockSize = stat.getBlockSizeLong();
    long availableBlocks = stat.getAvailableBlocksLong();
    return availableBlocks * blockSize;
}

// 路径：/storage/sdcard0/
public static String getSDCardPath() {
    if (!isEnable())
        return "";
    return Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator;
}


public static File createDir(String directoryName) {
    //建默认文件夹
    String defaultDir = getSDCardPath() + DEFAULT_DIR;
    File defaultFile = new File(defaultDir);
    if (!defaultFile.exists()) {
        defaultFile.mkdir();
    }

    String dirPath = getFilePath(directoryName);
    File dirFile = new File(dirPath);
    if (!dirFile.exists()) {
        dirFile.mkdir();
    }
    return dirFile;
}

public static File createFile(String fileName) {
    try {
        //建默认文件夹
        String dirPath = getSDCardPath() + DEFAULT_DIR;
        File directory = new File(dirPath);
        if (!directory.exists()) {
            directory.mkdir();
        }

        //再在默认文件夹里建文件
        File file = new File(getFilePath(fileName));
        if (!file.exists()) {
            file.createNewFile();
        }
        return file;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}

public static String getFilePath(String fileName) {
    return getSDCardPath() + DEFAULT_DIR + fileName;
}

public static boolean isFileExist(String fileName) {
    File file = new File(getFilePath(fileName));
    return file.exists();
}

public static boolean saveByte(String fileName, byte[] bytes) {
    if (bytes == null) {
        return false;
    }

    OutputStream output = null;
    try {
        if (bytes.length &lt; getAvailableByte()) {
            File file = createFile(fileName);//这里面已经建了默认文件夹
            output = new BufferedOutputStream(new FileOutputStream(file));
            output.write(bytes);
            output.flush();
            return true;
        }
    } catch (IOException e1) {
        e1.printStackTrace();
    } finally {
        try {
            if (output != null) {
                output.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return false;
}

public static byte[] getByte(String fileName) {
    File file = new File(getFilePath(fileName));
    if (!file.exists()) {
        return null;
    }
    InputStream inputStream = null;
    try {
        inputStream = new BufferedInputStream(new FileInputStream(file));
        byte[] data = new byte[inputStream.available()];
        inputStream.read(data);
        return data;
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (inputStream != null) {
                inputStream.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return null;
}

public static boolean saveBitmap(Bitmap bitmap, String bitmapName) {
    if (bitmap == null) {
        return false;
    }
    //建默认文件夹
    String dirPath = getSDCardPath() + DEFAULT_DIR;
    File directory = new File(dirPath);
    if (!directory.exists()) {
        directory.mkdir();
    }

    File file = new File(getFilePath(bitmapName));
    BufferedOutputStream output = null;
    try {
        output = new BufferedOutputStream(new FileOutputStream(file));
        bitmap.compress(Bitmap.CompressFormat.JPEG, 80, output);
        output.flush();
        output.close();
        return true;
    } catch (IOException e1) {
        e1.printStackTrace();
    } finally {
        try {
            if (output != null) {
                output.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return false;
}

public static Bitmap getBitmap(String bitmapName) {
    String myJpgPath = getFilePath(bitmapName);
    BitmapFactory.Options options = new BitmapFactory.Options();
    return BitmapFactory.decodeFile(myJpgPath, options);
}

public static void removeFile(String fileName) {
    String filePath = getFilePath(fileName);
    File file = new File(filePath);
    if (file.exists()) {
        file.delete();
    }
}

public static void removeFile(File file) {
    if (file.isFile()) {
        file.delete();
        return;
    }
    if (file.isDirectory()) {
        File[] childFiles = file.listFiles();
        if (childFiles == null || childFiles.length == 0) {
            file.delete();
            return;
        }

        for (int i = 0; i &lt; childFiles.length; i++) {
            removeFile(childFiles[i]);
        }
        file.delete();
    }
}

public static void removeAll() {
    String filePath = getSDCardPath() + DEFAULT_DIR;
    File file = new File(filePath);
    if (file.exists()) {
        removeFile(file);
    }

    //再建一个空文件夹
    File directory = new File(filePath);
    if (!directory.exists()) {
        directory.mkdir();
    }
  }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio插件]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/22/studioplugin/"/>
    <updated>2015-11-22T14:10:45+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/22/studioplugin</id>
    <content type="html"><![CDATA[<h3>* Logger</h3>

<p>推荐一款打印工具<a href="https://github.com/orhanobut/logger">Logger</a>,比自带的打印效果更好，主要是json打印是格式化的！Github上写的地址<code>compile 'com.github.orhanobut:logger:1.12'</code>我下载失败，我用的是<code>compile 'com.orhanobut:logger:1.11'</code>。
<img src="http://andyfightting.github.io/myimg/android/logger.png" alt="img" />
打印颜色可以在preference里设置，要先<code>Save as</code>保存一下，然后把右边的<code>Use inherited attributes</code>取消，然后就可以选择颜色了<!--more-->
<img src="http://andyfightting.github.io/myimg/android/logColor.png" alt="img" /></p>

<h3>* Sexy Editor</h3>

<p>设置编辑区域背景图的, 这样敲代码也更有力气拉~~哈哈</p>

<p><img src="http://andyfightting.github.io/myimg/android/screen.png" alt="img" /></p>

<p>怎么添加插件？有如下三种方式<code>install JetBrains plugin</code>,<code>Browse repositories</code>,<code>install plugin from disk</code>。<code>Sexy Editor</code>是用第二种方式添加。</p>

<p><img src="http://andyfightting.github.io/myimg/android/add_plugin.png" alt="img" /></p>

<p>我的<code>sexy editor</code>设置</p>

<p><img src="http://andyfightting.github.io/myimg/android/sexy_editor.png" alt="img" /></p>

<h3>* Mac下的快捷键</h3>

<p>Mac中的标识：<code>⌘:command</code>, <code>⌃:control</code>, <code>⇧:shift</code>, <code>⌥:alt/option</code></p>

<p><code>⌘ + ⌥ + L</code>: 代码对齐格式化</p>

<p><code>^ + ⌥ + O</code>: 除去无效的import引用</p>

<p><code>F1</code>: 查看文档</p>

<p><code>F2</code>: 定位到未被使用的成员</p>

<p><code>F3</code>: 添加书签</p>

<p><code>F4</code>: 定位到声明处</p>

<p><code>⇧ + F6</code>: 文件重命名</p>

<p><code>⌘ + F12</code>: 显示内部成员</p>

<p><code>⌘ + ⇧ + F7</code>: 代码高亮</p>

<p><code>⌥ + ⏎</code>: 添加缺少的import</p>

<p><code>⌘ + delete</code>: 删除整行</p>

<p><code>⌘ + N</code>: 生成代码，getter setter 等</p>

<p><code>⌃ + H</code>: 查看类的层级关系</p>

<p><code>⌘ + U</code>: 查看父类的同名方法</p>

<p><code>⌘ + J</code>: 快捷插入常用代码片段</p>

<p><code>⌥ + ⇧ + ↑或↓</code>: 上下移动光标所在的行</p>

<p><code>⌘ + ⇧ + ↑或↓</code>: 上下移动整个方法块</p>

<p><code>⌘ + ⌥ + ⏎</code>: 当前行上面插入一行</p>

<p><code>⌘ + ⇧ + U</code>: 大小写转化</p>

<p><code>⌘ + E</code>: 查看打开过的文件</p>

<p><code>⌃ + T</code>: 重构面板</p>

<p><code>⌃ + O</code>: 选择要重写或者要实现的方法</p>

<p><code>⌘ + O</code>: 快速搜索class</p>

<p><code>⌘ + ⇧ + O</code>: 快速搜索file</p>

<p><code>⌘ + ⇧ + F</code>: 全局搜索</p>

<p><code>⌘ + ⇧ + R</code>: 全局替换</p>

<p><code>⌘ + +或-</code>: 展开或者收起代码块</p>

<p><code>⌘ + /</code>: 注释 //</p>

<p><code>⌘ + ⌥ + /</code>: 注释 /**/</p>

<p><code>⌥ + ⏎</code>: 提示错误解决方法</p>

<p>可能会有人觉得为啥重命名<code>⇧ + F6</code>没反应呢？跟 F1 ~ F12 有关的都没反应&hellip;</p>

<p>因为Mac系统默认没有启用它们&hellip;在系统设置，键盘选项里选中就可以了。</p>

<p><img src="http://andyfightting.github.io/myimg/android/keyf.png" alt="img" /></p>

<p>当然可以设置自己喜欢的快捷键，我自己把运行和调试改成了<code>⌘ + R</code>和<code>⌘ + D</code></p>

<p><img src="http://andyfightting.github.io/myimg/android/keymap.png" alt="img" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 基础知识]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/21/androidBase0/"/>
    <updated>2015-11-21T09:26:15+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/21/androidBase0</id>
    <content type="html"><![CDATA[<h3>* Activity启动模式</h3>

<p>在AndroidMainfest.xml里的activity里设置android:launchMode = “xxx”</p>

<p><strong>standard:</strong> 默认模式，每次都会创建一个新的放在栈顶，即使栈里已经有了</p>

<p><strong>singleTop:</strong> 已经在<strong>栈顶</strong>了就不创建，否则还是会创建，即使栈里已经有了</p>

<p><strong>singleTask:</strong> 在活动栈中有了就不创建，直接推到栈顶，<strong>在它之前的全部会被挤出栈</strong>，若活动栈中没有就创建</p>

<p><strong>singleInstance:</strong> 会创建一个<strong>新的活动栈</strong>把自己放进去</p>

<h3>* 随时随地退出程序</h3>

<p>在任何页面都可以被踢下线的实现技巧</p>

<p>创建一个收集Activity的管理类，在BaseActivity的<code>onCreate()</code>方法中添加<code>ActivityManager.addActivity(this)</code>,在<code>onDestroy</code>方法中添加<code>ActivityManager.removeActivity(this)</code>。然后在任何要强退的地方调用<code>ActivityManager.finishAllActivity()</code>。<!--more--></p>

<pre><code>public class ActivityManager {

public static List&lt;Activity&gt; activityList = new ArrayList&lt;&gt;();

public static void addActivity(Activity activity){
    activityList.add(activity);
  }

public static void removeActivity(Activity activity){
    activityList.remove(activity);
  }

public static void finishAllActivity(){
    for (Activity activity : activityList){
        if (!activity.isFinishing()){
            activity.finish();
        }
    }
    activityList.clear();
  }
}
</code></pre>

<h3>* Activity跳转</h3>

<p>一般我们是用如下的方式跳转，需要知道下一个Activity要用哪些参数，多人开发可能有些不便。</p>

<pre><code>Intent intent = new Intent(OneActivity.thi,TwoActivity.class);
intent.putExtra("key","value");
startActivity(intent);
</code></pre>

<p>可以在下一个Activity中把需要的参数暴露出来。</p>

<pre><code>public static void actionStart(Activity activity,String param){
  Intent intent = new Intent(activity,TwoActivity.class);
  intent.putExtra("key","param");
  activity.startActivity(intent);
  activity.finish();
}
</code></pre>

<h3>* ListView的正确使用方式</h3>

<p>实现了item的复用，这样效率最好，ArrayAdapter源码中就是这样弄的。ArrayAdapter把BaseAdapter包装了一遍，实现了<code>getCount</code>,<code>getItem</code>,<code>getItemId</code>，所以这些我们就可以不用再写了，只重写个<code>getView</code>就可以。</p>

<pre><code>public class UserAdapter extends ArrayAdapter&lt;User&gt; {

private int layoutId;
public UserAdapter(Context context, int resourceId, List&lt;User&gt; objects){
      super(context,resourceId,objects);
      layoutId = resourceId;
}

@Override
public View getView(int position, View convertView, ViewGroup parent){

    User user = getItem(position);
    ViewHolder viewHolder;
    View layoutView;

    if (convertView == null){
        layoutView = LayoutInflater.from(getContext()).inflate(layoutId,null);
        viewHolder = new ViewHolder();
        viewHolder.headImage = (ImageView)layoutView.findViewById(R.id.head_img);
        viewHolder.nameTv = (TextView)layoutView.findViewById(R.id.name_tv);
        layoutView.setTag(viewHolder);
    }else {
       layoutView = convertView;
       viewHolder = (ViewHolder)layoutView.getTag();
    }
    //--------在下面赋值 ----------------
    viewHolder.headImage.setImageResource(user.getHeadImgId());
    viewHolder.nameTv.setText(user.getName());

    return layoutView;
}

class ViewHolder{
    ImageView headImage;
    TextView nameTv;
  }
}
</code></pre>

<h3>* px,dpi,dp,density</h3>

<p>Android规定：如果手机一英寸长度上有160个px，那么手机的dpi就是160,此时1dp==1px，即density=1。所以如果一英寸长度上有320个px的话，那么手机的dpi就是320，此时1dp==2px,即density=2。</p>

<p>结论：即相同大小的手机上的dp个数是不变的，如果相同大小的手机像素不同的话，只会影响dip和density的值,所以我们适配手机的时候用的长度单位要用 &mdash;- <code>dp</code></p>

<pre><code>public static int getScreenWidthPx(Context context){
    return  context.getResources().getDisplayMetrics().widthPixels;
}

public static int getScreenHeightPx(Context context){
    return  context.getResources().getDisplayMetrics().heightPixels;
}

public static float getXdpi(Context context){
    return  context.getResources().getDisplayMetrics().xdpi;
}

public static float getYdpi(Context context){
    return  context.getResources().getDisplayMetrics().ydpi;
}

public static float getDensity(Context context){
   return context.getResources().getDisplayMetrics().density;
}
</code></pre>

<h3>* 9-patch图片</h3>

<p>1，在<code>上</code>边绘制的<code>垂直区域</code>会被<code>水平拉伸</code>，在<code>左</code>边绘制的<code>横向区域</code>会被<code>垂直拉伸</code>。</p>

<p>2，在<code>下</code>边和<code>右</code>边绘制的<code>交叉区域</code>是内容放置的区域。</p>

<p><img src="http://andyfightting.github.io/myimg/android/9patch.jpg" alt="img" /></p>

<h3>* Fragment</h3>

<p>在fragment里可以用<code>getActivity()</code>得到与之关联的Activity。<code>FragmentTransaction</code>的实例可以调用<code>addToBackStack(null)</code>方法把这个事务添加到返回栈中，这样点击返回就是回到事务处理之前的状态,而不是退出Activity。fragment之间的通信可以通过与之共同关联的Activity来转达。</p>

<p>fragment的生命周期与Activity类似，只不过比Activity多了<code>onAttach()</code>,<code>onCreateView()</code>,<code>onActivityCreated()</code>,<code>onDestroyView()</code>,<code>onDetach()</code>。</p>

<p>由生到死依次是：<code>onAttach()</code>, <code>onCreate()</code>,<code>onCreateView()</code>,<code>onActivityCreated()</code>,<code>onStart()</code>,<code>onResume()</code>,<code>onPause()</code>,<code>onStop()</code>,<code>onDestroyView()</code>,<code>onDestroy()</code>,<code>onDetach()</code>。</p>

<p>从返回栈回来后执行的第一个方法是<code>onActivityCreated()</code>,而Activity的轮回后执行的第一个方法是<code>onRestart()</code>,然后再<code>onStart()</code>,<code>onResume()</code>。</p>

<p>同一个Activity怎样让它在不同大小的设备自动加载不同的布局文件呢？用<code>限定符</code>,即在<code>res</code>下建<code>layout-large</code>文件夹或者不同限定符的文件夹，在里面放<code>同名</code>的布局文件。限定符有：<code>small</code>,<code>normal</code>,<code>large</code>,<code>xlarge</code>以及分辨率限定符：<code>ldpi</code>:120dpi以下，<code>mdpi</code>:120-160dpi，<code>hdpi</code>:160-240dpi,<code>xhdpi</code>:240-320dpi，以及方向限定符：<code>land</code>:横屏,<code>port</code>:竖屏。</p>

<p>还有个问题，<code>large</code>，大，到底多大算大呢？可以自己定义这个边界值。如<code>layout-sm600</code>,就是<code>宽度</code>大于600<code>dp</code>的设备叫大，否则叫小。<code>sm</code>的意思是：<code>smallest width</code>。</p>

<h3>* Broadcast 广播</h3>

<p>见名知意，即发一下消息，很多地方都可以收到。广播有两种：异步执行的广播 和 按顺序执行的同步广播。异步广播接收没有先后之分，可看做同时收到，这种广播发出之后不可被拦截。同步广播是按顺序一个一个执行，可以设置接收的优先级(设置<code>IntentFilter</code>的<code>priority</code>值,越大越优先)，这种广播可以被拦截(在<code>onReceive()</code>方法里调用<code>abortBroadcast()</code>废掉这条广播)。</p>

<p>注册接收广播有两种方式：一种是用代码注册，也叫动态注册，动态注册(在<code>onCreate()</code>里调用Activity的方法<code>registerReceiver()</code>)的广播接收一定要在<code>onDestroy</code>中移除注册(调用Activity的<code>unregisterReceiver()</code>)。另一种叫静态注册，是在xml中配置的，这种注册不用移除。</p>

<p>怎么写广播接收器？写个类继承<code>BroadcastReceiver</code>,它是个抽象类，然后重写<code>onReceive()</code>即可，可以通过<code>intent.getAction()</code>来区分不同广播，<strong>在<code>onReceive()</code>方法中不能开启线程</strong>。下面是一个监听网络变化的广播接收器。</p>

<pre><code>class NetWorkChangeReceiver extends BroadcastReceiver{
    @Override
    public void onReceive(Context context,Intent intent){
        ConnectivityManager connectivityManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
        if (networkInfo != null &amp;&amp; networkInfo.isAvailable()){
            Toast.makeText(context,"网络可用",Toast.LENGTH_SHORT).show();
        }else {
            Toast.makeText(context,"网络不可用",Toast.LENGTH_SHORT).show();
        }
    }
}
</code></pre>

<p>用Activity里的方法发送异步广播<code>sendBroadcaset(intent)</code>,和发送同步广播<code>sendOrderedBroadCaset(intent,null)</code>。这样发送的广播都是<code>跨应用</code>的，即A应用发出的广播，B应用也可以收到的！应为这些都是全局广播。</p>

<p>本地广播，即发出的广播只会被<code>本身应用</code>接收到,手机里的其他应用就收不到了。本地广播要用<code>LocalBroadcastManager</code>这个类来管理，即注册和移除的时候不能用<code>Activity</code>的<code>registerReceiver()</code>和<code>unregisterReceiver()</code>方法，而应该用<code>LocalBroadcastManager</code>实例的<code>registerReceiver()</code>和<code>unregisterReceiver()</code>方法，简单吧！<strong>本地广播不会被静态注册的接收器收到！</strong>要接收本地广播，接收器都得用动态注册的方式。</p>

<h3>* ContentProvider / ContentResolver</h3>

<p>这个是用于在手机中<code>不同应用程序</code>间的数据传递，可以自己选择那些数据可暴露出来给其他应用获取。有些系统的应用程序已经提供这样的接口了，可以直接通过这种方式获取数据，如 短信应用，通讯录应用等，而我们自己写的应用程序则要自己写这个数据提供接口。</p>

<p>获取数据通过<code>ContentResolver</code>类，可以通过Context 的 <code>getContentResolver()</code>得到实例，然后数据处理就是 <code>insert()</code>,<code>update()</code>,<code>delete()</code>,<code>quert()</code>,和<code>SQLiteDatabase</code>很像，但不是传<code>表名</code>而是传<code>Uri</code>。</p>

<p>提供数据，要继承抽象类<code>ContentProvider</code>然后重写里面的六个方法：<code>onCreate()</code>,<code>quert()</code>,<code>insert()</code>,<code>update()</code>,<code>delete()</code>,<code>getType()</code>。</p>

<h3>* NotificationManager</h3>

<p>Notification 在手机顶部提示用户的通知，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress搭建个人博客]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/14/jiaocheng/"/>
    <updated>2015-11-14T11:21:39+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/14/jiaocheng</id>
    <content type="html"><![CDATA[<p>本人的博客刚刚搭建好，并绑定了个人域名(<a href="http://guimingsu.com">guimingsu.com</a>)，现将该过程记录下来。</p>

<p><a href="https://pages.github.com/">Github Pages</a>是Github提供的一个免费空间，相当于我们博客的免费托管服务器，我们写的博客就是放这上面的。它可以拥有一个独立的二级域名如xxx.github.io(如果有自己的个人域名，可以用自己的个人域名指向它)，允许开发者提交静态网页文件，用于介绍自己，或者自己的开源项目，可以看作是个人或项目主页。</p>

<p><a href="http://octopress.org/">Octopress</a>“A blogging framework for hackers”，即像写代码似的写博客。一个博客网页生成框架，我们按照它要求的格式写博客内容，然后敲命令<code>rake generate</code>,<code>rake deploy</code>,就可以把网页放到Github服务器上，然后我们就可以看到了啊，它就是一个写博客的工具可以这样理解。</p>

<p>个人域名，这个要自己买了，可以上<a href="http://wanwang.aliyun.com/">阿里云</a>上买，一年几十块，配置后面再讲。在注册阿里云的时候我用的QQ邮箱，就是收不到邮件，换成Gmail就收到了。不知道是我网络问题还是大公司间的任性撕逼，如果你也收不到邮件就换个邮箱注册吧。<!--more--></p>

<ul>
<li><p>在<a href="https://github.com">Github</a>上New repository, 名字为<code>yourNmae.github.io</code>确定提交，这里报错是因为我已经建好了。
<img src="http://andyfightting.github.io/myimg/other/creat_rep.png" alt="creat_rep" />
之后会生成一个HTTPS连接如 <a href="https://github.com/yourName/yourName.github.io.git">https://github.com/yourName/yourName.github.io.git</a> ,这个连接在之后的Octopress绑定配置中要用。</p></li>
<li><p><a href="http://octopress.org/docs/setup/">Octopress</a>这个步骤比较多一点, 我用的系统是 OS X10.10.5。Octopress要用到ruby环境，且ruby版本要大于等于<code>1.9.3</code>。可以用<code>ruby -v</code>命令看一下ruby版本，我的是版本是<code>2.0.0p643</code>, 没有的话可以看<a href="https://ruby-china.org/wiki/install_ruby_guide">这里</a>安装ruby环境。</p></li>
</ul>


<p>环境装好后从网上下载Octopress框架到本地电脑上，这里我保存到octopress文件夹且放在桌面上</p>

<p>下载： <code>git clone git://github.com/imathis/octopress.git /Users/suguiming/Desktop/octopress</code></p>

<p>然后进入该文件夹：<code>cd  /Users/suguiming/Desktop/octopress</code></p>

<p>然后：  <code>gem install bundler</code></p>

<p>这里可能会报错，说缺少xxx依赖包，可以用<code>gem dependency</code>查看要依赖的包，然后把包都装上再敲上面的命令</p>

<p>然后： <code>bundle install</code></p>

<p>再然后：  <code>rake install</code></p>

<p>这里Octopress就下载安装好了，之后要进行关联配置,把Octopress和Github关联起来，我们就可以把博客放到之前建的Github项目<code>yourNmae.github.io</code>里了。</p>

<p>但关联前还有一个步骤就是SSH key处理。新建一个命令窗口<code>cd ~/.ssh</code>进入目录，<code>ls -a</code>查看内容，这时候一般没有<code>id_rsa</code>及<code>id_rsa.pub</code>这两个文件的，我们现在要创建这两个文件。<code>ssh-keygen -t rsa -C "Github登录账号邮箱@qq.com"</code>,然后按回车回车再回车就生成那两个文件了。然后把<code>id_rsa.pub</code>里的东西全选复制，在<a href="https://github.com/settings/ssh">这里</a>添加一个SSH key即可。</p>

<p>回到octopress的命令窗口，输入命令<code>rake setup_github_pages</code> 此时要求输入Github项目<code>yourNmae.github.io</code>的地址，即前面得到的<code>https://github.com/yourName/yourName.github.io.git</code>,也可在Github中项目里的右下角的HTTPS链接复制过来然后</p>

<pre><code>rake generate
rake deploy
git add .
git commit -m 'say something'
git push origin source
</code></pre>

<ul>
<li>写博客，<code>rake new_post["file name"]</code>新建一个写博客的文件，它会在<code>/source/_posts</code>文件夹里生成,打开它在里面写博客内容就可以了。它是用markdown的方式写，可以在<a href="http://wowubuntu.com/markdown/">这里</a>和<a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">这里</a>查看markdown的使用规则，常用的就那几个，熟悉就可以了,大概长这样。推荐使用<a href="http://mouapp.com/">Mou</a>来编写markdown文件，<a href="https://maxiang.io/">马克飞象</a>这个在线编写工具也很好。
  <img src="http://andyfightting.github.io/myimg/other/write_blog.png" alt="write_blog" />
  写好后保存，<code>rake generate</code>生成博客，<code>rake preview</code>预览博客，在地址栏输入<code>http://localhost:4000/</code>查看，退出预览<code>control+C</code></li>
</ul>


<p>然后提交，之后在地址栏输入<code>yourName.github.io</code>就可以查看了</p>

<pre><code>rake deploy
git add .
git commit -m 'say something'
git push origin source
</code></pre>

<ul>
<li><p>域名绑定，在<code>yourName.github.io</code>项目里新建一个文件，文件名必须是大写的<code>CNAME</code>,内容是你购买的域名如我的域名<code>guimingsu.com</code>,前面不要加www或http,参考<a href="https://help.github.com/articles/adding-a-cname-file-to-your-repository/">这里</a>,然后<code>git pull</code>把刚才建的文件同步到本地。
然后在域名购买的服务商那里设置，我用的是<a href="http://www.aliyun.com/">阿里云</a>。登录账号，在控制管理，域名解析中添加域名指向,把图中的<code>andyfightting.github.io</code>换成你自己的，其他的不变,这样域名就配置好了
<img src="http://andyfightting.github.io/myimg/other/yuming.png" alt="img" />
参考<a href="https://help.github.com/articles/my-custom-domain-isn-t-working/">这里</a>
<img src="http://andyfightting.github.io/myimg/other/dns_error.png" alt="img" /></p></li>
<li><p>其他个性化配置，如在浏览器显示的icon替换，在source文件夹里面有个文件叫favicon.png，做一个16*16图片替换进去提交，可能不会立即有反应。还有博客的评论系统是用的第三方<a href="https://disqus.com">disqus</a>。在该网站上注册一个账号，然后把账号名填写在<code>/octopress/_config.yml</code>文件中对应的地方，把false改成true。</p></li>
</ul>


<p><img src="http://andyfightting.github.io/myimg/other/discus.png" alt="img" /></p>

<p>由于访问国外disqus比较慢，我又把评论部分改用国内的<a href="http://duoshuo.com/">多说</a>了，使用方法都类似的，具体配置请看<a href="http://www.tuicool.com/articles/VbqYNjn">这里</a>,里面还说了性能优化可以跟着改改，提高网页的响应速度。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Octopress]]></title>
    <link href="http://andyfightting.github.io/blog/2015/11/13/my-octopress/"/>
    <updated>2015-11-13T21:03:44+08:00</updated>
    <id>http://andyfightting.github.io/blog/2015/11/13/my-octopress</id>
    <content type="html"><![CDATA[<p>Hello World !!
<img src="http://andyfightting.github.io/myimg/other/octopress.png" alt="img" /></p>
]]></content>
  </entry>
  
</feed>
