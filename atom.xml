<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[阿贵]]></title>
  <link href="http://andyfightting.github.io/atom.xml" rel="self"/>
  <link href="http://andyfightting.github.io/"/>
  <updated>2016-12-13T12:44:46+08:00</updated>
  <id>http://andyfightting.github.io/</id>
  <author>
    <name><![CDATA[guimingsu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[排序算法]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/10/suan-fa/"/>
    <updated>2016-12-10T14:25:43+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/10/suan-fa</id>
    <content type="html"><![CDATA[<h5>1.冒泡排序</h5>

<p>比如要升序排序，原理是从第一位开始，把它依次和后面的每一位数字进行两两比较,如果低位的比高位的大就交换，然后用较大的数字继续和后面比较交换。这样一趟比较过去后,最大的数字被交换到了最后一位。然后再从头开始以此类推,直到倒数第二位和最后一位比较交换完时结束。</p>

<pre><code>void ascSort(int array[], int size){
    int i, j, temp;
    for (j = 0; j &lt; size - 1; j++) //比较的趟数
        for (i = 0; i &lt; size - 1 - j; i++){ //每趟要比较的次数
            if(array[i] &gt; array[i + 1]){
                temp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = temp;
            }
        }
}
</code></pre>

<p>时间复杂度，一个算法花费的时间与算法中语句的执行次数成正比，算法中语句执行次数多，它花费时间就多。算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p>

<p>在冒泡排序中，最坏情况下 T(n) = n * (n - 1) / 2 = (n<sup>2</sup> - n) / 2。如果 n = 10000，那么 (n<sup>2</sup> - n) / 2 = (100000000 - 10000) / 2, 相对10<sup>8</sup>来说，10000可以忽略不计了。所以总计算次数约为 0.5 * n<sup>2</sup>。 忽略前面的倍数， 所以冒泡排序的时间复杂度是  O(n<sup>2</sup>) 。</p>

<p>算法的稳定性是指，如果有两个相等的数 Ai = Aj， 在排序前 Ai 在 Aj 前面，排序后 Ai 还是在 Aj 前面，即两个相等的数不会交换位置。排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</p>

<p>例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] >= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。</p>

<h5>2.鸡尾酒排序</h5>

<p>鸡尾酒排序也叫来回排序，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素，他可以得到比冒泡排序稍微好一点的效率。</p>

<p>原理是先找到最小的数字，把他放到第一位，然后找到最大的数字放到最后一位。然后再找到第二小的数字放到第二位，再找到第二大的数字放到倒数第二位。以此类推，直到完成排序。</p>

<pre><code>void ascSort(int array[], int size){
    //初始化查询边界
    int left = 0;
    int right = size - 1;
    int tmp;

    while (left &lt; right) {
        for (int i=left; i&lt;right; i++) { //最大值放右边
            if (array[i] &gt; array[i+1]) {
                tmp = array[i];
                array[i] = array[i + 1];
                array[i + 1] = tmp;
            }
        }
        right--;

        for (int i=right; i&gt;left; i--) {//最小值放左边
            if (array[i-1] &gt; array[i]) {
                tmp = array[i-1];
                array[i-1] = array[i];
                array[i] = tmp;
            }
        }
        left++;
    }
}
</code></pre>

<h5>3.选择排序</h5>

<p>每次从剩余序列中选出最小的数放在剩余序列的第一个位置。如从10个数中选出最小的和 array[0] 交换，那 array[0] 就是最小的了。再从剩下的 array[1] 到 array[9] 中选出最小的和 array[1] 交换，依次类推。</p>

<pre><code>void ascSort(int array[], int size){
    int i,j,k,t;
    for (i=0; i&lt;size-1; i++) {
        k=i;
        for (j=i+1; j&lt;size; j++){//从剩余数组中找出最小数的位置放k里
            if (array[j] &lt; array[k]){
                 k = j;
            }
        }

        t = array[k];
        array[k] = array[i];
        array[i] = t;
    }
}
</code></pre>

<p>时间复杂度也是  O(n<sup>2</sup>) 。</p>

<h5>4.插入排序</h5>

<p>插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌。对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。
<img src="http://andyfightting.github.io/myimg/java/charu.png" width="300" alt="" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>从第一个元素开始，该元素可以认为已经被排序
</span><span class='line'>取出下一个元素，在已经排序的元素序列中从后向前扫描
</span><span class='line'>如果该元素（已排序）大于新元素，将该元素移到下一位置
</span><span class='line'>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
</span><span class='line'>将新元素插入到该位置后
</span><span class='line'>重复步骤2~5</span></code></pre></td></tr></table></div></figure>


<pre><code>void ascSort(int array[], int size){
    int j,tmp;
    for (int i = 1; i &lt; size; i++) { //把array[0]当做已排序好的，从array[1]到array[size-1]是将要一个一个拿来插入的
        tmp = array[i]; //要被插入的数
        j = i - 1; //j是已经排好的数组的最后一位数的位置，第一次即为 index 0

        while (j &gt;=0 &amp;&amp; array[j] &gt; tmp) {
            array[j+1] = array[j]; //后移
            j--;
        }

        array[j+1] = tmp;//直到遇到比要插入的数小，然后把要插入的数插到它右边
    }
}
</code></pre>

<h5>5.希尔排序</h5>

<p>希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本，因为插入排序每次只能将数据移动一位。而该方法实质上是一种分组插入方法，算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。一般的初次取序列的一半为增量，以后每次减半，直到增量为1。
<img src="http://andyfightting.github.io/myimg/java/xier.jpg" width="400" alt="" /></p>

<pre><code>void ascSort(int array[], int size){
    int h = size/2; //初始增量为一半
    int i,j,tmp;

    while (h &gt;= 1) {
        for (i = h; i &lt; size; i++) {
            //下面是跨度为h的插入排序，
            tmp = array[i];
            j = i - h;
            while (j &gt;= 0 &amp;&amp; array[j] &gt; tmp){
                array[j + h] = array[j];
                j = j - h;
            }
            array[j + h] = tmp;
        }
        h = h/2; //增量每次减半
    }
}
</code></pre>

<h5>6.堆排序</h5>

<p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构,并同时满足堆的性质：父节点总是小于等于它的子节点。(父节点或大于等于子节点，这里就举例小于等于的)。当父结点总是小于或等于任何一个子节点时称为小根堆，反之为大根堆。</p>

<p>可以用一维数组来表示堆，节点 i 的父节点是 (i – 1) / 2。 i 的左右子结点下标分别为2 * i + 1和2 * i + 2, 如第0个结点左右子结点下标分别为1和2。
<img src="http://andyfightting.github.io/myimg/java/dui.png" width="500" alt="" /></p>

<pre><code>1.根据数组初始化一个大根堆
2.把堆顶元素和堆尾元素交换
3.把堆的尺寸减一，然后调整堆使剩下的堆继续满足大根堆
4.重复2、3，直到堆的尺寸为1
</code></pre>

<p>如 int array[] = {16,7,3,20,17,8}; 可以看成以下的完全二叉树：
<img src="http://andyfightting.github.io/myimg/java/shu0.png" width="300" alt="" /></p>

<p>然后从最后一个非叶子节点开始调整，比较自己和左节点，右节点谁最大，最大的调为父节点。经过 3-8，7-20-17，16-20-8，16-7-17 四次调整后最后就是一个大根堆了，每个父节点都比子节点大！</p>

<p><img src="http://andyfightting.github.io/myimg/java/shu1.png" width="500" alt="" /></p>

<p>即每次调整都是从父节点、左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换，交换之后可能造成被交换的孩子节点不满足堆的性质，因此每次交换之后要重新对被交换的孩子节点进行调整。初始化好大根堆后就可以进行排序了。</p>

<p>第一轮，把20和最后的3交换，再调整后如下：</p>

<p><img src="http://andyfightting.github.io/myimg/java/shu2.png" width="400" alt="" /></p>

<p>再把17和3交换，调整后如下：</p>

<p><img src="http://andyfightting.github.io/myimg/java/shu3.png" width="400" alt="" /></p>

<p>再把16和3交换调整后如下：</p>

<p><img src="http://andyfightting.github.io/myimg/java/shu4.png" width="300" alt="" /></p>

<p>然后8和3交换调整：</p>

<p><img src="http://andyfightting.github.io/myimg/java/shu5.png" width="300" alt="" /></p>

<p>最后7和3交换，完成。</p>

<p><img src="http://andyfightting.github.io/myimg/java/shu6.png" width="250" alt="" /></p>

<pre><code>int heapsize;
void ascSort(int array[], int size){
    buildHeap(array, size);
    for (int i = size - 1; i &gt;= 1; i--){
        exchange(array, 0, i);       // 将堆顶元素最大值与堆的最后一个元素互换
        heapsize--;                  // 从堆中去掉最后一个元素
        heapModify(array, 0);        // 从新的堆顶元素开始进行堆调整
    }
}

void buildHeap(int array[], int size){
    heapsize = size;
    for (int i = heapsize/2 - 1; i &gt;= 0; i--){ // 对每一个非叶结点 不断的堆调整
        heapModify(array, i);
    }
}

void heapModify(int array[], int i){    // 堆调整函数,这里使用的是大根堆
    int leftchild = 2 * i + 1;          // 左孩子索引
    int rightchild = 2 * i + 2;         // 右孩子索引
    int largest;                        // 选出当前结点与左右孩子之中的最大值

    if (leftchild &lt; heapsize &amp;&amp; array[leftchild] &gt; array[i]){
        largest = leftchild;
    }else{
        largest = i;
    }

    if (rightchild &lt; heapsize &amp;&amp; array[rightchild] &gt; array[largest]){
        largest = rightchild;
    }

    if (largest != i){
        exchange(array, i, largest);     // 把当前结点和它的最大直接子节点进行交换
        heapModify(array, largest);      // 递归调用，继续从当前结点向下进行堆调整
    }
}

void exchange(int array[], int i, int j){   // 交换array[i]和array[j]
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}
</code></pre>

<h5>7.归并排序</h5>

<p>归并操作指的是将两个已经排序的序列合并成一个有序序列的操作，即只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</p>

<pre><code>void mergeArray(int arrayA[], int sizeA, int arrayB[], int sizeB, int resultArray[]){
    int indexA =0;
    int indexB =0;
    int indexResult =0;

    while (indexA &lt; sizeA &amp;&amp; indexB &lt; sizeB){
        if (arrayA[indexA] &lt; arrayB[indexB]){
            resultArray[indexResult] = arrayA[indexA];
            indexResult++;
            indexA++;
        }else{
            resultArray[indexResult] = arrayB[indexB];
            indexResult++;
            indexB++;
        }
    }

    while (indexA &lt; sizeA){
       resultArray[indexResult] = arrayA[indexA];
        indexResult++;
        indexA++;
    }

    while (indexB &lt; sizeB){
       resultArray[indexResult] = arrayB[indexB];
        indexResult++;
        indexB++;
    }
}
</code></pre>

<p>归并的基本思路是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？可以将A，B组各自再分成二组，依次类推。当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。
<img src="http://andyfightting.github.io/myimg/java/dg0.png" width="600" alt="" /></p>

<pre><code>void ascSort(int array[], int size){
    int *temp = malloc(size * sizeof(int));
    recursionArray(array, temp, 0, size - 1);
    free(temp);
}

void recursionArray(int array[], int temp[], int low, int high){
    if (low &lt; high){
        int middle = (low + high) / 2;
        recursionArray(array, temp, low, middle);   //左边有序
        recursionArray(array, temp, middle + 1, high); //右边有序
        mergeArray(array, temp, low,middle,high);  //再把两个有序的合并
    }
}

//将有二个有序数列 array[low...middle]和 array[middle...high]合并
void mergeArray(int array[], int temp[], int low, int middle, int high){
    int i = low;
    int j = middle + 1;
    int k = low;

    while (i &lt;= middle &amp;&amp; j &lt;= high){
        if (array[i] &lt;= array[j]){
            temp[k++] = array[i++];
        }
        else{
            temp[k++] = array[j++];
        }
    }

    while (i &lt;= middle){
        temp[k++] = array[i++];
    }

    while (j &lt;= high){
        temp[k++] = array[j++];
    }

    for (int k = low; k &lt;= high; k++){
        array[k] = temp[k];
    }
}
</code></pre>

<h5>8.快速排序</h5>

<p>快速排序也是用分治法来实现的，即先分解分解再分解，然后逐个击破，最后挨个合并。其基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>先从数列中取出一个数作为基准数。
</span><span class='line'>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
</span><span class='line'>再对左右区间重复第二步，直到各区间只有一个数。</span></code></pre></td></tr></table></div></figure>


<pre><code>void ascSort(int array[], int left, int right){
    if (left &lt; right){
        int i = left, j = right, x = array[left];
        while (i &lt; j){
            while(i &lt; j &amp;&amp; array[j] &gt;= x) // 从右向左找第一个小于x的数
                j--;
            if(i &lt; j)
                array[i++] = array[j];

            while(i &lt; j &amp;&amp; array[i] &lt; x) // 从左向右找第一个大于等于x的数
                i++;
            if(i &lt; j)
                array[j--] = array[i];
        }
        array[i] = x;
        ascSort(array, left, i - 1); // 递归调用
        ascSort(array, i + 1, right);
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Protocol Buffer]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/09/google-protocol-buffer/"/>
    <updated>2016-12-09T09:54:35+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/09/google-protocol-buffer</id>
    <content type="html"><![CDATA[<p><a href="https://developers.google.com/protocol-buffers/">Google Protocol Buffer</a>是一种轻便高效的结构化数据存储格式，它很适合用于网络传输、数据存储等领域的与语言无关、平台无关、可扩展的序列化结构数据格式。google 提供了多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 XML、JSON 进行数据交换快许多也小许多。</p>

<p>首先需要安装编译器，在<a href="https://github.com/google/protobuf/releases">这里</a>选择一种语言下载，我下载的是<code>protobuf-java-3.0.0.zip</code>。</p>

<pre><code>//安装步骤
1.解压后 cd 进入文件夹
2.终端输入 ./configure (如果不是管理员身份，需要输入：./configure --prefix=$INSTALL_DIR 后面表示你要把protobuf安装的路径，需要是绝对路径)
3.输入 make 
4.输入 make check 
5.输入 make install 
</code></pre>

<p>每个过程时间都挺长的，然后输入<code>protoc -- version</code>验证是否安装成功！
<img src="http://andyfightting.github.io/myimg/java/proto0.png" width="600" alt="" /></p>

<p>下面就可以开始写例子了.新建一个<code>addressbook.proto</code>文件，输入：</p>

<pre><code>syntax = "proto2";
package tutorial;

option java_package = "com.example.tutorial";
option java_outer_classname = "AddressBookProtos";

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}

message AddressBook {
  repeated Person person = 1;
}
</code></pre>

<p>终端 cd 进入文件所在的目录，运行<code>protoc -I=./ --java_out=./ ./addressbook.proto</code>，就会在文件夹里生成一个<code>AddressBookProtos.java</code>的文件。把文件放到Eclipse里，然后添加<a href="http://mavensearch.io/repo/com.google.protobuf/protobuf-java/3.0.0">jar包</a>。</p>

<p>然后创建一个用于写入的类：<code>AddPerson</code></p>

<pre><code>package com.example.tutorial;

import com.example.tutorial.AddressBookProtos.AddressBook;
import com.example.tutorial.AddressBookProtos.Person;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.PrintStream;

class AddPerson {
  // This function fills in a Person message based on user input.
  static Person PromptForAddress(BufferedReader stdin,
                                 PrintStream stdout) throws IOException {
    Person.Builder person = Person.newBuilder();

    stdout.print("Enter person ID: ");
    person.setId(Integer.valueOf(stdin.readLine()));

    stdout.print("Enter name: ");
    person.setName(stdin.readLine());

    stdout.print("Enter email address (blank for none): ");
    String email = stdin.readLine();
    if (email.length() &gt; 0) {
      person.setEmail(email);
    }

    while (true) {
      stdout.print("Enter a phone number (or leave blank to finish): ");
      String number = stdin.readLine();
      if (number.length() == 0) {
        break;
      }

      Person.PhoneNumber.Builder phoneNumber =
        Person.PhoneNumber.newBuilder().setNumber(number);

      stdout.print("Is this a mobile, home, or work phone? ");
      String type = stdin.readLine();
      if (type.equals("mobile")) {
        phoneNumber.setType(Person.PhoneType.MOBILE);
      } else if (type.equals("home")) {
        phoneNumber.setType(Person.PhoneType.HOME);
      } else if (type.equals("work")) {
        phoneNumber.setType(Person.PhoneType.WORK);
      } else {
        stdout.println("Unknown phone type.  Using default.");
      }

      person.addPhone(phoneNumber);
    }

    return person.build();
  }

  //   Main function:  Reads the entire address book from a file,
  //   adds one person based on user input, then writes it back out to the same file.
  public static void main(String[] args) throws Exception {
    if (args.length != 1) {
      System.err.println("Usage:  AddPerson ADDRESS_BOOK_FILE");
      System.exit(-1);
    }

    AddressBook.Builder addressBook = AddressBook.newBuilder();

    // Read the existing address book.
    try {
      addressBook.mergeFrom(new FileInputStream(args[0]));
    } catch (FileNotFoundException e) {
      System.out.println(args[0] + ": File not found.  Creating a new file.");
    }

    // Add an address.
    addressBook.addPerson(
      PromptForAddress(new BufferedReader(new InputStreamReader(System.in)),
                       System.out));

    // Write the new address book back to disk.
    FileOutputStream output = new FileOutputStream(args[0]);
    addressBook.build().writeTo(output);
    output.close();
  }
}
</code></pre>

<p>再创建一个用于读取的类：<code>ListPeople</code></p>

<pre><code>package com.example.tutorial;

import com.example.tutorial.AddressBookProtos.AddressBook;
import com.example.tutorial.AddressBookProtos.Person;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.PrintStream;

class ListPeople {
  // Iterates though all people in the AddressBook and prints info about them.
  static void Print(AddressBook addressBook) {
    for (Person person: addressBook.getPersonList()) {
      System.out.println("Person ID: " + person.getId());
      System.out.println("  Name: " + person.getName());
      if (person.hasEmail()) {
        System.out.println("  E-mail address: " + person.getEmail());
      }

      for (Person.PhoneNumber phoneNumber : person.getPhoneList()) {
        switch (phoneNumber.getType()) {
          case MOBILE:
            System.out.print("  Mobile phone #: ");
            break;
          case HOME:
            System.out.print("  Home phone #: ");
            break;
          case WORK:
            System.out.print("  Work phone #: ");
            break;
        }
        System.out.println(phoneNumber.getNumber());
      }
    }
  }

  // Main function:  Reads the entire address book from a file and prints all
  //   the information inside.
  public static void main(String[] args) throws Exception {
    if (args.length != 1) {
      System.err.println("Usage:  ListPeople ADDRESS_BOOK_FILE");
      System.exit(-1);
    }

    // Read the existing address book.
    AddressBook addressBook =
      AddressBook.parseFrom(new FileInputStream(args[0]));

    Print(addressBook);
  }
} 
</code></pre>

<p>然后在项目文件夹里放一个用于保存数据的空文件：<code>addressbook.txt</code>,再设置<code>Run Configurations</code></p>

<p><img src="http://andyfightting.github.io/myimg/java/pro0.png" alt="" /></p>

<p>运行<code>AddPerson</code>文件，从控制台输入：</p>

<p><img src="http://andyfightting.github.io/myimg/java/pro1.png" alt="" /></p>

<p>再运行<code>ListPeople</code>就可读取输出了：</p>

<p><img src="http://andyfightting.github.io/myimg/java/pro2.png" alt="" /></p>

<p>再想打开查看<code>`addressbook.txt</code>文件已经查看不了了，应为它的编码不是Unicode也不utf-8等，而是前面安装的编译器的编码。它的优势就是小，不浪费字节，所以快，还安全。例子运行起来了，语法规则再慢慢看吧~</p>

<p><a href="http://andyfightting.github.io/mysrc/java/ProtoBufferTest.zip">下载</a></p>

<p><a href="https://developers.google.com/protocol-buffers/docs/javatutorial">Tutorial</a></p>

<p><a href="http://www.surajnayak.com/2015/05/05/protocol-buffers-hour-1-generating-code-and-using-generated-class/">Blog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unicode、UTF-8编码起源]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/08/utf8/"/>
    <updated>2016-12-08T15:39:55+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/08/utf8</id>
    <content type="html"><![CDATA[<p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为字节。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为计算机。</p>

<p>开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上0×10(0x表示16进制), 终端就换行，遇上0×07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0×20以下的字节状态称为控制码。他们又把所有的空 格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉 很好，于是大家都把这个方案叫做 ANSI 的Ascii编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。
<img src="http://andyfightting.github.io/myimg/other/asc1.jpg" alt="" /></p>

<p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机 保存他们的文字，他们决定采用 127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128 到255这一页的字符集被称扩展字符集。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！
<img src="http://andyfightting.github.io/myimg/other/asc2.jpg" alt="" /></p>

<p>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气 地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7(16进制以0x开头)，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312“。GB2312 是对 ASCII 的中文扩展。
<img src="http://andyfightting.github.io/myimg/other/gbk1.png" alt="" /></p>

<p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字 符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS“（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处 理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣 们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……”</p>

<p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海 里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序 就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎 么办？ 真是计算机的巴比伦塔命题啊！</p>

<p>正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。</p>

<p>unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原 来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在 保存英文文本时会多浪费一倍的空间。</p>

<p>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符“！同时，也都是统一的”两个字节“，请注意”字符”和”字节”两个术语的不同，“字节”是一个8位的物理存贮单元，而“字符”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。</p>

<p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。</p>

<p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。</p>

<p>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！</p>

<p>这里就有两个的问题，一个是如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每 个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。</p>

<p>unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</p>

<p>UTF-8(8-bit Unicode Transformation Format)最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII 码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中 文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。</p>

<p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入"联通"两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。其实这是因为GB2312编码与UTF-8编码产生了编码冲撞的原因。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Unicode符号范围     |        UTF-8编码方式
</span><span class='line'> (十六进制)         |           （二进制）
</span><span class='line'>—————————————————————–——————————————————————————————————
</span><span class='line'>0000 0000 0000 007F | 0xxxxxxx
</span><span class='line'>0000 0080 0000 07FF | 110xxxxx 10xxxxxx
</span><span class='line'>0000 0800 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
</span><span class='line'>0001 0000 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
</span><span class='line'>... ...</span></code></pre></td></tr></table></div></figure>


<p>例如"汉"字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110110001001001，依次代替上面3字节模板<code>1110xxxx 10xxxxxx 10xxxxxx</code>中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF-8的编码。</p>

<p>而当你新建一个文本文件时，记事本的编码默认是ANSI, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，"联通"的GB内码是：</p>

<pre><code>c1 1100 0001
aa 1010 1010

cd 1100 1101
a8 1010 1000
</code></pre>

<p>注意到了吗？第一二个字节、第三四个字节的起始部分分别都是"110"和"10"，正好与UTF-8规则里的两字节模板是一致的，于是再次打开记事本时，记事本就误认为这是一个UTF-8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了"00001 101010"，再把各位对齐，补上前导的0，就得到了"0000 0000 0110 1010"，不好意思，这是unicode的006A，也就是小写的字母"j"，而之后的两字节用UTF-8解码之后是0368，这个字符什么也不是。</p>

<p>这就是只有"联通"两个字的文件没有办法在记事本里正常显示的原因。而如果你在"联通"之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个UTF-8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Node.js]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/03/node-js/"/>
    <updated>2016-12-03T10:24:36+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/03/node-js</id>
    <content type="html"><![CDATA[<p>Node.js 是运行在服务端的 JavaScript。Node.js 应用是由几部分组成的：</p>

<pre><code>1. 引入 require 模块：可以使用 require 指令来载入 Node.js 模块。
2. 创建服务器：服务器可以监听客户端的请求
3. 接收请求与响应请求: 可以使用浏览器或客户端发送 HTTP 请求，服务器接收请求后返回响应数据。
</code></pre>

<h4>Hello World</h4>

<p>创建一个test.js文件，里面输入如下内容。终端进入文件所在文件夹，执行<code>node test.js</code>,浏览器地址栏输入<code>http://127.0.0.1:8888/</code>就可以看到Hello World了。</p>

<pre><code>//引用http模块
var http = require('http');
http.createServer(function (request, response) {
    // 发送 HTTP 头部 
    // HTTP 状态值: 200 : OK
    // 内容类型: text/plain
    response.writeHead(200, {'Content-Type': 'text/plain'});
    // 发送响应数据 "Hello World"
    response.end('Hello World！\n');
}).listen(8888);
</code></pre>

<p><img src="http://andyfightting.github.io/myimg/react/nodeHello.png" width="400" alt="" /></p>

<h4>NPM</h4>

<p>npm 是js包管理工具，像 CocoaPods 似的可以下载被人编写的第三方包，也可以把自己写的包上传的npm服务器。</p>

<p><code>npm install 包名</code> 本地安装,将安装包放在 ./node_modules 下，如果没有 node_modules 文件夹，会在当前执行 npm 命令的目录下生成 node_modules 文件夹。然后就可以通过require(包名) 来引入本地安装的包。</p>

<p><code>npm install 包名字 -g</code> 全局安装，将安装包放在 /usr/local 下或者 node 的安装目录。</p>

<p><code>npm uninstall 包名</code> 卸载包</p>

<p><code>npm update 包名</code> 更新包</p>

<p><code>npm search 包名</code> 搜索包</p>

<h4>package.json</h4>

<p>package.json 用于表示需要安装的包的属性，如名字，版本，依赖等。package.json 文件是必不可少的。可通过<code>npm init</code>创建该文件。</p>

<pre><code>//Package.json 属性说明
name - 包名。
version - 包的版本号。
description - 包的描述。
homepage - 包的官网 url 。
author - 包的作者姓名。
contributors - 包的其他贡献者姓名。
dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。
repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。
main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require("express")。
keywords - 关键字
</code></pre>

<h4>回调函数</h4>

<p>Node.js 异步编程的直接体现就是回调。Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>

<pre><code>//顺序执行
var fs = require("fs");
var data = fs.readFileSync('input.txt');
console.log(data.toString());
console.log("程序执行结束!");

//异步回调
var fs = require("fs");
fs.readFile('input.txt', function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});
console.log("程序执行结束!");
</code></pre>

<h4>事件驱动</h4>

<p>Node.js 每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用并处理并发。基本上所有的事件机制都是用观察者模式实现。当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。
当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p>

<p><img src="http://andyfightting.github.io/myimg/react/reactevent.png" width="400" alt="" /></p>

<p>在 Node 应用程序中，执行异步操作将回调函数作为最后一个参数， 回调函数里接收错误的对象作为回调函数的第一个参数。</p>

<pre><code>//回调函数是readFile的最后一个参数，err是回调函数的第一个参数
var fs = require("fs");
fs.readFile('input.txt', function (err, data) {
   if (err){
      console.log(err.stack);
      return;
   }
   console.log(data.toString());
});
console.log("程序执行完毕");
</code></pre>

<p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。许多对象都会分发事件，如一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是基于 events.EventEmitter 的实例。</p>

<p>events 模块只提供了一个对象： events.EventEmitter(事件分发器)。EventEmitter 的核心就是事件触发与事件监听器功能的封装。
可以通过require(&ldquo;events&rdquo;);来访问该模块。EventEmitter 对象如果在实例化时发生错误，会触发 &lsquo;error&rsquo; 事件。当添加新的监听器时，'newListener' 事件会触发，当监听器被移除时，'removeListener' 事件被触发。EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>

<pre><code>var events = require('events'); 
var emitter = new events.EventEmitter(); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener1', arg1, arg2); 
}); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener2', arg1, arg2); 
}); 
emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); 

//打印出
//listener1 arg1 参数 arg2 参数
//listener2 arg1 参数 arg2 参数
</code></pre>

<h4>EventEmitter 方法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>addListener(eventName, listenerFun): 为指定事件添加一个监听器到监听器数组的尾部。
</span><span class='line'>on(eventName, listenerFun):为指定事件注册一个监听器，接受一个字符串 eventName 和一个回调函数。
</span><span class='line'>once(eventName, listenerFun): 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。
</span><span class='line'>removeListener(eventName, listenerFun):移除指定事件的某个监听器，监听器 必须是该事件已经注册过的监听器。
</span><span class='line'>removeAllListeners([eventName]):移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。
</span><span class='line'>setMaxListeners(n)：默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。
</span><span class='line'>listeners(eventName)：返回指定事件的监听器数组。
</span><span class='line'>emit(eventName, [arg1], [arg2], [...]):按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。
</span><span class='line'>listenerCount(emitter, eventName):类方法，返回指定事件的监听器数量。</span></code></pre></td></tr></table></div></figure>


<p>实例：</p>

<pre><code>var events = require('events');
var eventEmitter = new events.EventEmitter();

// 监听器1   
var listener1 = function listener1() {
   console.log('监听器 listener1 执行。');
}

// 监听器2       
var listener2 = function listener2() {
  console.log('监听器 listener2 执行。');
}

// 绑定 connection 事件，处理函数为 listener1 
eventEmitter.addListener('connection', listener1);

// 绑定 connection 事件，处理函数为 listener2
eventEmitter.on('connection', listener2);

var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');
console.log(eventListeners + " 个监听器监听连接事件。");

// 处理 connection 事件 
eventEmitter.emit('connection');

// 移除监绑定的 listener1 函数
eventEmitter.removeListener('connection', listener1);
console.log("listener1 不再受监听。");

// 触发连接事件
eventEmitter.emit('connection');

eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');
console.log(eventListeners + " 个监听器监听连接事件。");

console.log("程序执行完毕。");

//打印结果
//2 个监听器监听连接事件。
//监听器 listener1 执行。
//监听器 listener2 执行。
//listener1 不再受监听。
//监听器 listener2 执行。
//1 个监听器监听连接事件。
//程序执行完毕
</code></pre>

<h5>error 事件</h5>

<p>EventEmitter 定义了一个特殊的事件<code>error</code>，它包含了错误的语义，在遇到异常的时候通常会触发 error 事件。
当 error 被触发时，如果没有对应的监听器就会把它当作异常，退出程序并输出错误信息。
所以要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。</p>

<p>大多数时候不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，
只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>

<h4>Buffer 类</h4>

<p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理文件流时，必须使用到二进制数据。
所以在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。可以让 Node.js 处理二进制数据，
每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。
一个 Buffer 类似于一个整数数组，utf-8 是默认的编码方式。</p>

<pre><code>//写数据
buf.write(string, offset, length, encoding)；
string - 写入缓冲区的字符串。
offset - 缓冲区开始写入的索引值，默认为 0 。
length - 写入的字节数，默认为 buffer.length。
encoding - 使用的编码。默认为 'utf8' 。
返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。

//读数据
buf.toString(encoding, start, end)；
encoding - 使用的编码。默认为 'utf8' 。
start - 指定开始读取的索引位置，默认为 0。
end - 结束位置，默认为缓冲区的末尾。
返回值是用指定的编码返回字符串。
</code></pre>

<h5>常用方法</h5>

<pre><code>new Buffer(size)：配一个新的 size 大小单位为8位字节的 buffer。
new Buffer(buffer)：拷贝参数 buffer 的数据到 Buffer 实例。
new Buffer(str, encoding)分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 'utf8'。
buf.length: 返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。
buf.write(string[, offset[, length]][, encoding]):写入数据。
buf.toJSON()：将 Buffer 实例转换为 JSON 对象。
buf.equals(otherBuffer)：比较两个缓冲区是否相等。
buf.compare(otherBuffer):比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。
buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]):buffer 拷贝，源和目标可以相同。 
targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。
</code></pre>

<h4>Stream 流</h4>

<p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。
<strong>所有的 Stream 对象都是 EventEmitter 的实例</strong></p>

<pre><code>Stream 有四种流类型：
1. Readable - 可读操作。
2. Writable - 可写操作。
3. Duplex - 可读可写操作.
4. Transform - 操作被写入数据，然后读出结果。

所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：
data - 当有数据可读时触发。
end - 没有更多的数据可读时触发。
error - 在接收和写入过程中发生错误时触发。
finish - 所有数据已被写入到底层系统时触发。
</code></pre>

<p>读取文件例子：</p>

<pre><code>var fs = require("fs");
var data = '';

// 创建可读流
var readerStream = fs.createReadStream('input.txt');

// 设置编码为 utf8。
readerStream.setEncoding('UTF8');

// 处理流事件 --&gt; data, end, and error
readerStream.on('data', function(chunk) {
   data += chunk;
});

readerStream.on('end',function(){
   console.log(data);
});

readerStream.on('error', function(err){
   console.log(err.stack);
});

console.log("程序执行完毕");
</code></pre>

<h4>模块系统</h4>

<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。一个 Node.js 文件就是一个模块，这个文件可能是JavaScript、JSON 或者编译过的C/C++ 扩展等。
Node.js 提供了<code>exports</code> 和 <code>require</code> 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p>

<p>require方法中的文件查找策略：</p>

<p><img src="http://andyfightting.github.io/myimg/react/require.png" width="400" alt="" /></p>

<h4>函数</h4>

<p>在JavaScript中，一个函数可以作为另一个函数的参数。可以先定义一个函数变量，然后传递，也可以在传递参数的地方直接定义函数(不要名字的函数，匿名函数)。</p>

<pre><code>function say(word) {
  console.log(word);
}

function execute(someFunction, value) {
  someFunction(value);
}

execute(say, "Hello");

//也可以直接传递匿名函数

function execute(someFunction, value) {
  someFunction(value);
}

execute(function(word){ console.log(word) }, "Hello");
</code></pre>

<h4>全局对象</h4>

<p>JavaScript 中有一个特殊的对象，称为全局对象，它及其所有属性都可以在程序的任何地方访问，即全局变量。
在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。
在 Node.js 可以直接访问到 global 对象的属性，而不需要在应用中包含它。<strong>注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。</strong></p>

<pre><code>满足以下条 件的变量是全局变量：
1.在最外层定义的变量；
2.全局对象的属性；
3.隐式定义的变量（未定义直接赋值的变量）。
</code></pre>

<p><strong>__filename ：</strong>表示当前正在执行的文件名,输出文件的绝对路径。</p>

<p><strong>__dirname ：</strong>表示当前正在执行的文件目录。</p>

<p><strong>setTimeout(cb, ms) :</strong> 全局函数,在指定的毫秒(ms)数后执行指定函数(cb)。只执行一次指定函数。返回一个代表定时器的句柄值。</p>

<p><strong>clearTimeout(t) :</strong> 全局函数,用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。</p>

<p><strong>setInterval(cb, ms) :</strong>setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。
返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。
setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</p>

<p><strong>console :</strong> 全局对象，常用方法有<code>console.log()</code>,<code>console.info()</code>,<code>console.warn()</code>,<code>console.error()</code></p>

<p><strong>process :</strong>全局变量，即 global 对象的属性。便于我们更好的控制系统的交互,很多属性和方法。<code>process.stdout</code>,<code>process.exet()</code>&hellip;</p>

<p><a href="https://nodejs.org/dist/latest-v7.x/docs/api/">Node.js API</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 基础组件]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/02/react-base-view/"/>
    <updated>2016-12-02T09:12:24+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/02/react-base-view</id>
    <content type="html"><![CDATA[<p>这里主要记录看 <a href="https://github.com/facebook/react-native">React Native 官方例子</a> 的基础组件过程中，记录一些比较特殊或需要注意的地方。
<img src="http://andyfightting.github.io/myimg/react/view0.png" width="800" alt="" /></p>

<h4>View</h4>

<pre><code>//宽度自适应,需要在Text的父控件上设置alignSelf属性！
必须把文字放在&lt;Text&gt;组件内。不能直接在&lt;View&gt;下放置一段文字。
值为flex-start,center,flex-end都会自适应！而auto,stretch则不会！
&lt;View style=&gt;
    &lt;Text&gt;这里的文字会自适应宽度！&lt;/Text&gt;
&lt;/View&gt;

//背景色和圆角问题
当设置了背景色又设置了圆角时，需要设置 overflow: 'hidden' ，否则四个角会有背景色！前提是这个View里有子组件，
因为像css似的背景色会继承到子组件中！四个角显示的是子组件的背景色。
所以不用overflow,把子组件背景色设置透明transparent也可以。 

//overflow:(visible,hidden,scroll),设置子组件超出父组件的话该如何显示。
visible:默认值。内容不会被修剪，会呈现在元素框之外。
hidden:内容会被修剪，并且其余内容是不可见的。
scroll:内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。

//不透明opacity:(0~1),1不透明，0透明。

//zIndex是从屏幕指向外的z轴。

//一般用TouchableWithoutFeedback onPress 来接收点击事件。  
</code></pre>

<h4>Image</h4>

<pre><code>//Image里也可以嵌套。也可以显示gif

//capInsets {top, left, bottom, right} ,9-patch图片效果。

//tintColor: 为所有非透明的像素指定一个颜色.(tint:染，给...着色)

//resizeMode: 图片如何显示
Image.resizeMode.cover(按比例充满),(默认值)
Image.resizeMode.contain(按比例包含),
Image.resizeMode.stretch(拉伸充满),
Image.resizeMode.center(按比例居中),
Image.resizeMode.repeat(原比例重复显示)

 //如果 source 或者 uri 属性值有http前缀的话，会自动下载图片。

  //加载网络图片的一些回调方法，不论成功失败都会调用onLoadEnd
  &lt;Image
     style=/{/{width:300,height:100/}/} //把/去掉
     defaultSource={require('./images/msg.png')}
     onLoadStart={() =&gt; { console.log('Image:-----onLoadStart') }}
     onProgress={() =&gt; { console.log('Image:-----onProgress')  }}
     onLoad={() =&gt; { console.log('Image:-----onLoad')  }}//成功
     onError={() =&gt; { console.log('Image:-----onError')  }}//失败
     onLoadEnd={() =&gt; { console.log('Image:-----onLoadEnd')  }}//不论成功失败都会被调用
     source=/{/{uri:'https:xxx.png'/}/} //把/都去掉
    /&gt;
</code></pre>

<h4>图片加载成功</h4>

<p><img src="http://andyfightting.github.io/myimg/react/images.png" width="400" alt="" /></p>

<h4>图片加载失败</h4>

<p><img src="http://andyfightting.github.io/myimg/react/imagee.png" width="400" alt="" /></p>

<h4>Text</h4>

<pre><code>//Text里也可以嵌套其他组件。嵌套的空间是span样式而不是div块。

//文字居中除了要设置textAlign='center'，外还需设置lineHeight = height,因为textAlign只是水平对齐方式。

//Text本身设置alignSelf为flex-start,center,flex-end也会宽度自适应。

//fontStyle: (italic,normal,oblique).

//textDecorationLine:(none,underline,line-through,underline line-through)

//textDecorationStyle: (dashed,dotted,double,solid)

//letterSpacing: 字符间距

//Text有onPress，onLongPress.样式属性值可以通过state动态改变。

//ellipsizeMode: (clip,head,middle,tail,wordWrapping) wordWrapping:三个点都不显示

//adjustsFontSizeToFit: iOS的自动调整字体大小
</code></pre>

<h4>Button</h4>

<pre><code>//color: iOS是设置文字颜色，而Android是设置背景色.title 和 onPress两个属性是必须的。
Button可以属性很少啊，style样式都没用...一般用TouchableOpacity或TouchableNativeFeedback嵌套Text来自定义按钮。
</code></pre>

<h4>ScrollView</h4>

<p>ScrollView适合用来显示数量不多的滚动元素。放置在ScollView中的所有组件都会被渲染，哪怕有些组件因为内容太长被挤出了屏幕外。如果需要显示较长的滚动列表，应该使用ListView组件。代码在<code>/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js</code>。</p>

<p>发现一个奇怪的地方，如果ScrollView的父View设置了flex=1的话，再设置ScrollView的height就没效果了，ScrollView还是会充满父View ！</p>

<pre><code>//常用属性
ref //暴露一个引用
contentContainerStyle //内容容器样式，所以子控件都在内容容器里
automaticallyAdjustContentInsets //iOS的顶部是否留有空间，一般都设false，不知道干啥要弄出个这属性。
horizontal //true/false,水平排列还是垂直排列
keyboardDismissMode //none,interactive,onDrag.滚动时是否隐藏键盘，none不，onDrag开始拖动就隐藏，interactive:iOS的键盘位置同步变化。
keyboardShouldPersistTaps //true/false: 默认false:点击输入框外部会收起键盘。true:点击输入框外部不会自动收起键盘，scroll不会受到点击事件，但子控件可以收到。
onContentSizeChange //scroll的content size 变化是回调该方法。参数是contentWidth, contentHeight。
onScroll //滚动时实时调用，频率可以通过scrollEventThrottle属性设置。
pagingEnabled //是否分页
refreshControl //一个RefreshControl组件，用于下拉刷新。
removeClippedSubviews //是否移除scroll屏幕外的子视图，可以提高scroll性能，默认true。
scrollEnabled //是否能滚动，默认当然true。
showsHorizontalScrollIndicator //是否显示水平滚动条。
showsVerticalScrollIndicator //是否显示垂直滚动条
alwaysBounceHorizontal,alwaysBounceVertical //当内容小于size时，是否还bounce.
bounces //是否可以bounces，优先级高于上面的两个。
centerContent //当内容小于size时，是否居中。
contentInset = //inset
contentOffset= //offset
</code></pre>

<h4>ListView</h4>

<h4>TabBar</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native Navigator]]></title>
    <link href="http://andyfightting.github.io/blog/2016/12/01/react-navigator/"/>
    <updated>2016-12-01T09:27:30+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/12/01/react-navigator</id>
    <content type="html"><![CDATA[<p>这里主要记录一下Navigator的基本使用，页面间的传参，回调，以及在push,pop过程中生命周期方法的调用顺序。</p>

<p>React 的“页面”的概念和Android或iOS有点不一样，不像Android有个Activity作为页面容器，iOS有Controller作为页面容器。React 的“页面”本身就是一个组件集合，和Text,Image等基础组件是一个级别的东西。只不过是把多个组件拼起来充满屏幕，就组成一个“页面”了。</p>

<p>通过在Navigator的route里放置一个params参数，params里面放key-value传参。注意，方法也是对象，也可以当做value传递，这样就可回调了。就像Android的接口回调或iOS的block似的，在A页面实现方法，然后传递给B页面，在B页面使用方法，这样数据就从B回传给A了。数据从方法使用的地方传到方法实现的地方。</p>

<h4>在Index.js里初始化Navigator并且显示第一个页面FirstView:</h4>

<p><img src="http://andyfightting.github.io/myimg/java/lift0.png" width="500" alt="" /></p>

<h4>从FirstView push 到SecondView</h4>

<p><img src="http://andyfightting.github.io/myimg/java/lift1.png" width="500" alt="" /></p>

<h4>不调用FirstView的回调方法直接pop。</h4>

<p><img src="http://andyfightting.github.io/myimg/java/life3.png" width="500" alt="" /></p>

<h4>如果在SecondView里点击返回的时候，先掉用FirstView的回调方法, 在回调方法里调用 setState() 刷新FirstView，然后 pop 。</h4>

<p><img src="http://andyfightting.github.io/myimg/java/lift2.png" width="500" alt="" /></p>

<p>从上面可以看出不管是从A到B还是从B返回A,A的componentWillReceiveProps都会被调用! A的更新流程都会先走一遍！</p>

<p><img src="http://andyfightting.github.io/myimg/java/life4.png" width="600" alt="" /></p>

<pre><code>configureScene 属性用来配置场景动画。
configureScene={(route, routeStack) =&gt; {
                return Navigator.SceneConfigs.PushFromRight;
              }}
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>在/node_modules/react-native/Libraries/CustomComponents/Navigator/NavigatorSceneConfigs 中预设了很多转场动画。
</span><span class='line'>PushFromRight
</span><span class='line'>PushFromLeft
</span><span class='line'>FloatFromRight // We will want to customize this soon
</span><span class='line'>FloatFromLeft
</span><span class='line'>FloatFromBottom
</span><span class='line'>FloatFromBottomAndroid
</span><span class='line'>FadeAndroid
</span><span class='line'>HorizontalSwipeJump
</span><span class='line'>HorizontalSwipeJumpFromRight
</span><span class='line'>HorizontalSwipeJumpFromLeft
</span><span class='line'>VerticalUpSwipeJump
</span><span class='line'>VerticalDownSwipeJump</span></code></pre></td></tr></table></div></figure>


<h4>其他方法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>getCurrentRoutes() - 获取当前栈里的所有路由
</span><span class='line'>jumpBack() - 跳回之前的路由，还保留现在的，还可以再跳回来，会保留原样
</span><span class='line'>jumpForward() - 与上一个方法对应
</span><span class='line'>jumpTo(route) - 跳转到已有的场景并且不卸载
</span><span class='line'>push(route) - 跳转到新的场景，并且将场景入栈
</span><span class='line'>pop() - 跳转回去并且卸载掉当前场景
</span><span class='line'>replace(route) - 用一个新的路由替换掉当前场景
</span><span class='line'>replaceAtIndex(route, index) - 替换掉指定序列的路由场景
</span><span class='line'>replacePrevious(route) - 替换掉之前的场景
</span><span class='line'>resetTo(route) - 跳转到新的场景，并且重置整个路由栈
</span><span class='line'>immediatelyResetRouteStack(routeStack) - 用新的路由数组来重置路由栈
</span><span class='line'>popToRoute(route) - pop到路由指定的场景，在整个路由栈中，处于指定场景之后的场景将会被卸载
</span><span class='line'>popToTop() - pop到栈中的第一个场景，卸载掉所有的其他场景</span></code></pre></td></tr></table></div></figure>


<h4>index.ios.js</h4>

<pre><code>import React, {Component} from 'react';
import {View,Navigator,AppRegistry} from 'react-native';
import FirstView from './FirstView';

   var logName = 'Index:--------';

   export default class BaseNavigator extends Component {
     constructor(props){
          console.log(logName + 'constructor');
          super(props);
      }
      componentWillMount(){
          console.log(logName + 'componentWillMount');
      }
       render() {
         console.log(logName+'render')
        return (
        &lt;Navigator
          //把下面一行的/都去掉，因为Markdown转化不了所以加的
          initialRoute=/{/{params: /{/},view: FirstView /}/}
          renderScene={(route, navigator) =&gt; {
            let ShowedView = route.view;
            return &lt;ShowedView {...route.params} nav={navigator} /&gt;
          }} /&gt;
        );
       }

       componentDidMount() {
           console.log(logName + 'componentDidMount');
       }

       componentWillReceiveProps(nextprops){
              console.log(logName + 'componentWillReceiveProps');
        }
        shouldComponentUpdate(nextProps,nextState){
              console.log(logName + 'shouldComponentUpdate');
            return true;
        }
        componentWillUpdate(nextProps,nextState){
              console.log(logName + 'componentWillUpdate');
        }
        componentDidUpdate(prevProps,prevState){
            console.log(logName + 'componentDidUpdate');
        }
        componentWillUnmount(){
            console.log(logName + 'componentWillUnmount');
        }
   }
AppRegistry.registerComponent('MyReact', () =&gt; BaseNavigator);
</code></pre>

<h4>FirstView.js</h4>

<pre><code>import React,{Component} from 'react';
import {View,StyleSheet,Text} from 'react-native';
import SecondView from './SecondView';

var logName = 'FirstView:--------';
export default class FirstView extends Component { 
  constructor(props) {
    console.log(logName + 'constructor');
        super(props);
        this.state = {
            callBackMsg: '',
        };
    }
   componentWillMount(){
       console.log(logName + 'componentWillMount');
   }

    render() {
      console.log(logName+'render')
        return (
            &lt;View style={styles.backView}&gt;
                  &lt;Text style={styles.tapView}  onPress={this.pressedFun.bind(this)}&gt;点击跳转&lt;/Text&gt;
                  &lt;Text style={styles.msgView}&gt;
                    {this.state.callBackMsg}
                  &lt;/Text&gt;
            &lt;/View&gt;
        );
    }
    componentDidMount() {
        console.log(logName + 'componentDidMount');
    }

    componentWillReceiveProps(nextprops){
           console.log(logName + 'componentWillReceiveProps');
     }
     shouldComponentUpdate(nextProps,nextState){
           console.log(logName + 'shouldComponentUpdate');
         return true;
     }
     componentWillUpdate(nextProps,nextState){
           console.log(logName + 'componentWillUpdate');
     }
     componentDidUpdate(prevProps,prevState){
         console.log(logName + 'componentDidUpdate');
     }
     componentWillUnmount(){
         console.log(logName + 'componentWillUnmount');
     }
//-------个人方法--------
    pressedFun() {
        let nav = this.props.nav;
        let tmpThis = this;
            nav.push({
                view: SecondView,
                params:{
                  userId: 123,
                  userName: 'andy',
                  callBackFun: function(newMsg){
                      tmpThis.setState({
                        callBackMsg: newMsg,
                      })
                  },
                },
            });
          }
}

const styles = StyleSheet.create({
  backView:{
    flex: 1,
    justifyContent: 'center',
    backgroundColor: 'azure',
  },
  tapView:{
    fontSize: 20,
    alignSelf: 'center',
    textAlign: 'center',
    width: 130,
    height: 50,
    lineHeight: 50,
    color: 'yellow',
    borderColor: 'yellow',
    borderWidth: 2,
    borderRadius: 25,
    backgroundColor: 'blue',
    overflow: 'hidden',//不然边角会有背景色
  },
  msgView:{
    fontSize: 16,
    marginTop: 30,
    textAlign: 'center',
  },
});
</code></pre>

<h4>SecondView.js</h4>

<pre><code>import React,{Component} from 'react';
import {View,Navigator,StyleSheet,TouchableWithoutFeedback,Image,Text,} from 'react-native';

var logName = 'SecondView:--------';
export default class SecondView extends Component {
  static defaultProps = {
      // testProp: 'testProp默认值',
  }
  static propTypes = {
      // testProp: React.PropTypes.string.isRequired,
  }
  constructor(props) {
        console.log(logName + 'constructor');
        super(props);
        this.state = {};
    }
    componentWillMount(){
        console.log(logName + 'componentWillMount');
    }
    render() {
      console.log(logName+'render')
       return (
            &lt;View style={styles.backView}&gt;
              &lt;View style={styles.titleBackView}&gt;
              &lt;TouchableWithoutFeedback onPress={this.backPressed.bind(this)}&gt;
                 &lt;Image style={styles.backImage} source= {require('./images/backImage.png')}/&gt;
              &lt;/TouchableWithoutFeedback&gt;
                &lt;Text style={styles.titleView}&gt;标题&lt;/Text&gt;
              &lt;/View&gt;
                &lt;Text&gt;上个页面传来的参数userId: {this.props.userId}&lt;/Text&gt;
                &lt;Text&gt;上个页面传来的参数userName: {this.props.userName}&lt;/Text&gt;
            &lt;/View&gt;
        );
    }
    componentDidMount() {
        console.log(logName + 'componentDidMount');
    }

    componentWillReceiveProps(nextprops){
           console.log(logName + 'componentWillReceiveProps');
     }
     shouldComponentUpdate(nextProps,nextState){
           console.log(logName + 'shouldComponentUpdate');
         return true;
     }
     componentWillUpdate(nextProps,nextState){
           console.log(logName + 'componentWillUpdate');
     }
     componentDidUpdate(prevProps,prevState){
         console.log(logName + 'componentDidUpdate');
     }
     componentWillUnmount(){
         console.log(logName + 'componentWillUnmount');
     }

//------个人方法--------
     backPressed() {
         let nav = this.props.nav;
             this.props.callBackFun('这是消失的页面通过回调方法传来的数据！');
             nav.pop();
     }
}
const styles = StyleSheet.create({
  backView:{
    flex: 1,
    backgroundColor: 'bisque',
  },
  titleBackView:{
    height: 65,
    backgroundColor: 'darkkhaki',
    flexDirection: 'row'
  },
  titleView:{
    height:45,
    lineHeight:45,
    marginTop:20,
    color: 'white',
    fontSize: 18,
    textAlign: 'center',
    alignSelf: 'center',
    flex: 1,
    marginRight:20,
  },
  backImage:{
    marginTop:35,
    marginLeft:10,
    width: 10,
    height: 20,
  },
});
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 组件生命周期]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/30/react-native-life/"/>
    <updated>2016-11-30T11:08:59+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/30/react-native-life</id>
    <content type="html"><![CDATA[<p>生命周期就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期是开发的基础。<a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5语法和ES6语法有所变化</a>。</p>

<p><img src="http://andyfightting.github.io/myimg/java/life2.png" alt="" /></p>

<h4>可以把组件生命周期大致分为三个阶段：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；
</span><span class='line'>第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互接收事件更新界面；
</span><span class='line'>第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。</span></code></pre></td></tr></table></div></figure>


<p><strong>constructor(props) :</strong>这个方法会在组件创建的时候调用一次。 这个方法中可以通过this.state初始化状态参数，ES5是通过getInitialState()方法初始化的。</p>

<p><strong>getDefaultProps() :</strong>在组件类创建的时候调用一次，然后返回值被缓存下来。全局调用一次，所有实例共享。</p>

<p><strong>getInitialState() :</strong>在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。</p>

<p><strong>componentWillMount() :</strong>在组件创建并初始化了状态之后，在第一次 render() 之前。可以在这里做一些初始化操作。这个函数在整个生命周期中只被调用一次。</p>

<p><strong>render() :</strong>这个方法是必须的，对视图进行渲染，也可以返回 null 或者 false 来表明不需要渲染任何东西.</p>

<p><strong>componentDidMount() :</strong>在组件第一次绘制之后，会调用该方法通知组件已经加载完成。这个方法调用的时候，其虚拟 DOM 已经构建完成，可以在这个函数里获取其中的元素或者子组件。框架是先调用子组件的该方法，然后再调用父组件的。可以在这里发起网络请求等。</p>

<p><strong>componentWillReceiveProps(nextProps) :</strong> 父组件改变子组件的属性的时候会调用该方法,初次渲染时不会调用该方法。参数nextProps是即将被设置的属性，旧的属性还是可以通过 this.props 来获取。</p>

<p><strong>shouldComponentUpdate(nextProps,nextState) :</strong>当组件接收到新的属性或状态改变的话会调用该方法。参数 nextProps 和上面的方法一样。nextState 表示组件即将更新的状态值。这个方法的返回值决定是否需要更新组件，默认返回true。可以重载这个函数来决定组件是否需要更新。</p>

<p><strong>componentWillUpdate(nextProps,nextState) :</strong>如果组件状态改变，并且上面的方法返回为true，就会开始准更新组件。这里可以做一些在更新组件之前要做的事情。<strong>在这个方法里面不能再调用 this.setState 来修改状态</strong>。这个方法调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着就会调用 render() 来更新组件了。</p>

<p><strong>componentDidUpdate(prevProps,prevState) :</strong>在调用了 render() 更新组件同步到 DOM 中之后立刻调用该方法。因为到这里已经完成了属性和状态的更新了，此方法的参数变成了 prevProps 和 prevState。</p>

<p><strong>componentWillUnmount() :</strong>当组件从 DOM 中移除的时候就会调用该方法。可以这个方法中做一些资源清理工作。</p>

<p><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5 ES6写法对照表</a></p>

<p><a href="http://blog.kdchang.cc/2016/04/04/react-react-native-es5-es6-cheat-sheet/">ES5 ES6区别</a></p>

<p><a href="https://babeljs.io/blog/2015/06/07/react-on-es6-plus">React on ES6</a></p>

<p><a href="http://egorsmirnov.me/2015/06/14/react-and-es6-part2.html">React and ES6</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flexbox 布局]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/30/css-flex-box/"/>
    <updated>2016-11-30T08:56:06+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/30/css-flex-box</id>
    <content type="html"><![CDATA[<p>弹性盒子布局由弹性容器和弹性子item组成。容器默认存在两根轴：水平的主轴和垂直的交叉轴。主轴的开始位置叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。item默认沿主轴排列。item占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size
<img src="http://andyfightting.github.io/myimg/java/flexbox.png" width="600" alt="" /></p>

<p><strong>用在容器上的属性：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>flex-direction :决定item的排列方向。(row,row-reverse,column,column-reverse)
</span><span class='line'>flex-wrap :决定item如何换行。(nowrap,wrap,wrap-reverse)
</span><span class='line'>justify-content :决定itme在主轴上的对齐方式。(flex-start,flex-end,center,space-between,space-around)
</span><span class='line'>align-items :决定item在交叉轴上的对齐方式。(stretch,flex-start,flex-end,center,baseline:item第一行文字基线对齐)
</span><span class='line'>align-content :决定多条交叉轴线的对齐方式。(flex-start,flex-end,center,space-between,space-around,stretch)</span></code></pre></td></tr></table></div></figure>


<p>align-content:</p>

<p><img src="http://andyfightting.github.io/myimg/java/flex1.png" width="400" alt="" /></p>

<p><strong>用在Item上的属性</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>order :定义item的排列顺序。数值越小，排列越靠前，默认为0。
</span><span class='line'>flex-grow :定义item的放大比例。默认为0，即如果存在剩余空间也不放大。有多个的话按比例均分。
</span><span class='line'>flex-shrink :定义item的缩小比例。默认为1，即如果空间不足，该项目将缩小。0则不缩小。
</span><span class='line'>flex-basis :定义了在分配多余空间之前，item占据的主轴空间,默认auto,即本来大小。
</span><span class='line'>flex : flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。
</span><span class='line'>align-self :设置item自身在交叉轴上的对齐方式。可覆盖align-items属性。
</span><span class='line'>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
</span><span class='line'>(auto,flex-start,flex-end,center,baseline,stretch)</span></code></pre></td></tr></table></div></figure>


<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，也有些差异:flexDirection的默认值是column而不是row，alignItems的默认值是stretch而不是flex-start。使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求。</p>

<p><code>flexDirection</code>: 决定布局的主轴。子元素是沿着水平轴方向排列，还是沿着竖直轴方向排列。</p>

<p><code>justifyContent</code>: 决定子元素沿着主轴的排列方式。有flex-start、center、flex-end、space-around 和 space-between。</p>

<p><code>alignItems</code>: 决定其子元素沿着交叉轴的排列方式。有flex-start、center、flex-end以及stretch。<strong>注意：要使stretch选项生效的话，子元素在次轴方向上不能固定尺寸。</strong></p>

<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Fexbox布局实例</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 样式属性]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/29/rn-style/"/>
    <updated>2016-11-29T22:27:51+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/29/rn-style</id>
    <content type="html"><![CDATA[<p>React Native 采用CSS样式来布局，也会有继承和覆盖作用。只要在样式表中书写一个不存在的样式，就会报错，提示该样式不存在，然后提供所有可用的样式：
<img src="http://andyfightting.github.io/myimg/java/style.png" alt="" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//边框
</span><span class='line'>borderBottomWidth 
</span><span class='line'>borderLeftWidth 
</span><span class='line'>borderRightWidth 
</span><span class='line'>borderTopWidth 
</span><span class='line'>borderWidth </span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//边框颜色
</span><span class='line'>borderBottomColor
</span><span class='line'>borderLeftColor
</span><span class='line'>borderRightColor
</span><span class='line'>borderTopColor
</span><span class='line'>borderColor</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//外边距
</span><span class='line'>marginTop
</span><span class='line'>marginBottom
</span><span class='line'>marginLeft
</span><span class='line'>marginRight
</span><span class='line'>marginVertical //相当于marginTop 和 marginBottom
</span><span class='line'>marginHorizontal //相当于 marginLeft 和 marginRight
</span><span class='line'>margin</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//内边距  
</span><span class='line'>paddingTop  
</span><span class='line'>paddingBottom
</span><span class='line'>paddingLeft  
</span><span class='line'>paddingRight  
</span><span class='line'>paddingVertical //相当于 paddingTop 和 paddingBottom
</span><span class='line'>paddingHorizontal  //相当于 paddingLeft 和 paddingRight
</span><span class='line'>padding </span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//边框圆角
</span><span class='line'>borderTopLeftRadius
</span><span class='line'>borderTopRightRadius
</span><span class='line'>borderBottomLeftRadius
</span><span class='line'>borderBottomRightRadius
</span><span class='line'>borderRadius</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//flex 布局
</span><span class='line'>flex number 
</span><span class='line'>flexDirection enum('row', 'column') 
</span><span class='line'>flexWrap enum('wrap', 'nowrap') 
</span><span class='line'>alignItems enum('flex-start', 'flex-end', 'center', 'stretch') 
</span><span class='line'>alignSelf enum('auto', 'flex-start', 'flex-end', 'center', 'stretch') 
</span><span class='line'>justifyContent enum('flex-start', 'flex-end', 'center', 'space-between', 'space-around') 
</span><span class='line'>position属性值为absolute和relative，当使用绝对布局时，定位根据屏幕来进行。</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//字体相关属性
</span><span class='line'>color 字体颜色
</span><span class='line'>fontFamily 字体族
</span><span class='line'>fontSize 字体大小
</span><span class='line'>fontStyle 字体样式，正常，倾斜等，值为enum('normal', 'italic')
</span><span class='line'>fontWeight 字体粗细，值为enum("normal", 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900')
</span><span class='line'>letterSpacing 字符间隔
</span><span class='line'>lineHeight 行高
</span><span class='line'>textAlign 字体对齐方式，值为enum("auto", 'left', 'right', 'center', 'justify')
</span><span class='line'>textDecorationLine 上划线，下划线，删除线，无修饰，值为enum("none", 'underline', 'line-through', 'underline line-through')
</span><span class='line'>textDecorationStyle 修饰的线的类型 enum("solid", 'double', 'dotted', 'dashed')
</span><span class='line'>textDecorationColor 修饰的线的颜色
</span><span class='line'>writingDirection enum("auto", 'ltr', 'rtl') 书写方向，从左往右写还是从右往左写</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//图片相关属性
</span><span class='line'>resizeMode enum('cover', 'contain', 'stretch')
</span><span class='line'>overflow enum('visible', 'hidden') 超出部分是否显示，hidden为隐藏
</span><span class='line'>tintColor 着色，rgb字符串类型
</span><span class='line'>opacity 透明度
</span><span class='line'>scaleX:水平方向缩放
</span><span class='line'>scaleY:垂直方向缩放
</span><span class='line'>rotation:旋转
</span><span class='line'>translateX:水平方向平移
</span><span class='line'>translateY:水平方向平移
</span><span class='line'>//阴影,默认透明的，要设置shadowOpacity大于0才有效果
</span><span class='line'>shadowColor
</span><span class='line'>shadowOffset
</span><span class='line'>shadowOpacity
</span><span class='line'>shadowRadius</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 问题汇总]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/28/react-native-run-bug/"/>
    <updated>2016-11-28T18:46:09+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/28/react-native-run-bug</id>
    <content type="html"><![CDATA[<p>Android 设备:小米 red note MUI 8.0, iOS 设备:iPhone 6Plus 8.3</p>

<h5>1.运行不起来</h5>

<p>按照<a href="https://facebook.github.io/react-native/docs/getting-started.html#content">官网</a>的步骤一步一步下来运行报：</p>

<pre><code>com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Failed to establish session
</code></pre>

<p><a href="https://github.com/facebook/react-native/issues/6499">这里</a>说小米系列的手机都这样，我们平时用Android Studio调试运行不是会弹出个弹出框问是否安装吗？这是用USB链接的，所以没问题，但是用命令就掉动不起来那弹出框&hellip;
<img src="http://andyfightting.github.io/myimg/java/react_error_xm0.png" alt="" /></p>

<p>解决办法如下，关键是第4步，关闭小米的优化
<img src="http://andyfightting.github.io/myimg/java/react_error_xm1.png" alt="" /></p>

<h5>2.运行不起来</h5>

<p>报错：</p>

<pre><code>com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Unable to upload some APKs
</code></pre>

<p>解决：把 /项目/android/build.gradle 文件里的 <code>classpath 'com.android.tools.build:gradle:1.3.1'</code> 改成 <code>classpath 'com.android.tools.build:gradle:1.2.3'</code>就可以了&hellip;.why? yeah,why?</p>

<h5>3.白屏</h5>

<p>运行起来了，等啊等，怎么还是白屏？不是有东西的吗？摇啊摇不是有弹出框的吗？弹出框呢？？</p>

<p>解决：进系统设置，应用管理，找到这个应用，点击应用详情里的权限管理，开启显示悬浮框。刷新一下再摇一摇就有弹出框了。</p>

<h5>4.Could not connect to development server</h5>

<p>摇啊摇弹出框后，点击最后的 <code>Dev Settings</code> ，然后设置 <code>Debug server host &amp; port for device</code> 为<code>本机IP:8081</code>后返回刷新出现如下错误:</p>

<p><img src="http://andyfightting.github.io/myimg/java/react_error2.png" alt="" /></p>

<p>解决：命令行进入项目文件夹，运行如下命令：</p>

<pre><code>react-native start &gt; /dev/null 2&gt;&amp;1 &amp; curl "http://localhost:8081/index.android.bundle?platform=android" -o "android/app/src/main/assets/index.android.bundle"
</code></pre>

<p>如果提示没有 assets 文件夹，则先手动建一个再运行。之后就能真机运行起来了：</p>

<p><img src="http://andyfightting.github.io/myimg/java/react_android.png" alt="" /></p>

<h5>iOS模拟器Cmd+R不刷新，Cmd+D也没弹出框</h5>

<p>解决：要开启模拟器的键盘链接。模拟器菜单<code>Hardware</code>-><code>Keyboard</code> 选中 <code>Connect Hardware Keyboard</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native 基础知识]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/26/react-native-basic/"/>
    <updated>2016-11-26T11:16:25+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/26/react-native-basic</id>
    <content type="html"><![CDATA[<h4>React 的核心思想是：封装组件! React 应用都是构建在组件之上，各个组件维护自己的状态和 UI，当状态变更，自动重新渲染自身组件。组件的第一个字母必须大写,组件只能包含一个顶层标签。</h4>

<h4>Declarative</h4>

<p><a href="https://facebook.github.io/react/">React</a> 可以很好的创建交互式组件，设计不同状态下的组件，并且React可以根据组件的不同参数高效的刷新渲染。这样的组件可以让你的代码更加的可预测并且更方便调试。</p>

<h4>Component-Based</h4>

<p>基于组件，封装一个组件，让它们管理自己的状态，然后用它们去组成更加复杂的UI。由于组件的逻辑是写在JavaScript里的而不是模板里，这样你可以很轻松的让它穿梭于复杂的数据之间，并且在DOM外保持自己的状态。</p>

<h4>Learn Once, Write Anywhere</h4>

<p>我们不假定你现在的技术栈是怎样的，所以你可以不用重写已存在的代码来用React开放新的功能。React也可以在服务器端渲染，也可以用React Native创建强大的移动应用。</p>

<h4>A Simple Component</h4>

<p>React 组件调用 <code>render()</code> 方法来输入参数然后返回要显示的样子。这个例子用一个类似XML语言的我们称之为JSX，通过<code>this.props</code>输入数据传到组件内部可以被<code>render()</code>方法获取。使用React的话，JSX是可选的，不是必须要使用的。试着点击<code>Complied JS</code>去看看通过JSX编译器产生的原生的JavaScript 代码。</p>

<h4>A Stateful Component</h4>

<p>除了通过<code>this.props</code>来传入参数，组件可以通过<code>this.state</code>来维护自己内部状态的数据。当组件的状态数据改变时，渲染器就会重新调用<code>render()</code>方法来刷新。</p>

<h4>An Application</h4>

<p>使用<code>props</code>和<code>state</code>我们可以收集一个小型的代办事项申请。这个例子用<code>state</code>来跟踪当前列表和用户输入的数据。虽然事件处理程序似乎是呈现内联,他们会通过事件代理被收集和使用。</p>

<h4>A Component Using External Plugins</h4>

<p>React 是灵活的，并且提供了一个钩子来和库或框架进行链接。这个例子使用<code>remarkable</code>,一个外部的 Markdown 库，来实时转化文本内容。</p>

<p>哎呀~ 自己翻译果然别扭&hellip;😞  React 是什么呢？React 是Facebook 封装的一组JS代码库：</p>

<p><img src="http://andyfightting.github.io/myimg/java/react.png" alt="" /></p>

<p>按它规则可封装一个一个模块组件，这个模块组件有自己的状态，自己的逻辑等，它是一个独立的东西，然后把这样的组件一个一个组合起来。按照React 的规则可以混合着写JavaScript和HTML,这样的一个组件就是一个独立的模块化的View。添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。</p>

<p>React 还封装了一个自己的虚拟的DOM，通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。因为如果大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个虚拟 DOM，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 <a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">diff</a> 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性。给组件设置一个 <code>ref</code> 属性，然后用 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点对象。</p>

<h4>Hello World</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;

    &lt;script type="text/babel"&gt;
    var MyComponent = React.createClass({
      render: function() {
        return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;
      }
    });

    ReactDOM.render(&lt;MyComponent name="World !" /&gt;,
                    document.getElementById('example') );
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>上面的代码中用React的语法自定义了一个组件叫<code>MyComponent</code>,这个组件返回一个块区间，里面显示 Hello + 这个组件的<code>name</code>属性值。注意script 的type 要声明为<code>text/babel</code>。这样就可以在其他地方使用这个自定义的组件了。可以把 <code>props</code> 看作是组件的配置属性，在组件内部是不变的，只是在调用这个组件的时候传入不同的属性值来定制显示这个组件。当组件状态 <code>state</code> 有更改的时候，React 会自动调用组件的 <code>render()</code> 方法重新渲染整个组件的 UI。<code>this.props</code> 对象的属性与组件的属性一一对应，<code>this.props.children</code> 表示组件的所有子节点。需要注意， <code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 <code>this.props.children</code> 的时候要小心。上面的代码把 HTML 直接嵌入了 JS 代码里面了，这就是 React 提出的一种叫 JSX 的语法。把原来网页设计的代码分离，现在又融合了！</p>

<p><img src="http://andyfightting.github.io/myimg/java/react_hello.png" alt="" /></p>

<p>Hello World 运行起来了！嗯~ 我已经成功了一半！😆</p>

<h4>组件组合</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;

    &lt;script type="text/babel"&gt;

    var Avatar = React.createClass({
        render: function() {
            return (
                &lt;div&gt;
                    &lt;ProfilePic username={this.props.username} /&gt;
                    &lt;ProfileName username={this.props.username} /&gt;
                &lt;/div&gt;
            );
        }
       });

    var ProfilePic = React.createClass({
        render: function() {
            return (
                &lt;img src={'https://gss0.bdstatic.com/70cFsj3f_gcX8t7mm9GUKT-xh_/avatar/100/r6s1g6.gif'} /&gt;
            );
        }
    });

    var ProfileName = React.createClass({
        render: function() {
            return (
              &lt;div&gt;
                &lt;a href={'http://guimingsu.com'}&gt;
                    {this.props.username}
                &lt;/a&gt;
              &lt;/div&gt;
            );
        }
    });

    ReactDOM.render(
        &lt;Avatar username="hello world " /&gt;,
        document.getElementById('example')
      );

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这里显示了一个Avatar 组件，这个Avatar 组件是由两个更小的组件ProfilePic和ProfileName组合而成的。父组件和子组件间可以通过<code>props</code>一层一层的传值。Remember: React is all about one-way data flow down the component hierarchy.</p>

<p><img src="http://andyfightting.github.io/myimg/java/react_hello0.png" alt="" /></p>

<h4>状态变化</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;
    &lt;script type="text/babel"&gt;

     var LikeButton = React.createClass({
      getInitialState: function() {
        return {liked: false};
      },

      handleClick: function(event) {
        this.setState({liked: !this.state.liked});
      },

      render: function() {
        var text = this.state.liked ? 'like' : 'haven\'t liked';
        return (
          &lt;p onClick={this.handleClick}&gt;
            You {text} this. Click to toggle.
          &lt;/p&gt;
        );
      }
    });

    ReactDOM.render(
      &lt;LikeButton /&gt;,
      document.getElementById('example')
    );

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>上面代码是一个 <code>LikeButton</code> 组件，它的 <code>getInitialState</code> 方法用于定义初始状态，也就是一个对象，这个对象可以通过 <code>this.state</code> 属性读取。当用户点击组件，导致状态变化，<code>this.setState</code> 方法就修改状态值，每次修改以后，自动调用 <code>this.render</code> 方法，再次渲染组件。
由于 <code>this.props</code> 和 <code>this.state</code> 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，<code>this.props</code> 表示那些一旦定义，就不再改变的特性，而 <code>this.state</code> 是会随着用户互动而产生变化的特性。即把要跟随某个参数实时变化的代码写在 <code>render: function() {};</code>里，然后在用户调用的方法里调用<code>this.setState({ });</code>方法来改变参数就可以了，因为他们触发<code>render</code>方法。这样就可以根据不同参数值自动显示不同内容。</p>

<h4>生命周期</h4>

<p>组件的生命周期分成三个状态：</p>

<ol>
<li>Mounting：已插入真实 DOM</li>
<li>Updating：正在被重新渲染</li>
<li>Unmounting：已移出真实 DOM</li>
</ol>


<p>React 为每个状态都提供了两种处理函数，<code>will</code> 函数在进入状态之前调用，<code>did</code> 函数在进入状态之后调用，三种状态共计五种处理函数。</p>

<ol>
<li>componentWillMount()</li>
<li>componentDidMount()</li>
<li>componentWillUpdate(object nextProps, object nextState)</li>
<li>componentDidUpdate(object prevProps, object prevState)</li>
<li>componentWillUnmount()</li>
</ol>


<p>此外，React 还提供两种特殊状态的处理函数:</p>

<ol>
<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</li>
<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用</li>
</ol>


<p><img src="http://andyfightting.github.io/myimg/java/react_life.png" alt="" /></p>

<p>把这个<a href="https://facebook.github.io/react/docs/thinking-in-react.html">官方例子</a>看完就能收获不少了。主要在于思考，拿到设计图如何拆分模块，如何组建，如何选取放置状态参数，如何看懂别人写好的代码等。<a href="http://andyfightting.github.io/mysrc/java/reactPriceDemo.zip">下载</a></p>

<h5>链接</h5>

<ol>
<li><a href="http://www.cnblogs.com/sakurayeah/category/868210.html">React入门</a></li>
<li><a href="https://babeljs.io/docs/learn-es2015/">ECMAScript 2015</a></li>
<li><a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a></li>
<li><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5和ES6的写法对照表</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Atom]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/24/atom-edit/"/>
    <updated>2016-11-24T14:31:17+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/24/atom-edit</id>
    <content type="html"><![CDATA[<p><a href="https://atom.io/">Atom</a>是由GitHub开发的一款免费开源的编辑器，通过给它安装不同的插件包，就可以变成一款智能的IDE了。这里主要记录一下为了开发<a href="https://facebook.github.io/react-native/">React Native</a>所安装的插件包及基本使用。</p>

<p><a href="https://nuclide.io/">Nuclide</a>是官方推荐的开发React Native的基于Atom的工具。Nuclide 安装好后进入设置，选中<code>Install Recommented Packages on Startup</code>选项，下次启动的时候就会安装Nuclide所建议安装的插件了。</p>

<h4>插件</h4>

<p><strong>atom-react-native-autocomplete :</strong>React Native自动提示。</p>

<p><strong>atom-beautify :</strong> 文件排版格式化。ctrl-alt-b，可以进它的设置里选中 Beauty on Save 自动格式化。</p>

<p><strong>atom-html-preview :</strong> html预览。 ctrl-shift-h
<img src="http://andyfightting.github.io/myimg/java/atom-html-preview.png" width="700" alt="" /></p>

<p><strong>autocomplete-paths :</strong> 文件路径提示</p>

<p><img src="http://andyfightting.github.io/myimg/java/autocomplete-paths.png" width="500" alt="" /></p>

<p><strong>color-picker :</strong>颜色选取器，点击色块即可弹出，或者右键选择 Color Picker.</p>

<p><img src="http://andyfightting.github.io/myimg/java/color-picker.png" width="500" alt="" /></p>

<p><strong>docblockr :</strong> 快捷文档注释</p>

<p><strong>emmet :</strong>web开发神器</p>

<p><strong>file-icons :</strong>给文件加icon</p>

<p><img src="http://andyfightting.github.io/myimg/java/file-icons.png" width="200" alt="" /></p>

<p><strong>highlight-selected :</strong>选中相同的字符串高亮
<img src="http://andyfightting.github.io/myimg/java/highlight-selected.png" width="500" alt="" /></p>

<p><strong>js-hyperclick :</strong> js对象 cmd-点击 跳转</p>

<p><strong>merge-conflicts :</strong>解决版本冲突</p>

<p><strong>minimap :</strong>右边位置小地图
<img src="http://andyfightting.github.io/myimg/java/minimap.png" width="700" alt="" /></p>

<p><strong>pigments :</strong> 显示颜色。 快捷面板里搜 Pigments: Show Palette 可以打开调色板🎨。</p>

<p><img src="http://andyfightting.github.io/myimg/java/pigment.png" width="400" alt="" /></p>

<p><strong>pretty-json :</strong> Json 格式化。Packages->PrettyJson->Prettify</p>

<p><strong>react-snippets :</strong> React代码块快捷输入
<img src="http://andyfightting.github.io/myimg/java/react-snippets.png" width="700" alt="" /></p>

<p><strong>sort-lines :</strong>把列按字母排序。功能键 f5(电脑，设置，键盘里要开启功能选项) 或者 Edit->Lines->Sort</p>

<p><strong>tool-bar :</strong>上面显示工具栏，ctrl-alt-t 开/关
<img src="http://andyfightting.github.io/myimg/java/tool-bar.png" width="500" alt="" /></p>

<p>安装后的插件包不在Atom应用文件夹里，在 <code>/Users/用户名/.atom/packages/</code> 文件夹里。且 <code>.atom</code> 文件夹默认是隐藏的。在命令窗口输入显示文件夹命令。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//显示隐藏文件
</span><span class='line'>defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder
</span><span class='line'>//隐藏文件
</span><span class='line'>defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder</span></code></pre></td></tr></table></div></figure>


<p><img src="http://andyfightting.github.io/myimg/java/packages.png" width="300" alt="" /></p>

<h4>包的默认值修改</h4>

<p>可以直接点击<code>View Code</code>打开包的代码修改。也可以像上面先显示文件夹，找到对应的包，然后修改里面的默认配置。在Settings -> Open Config Folder 也可以打开所有插件包的配置。
<img src="http://andyfightting.github.io/myimg/java/package_change.png" width="700" alt="" /></p>

<h4>快捷键</h4>

<p>ctrl-space : 补全提示 (Mac要把设置->键盘->快捷键->Spotlight 里对应的快捷键取消掉! 不然电脑的优先级更高)</p>

<p>ctrl-alt-b : atom-beautify插件 代码格式化，为什么JSX格式化后有点乱&hellip;</p>

<p>cmd-shift-p : 打开快捷面板</p>

<p>cmd-f : 文件里搜索</p>

<p>cmd-shift-f : 项目里搜索</p>

<p>cmd-alt-[ : 折叠代码</p>

<p>cmd-alt-] : 展开代码</p>

<p>cmd-alt-shift-{ : 折叠所有代码</p>

<p>cmd-alt-shift-} : 展开所有代码</p>

<p>ctrl-[ : 左移动</p>

<p>ctrl-] : 右移动</p>

<p>ctrl-g : 跳转到某行</p>

<p>cmd-\ : 左边目录显示或隐藏</p>

<p>cmd-shift-o : 打开文件夹</p>

<p>cmd-b : 在打开的文件间切换</p>

<p>cmd-delete : 删除光标左边的</p>

<p>ctrl-shift-l : 删除一整行</p>

<p>ctrl-shift-&ldquo;+&rdquo; : 增大字体</p>

<p>ctrl-shift-&ldquo;-&rdquo; : 缩小字体</p>

<p><a href="https://github.com/kompasim/atom-plugins">[92款插件推荐]</a></p>

<p><a href="http://andyfightting.github.io/myimg/channel_v3.json">channel_v3.json</a></p>

<p><strong>嗯，还是WebStorm好用！！提示更智能也更多东西可以跳转查看，Atom没跳两下就跳不了了&hellip;</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Struts + Spring + MyBatis]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/18/struts-spring-mybatis/"/>
    <updated>2016-11-18T09:22:51+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/18/struts-spring-mybatis</id>
    <content type="html"><![CDATA[<h4>基本信息：</h4>

<p><code>Mac OS 10.11</code>, <code>eclipse neon</code>, <code>jdk1.8</code>, <code>tomcat7</code>, <code>struts2.5.5</code>, <code>spring4.3.4</code>, <code>mybatis3.4.1</code>,<code>mybatis-spring1.3</code>,<code>mysql数据库</code></p>

<h4>结构简介：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>用struts2的配置文件来控制方法的调用和页面的跳转，
</span><span class='line'>jps和Action通过strtus2标签方式或者EL表达式传值取值。
</span><span class='line'>Action负责业务逻辑处理，Action调用Service接口，Service接口注入某个Service的实现，
</span><span class='line'>在Service的实现里调用Dao来处理数据库。
</span><span class='line'>而Dao是用Mybatis通过对应的xml映射文件来关联的,
</span><span class='line'>且Action里的Service实现注入,Service实现类里的Dao注入,Dao的Section注入，
</span><span class='line'>都是通过Spring配置文件实现的。</span></code></pre></td></tr></table></div></figure>


<h4>截图:</h4>

<p><img src="http://andyfightting.github.io/myimg/java/ssm_index.png" alt="" />
<img src="http://andyfightting.github.io/myimg/java/ssm_list.png" alt="" />
<img src="http://andyfightting.github.io/myimg/java/ssm_json.png" alt="" />
<img src="http://andyfightting.github.io/myimg/java/ssm.png" alt="" /></p>

<p><a href="http://andyfightting.github.io/mysrc/java/SSM.zip">下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringMVC + Hibernate]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/17/springmvc-hibernate-jian/"/>
    <updated>2016-11-17T19:34:43+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/17/springmvc-hibernate-jian</id>
    <content type="html"><![CDATA[<h4>基本信息：</h4>

<p><code>Mac OS 10.11</code>, <code>eclipse neon</code>, <code>jdk1.8</code>, <code>tomcat7</code>, <code>spring4.3.4</code>, <code>Hibernate5.2.4</code>,<code>jackson2.5</code>,<code>mysql数据库</code></p>

<h4>截图:</h4>

<p><img src="http://andyfightting.github.io/myimg/java/ssh_frame.png" alt="" />
<img src="http://andyfightting.github.io/myimg/java/ssh_pack.png" alt="" /></p>

<h4>Controller从JSP取值</h4>

<pre><code>//1.使用HttpServletRequest获取
public String addUser(HttpServletRequest request) {
    String name = request.getParameter("name");
    String pass = request.getParameter("password");
    return "/addUser";
}
//2.使用注解
public String addUser(@RequestParam("name") String name,@RequestParam("password") String password) {
    System.out.println(name+password);
    return "/addUser";
}
//3.自动注入Entity属性
public String addUser(User user) {
    System.out.println(user.getName() + user.getPassword());
    return "/addUser";
}
</code></pre>

<h4>Controller传值给JSP</h4>

<pre><code>//1.使用HttpServletRequest 然后setAttribute()，就和Servlet中一样
public String getAllUser(HttpServletRequest request) {
    request.setAttribute("userList", userService.getAllUser());
    return "/index";
}
//2.使用Spring的ModelMap `public class ModelMap extends LinkedHashMap&lt;String, Object&gt;`，ModelMap数据会利用HttpServletRequest的Attribute传值
public String getAllUser(ModelMap modelMap) {
    modelMap.put("userList", userService.getAllUser());
    return "/index";
}
//3.HttpServletReequest的getSession()  
public String getAllUser(HttpServletRequest request) {
    HttpSession session = request.getSession();
    session.setAttribute("userList", userService.getAllUser());
    return "/index";
}
</code></pre>

<p><a href="http://andyfightting.github.io/mysrc/java/SSH.zip">下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hibernate 的使用]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/16/hibernate/"/>
    <updated>2016-11-16T09:20:12+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/16/hibernate</id>
    <content type="html"><![CDATA[<p>可以认为MyBatis是半自动化，而Hibernate是全自动化(也可半自动)。MyBatis是面向表和列的SQL查询，而Hibernate是用面向对象和对象属性的 HQL查询。 HQL 查询被 Hibernate 翻译为传统的 SQL 查询从而对数据库进行操作。尽管Hibernate可以直接使用本地 SQL 语句，但还是尽可能的使用 HQL 语句，以避免数据库移植产生的麻烦。在 HQL 中一些关键字比如 SELECT ，FROM 和 WHERE 等，是不区分大小写的，但对象名和属性名是区分大小写的。Hibernate也可以用注解方式来进行对象和表的关系映射，类似于<a href="http://ormlite.com/">OrmLit</a>这样。</p>

<p><img src="http://andyfightting.github.io/myimg/java/hibernate_frame.png" alt="" /></p>

<p>和Mybatis 很像，都是加载配置文件得到SessionFactory, 然后通过SessionFactory获取 Session,然后用Session进行HQL操作。</p>

<p>Hibernate(5.2.4)配置文件</p>

<pre><code>&lt;?xml version="1.0" encoding="GBK"?&gt;  
&lt;!DOCTYPE hibernate-configuration PUBLIC  
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"  
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;
&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:mysql://localhost:8889/java_db&lt;/property&gt;
        &lt;property name="connection.username"&gt;root&lt;/property&gt;
        &lt;property name="connection.password"&gt;root&lt;/property&gt;
        &lt;!-- 指定连接池里最大连接数 --&gt;
        &lt;property name="hibernate.c3p0.max_size"&gt;50&lt;/property&gt;
        &lt;!-- 指定连接池里最小连接数 --&gt;
        &lt;property name="hibernate.c3p0.min_size"&gt;5&lt;/property&gt;
        &lt;!-- 指定连接池里连接的超时时长 --&gt;
        &lt;property name="hibernate.c3p0.timeout"&gt;3000&lt;/property&gt;
        &lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt;
        &lt;property name="hibernate.c3p0.max_statements"&gt;100&lt;/property&gt;
        &lt;property name="hibernate.c3p0.idle_test_perxiod"&gt;3000&lt;/property&gt;
        &lt;property name="hibernate.c3p0.acquire_increment"&gt;2&lt;/property&gt;
        &lt;property name="hibernate.c3p0.validate"&gt;true&lt;/property&gt;
        &lt;!-- 指定数据库方言 --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt;
        &lt;!-- 根据需要自动创建数据表 --&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;
        &lt;!-- 显示Hibernate持久化操作所生成的SQL --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;
        &lt;!-- 将SQL脚本进行格式化后再输出 --&gt;
        &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;

        &lt;!-- 下面罗列所有的映射文件 --&gt;
        &lt;mapping resource="com/sgm/config/user.xml" /&gt;

    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre>

<p>对象到表的映射文件</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; 
&lt;hibernate-mapping package="com.sgm.bean"&gt;
   &lt;class name="User" table="user"&gt;
      &lt;id name="id" type="int" column="id"&gt;
         &lt;generator class="native"/&gt;
      &lt;/id&gt;
      &lt;property name="name" column="name" type="string"/&gt;
      &lt;property name="password" column="password" type="string"/&gt;
   &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>基本使用</p>

<pre><code>public class Main {
    private static SessionFactory factory;
    static{
        try {
            Configuration config = new Configuration().configure("com/sgm/config/hibernate.xml");
            factory = config.buildSessionFactory();
        } catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
        }
    }

@SuppressWarnings("unchecked")
public static void main(String[] args) {
    Session session = factory.openSession();
    Transaction transaction = null;
    try {
        transaction = session.beginTransaction();
        //数据库处理

        transaction.commit();
    } catch (Exception e) {
        if (transaction != null)
            transaction.rollback();
        e.printStackTrace();
    } finally {
        session.close();
    }
  }
}
</code></pre>

<p><img src="http://andyfightting.github.io/myimg/java/hibernate_zsg.png" alt="" /></p>

<p>一般情况下，用不带entityName参数的方法就可以了。带entityName的是hibernate在探索不使用pojo类进行O/R，不建议使用。</p>

<h4>查询</h4>

<pre><code>//from后面是对象！不是表名！对象和表在mapper文件里关联好了。hql面向的是对象，不是表！
String hql = "FROM User as u where u.id &gt;= 17 ";
Query&lt;User&gt; query = session.createQuery(hql);
List&lt;User&gt; list = query.getResultList();

//用setParameter设置查询参数，setFirstResult和setMaxResults可用于分页
String hql="from User as u where u.name=? and u.password = :password ORDER BY u.id DESC";
Query&lt;User&gt; query=session.createQuery(hql);
query.setParameter(0, "andy");
query.setParameter("password", "123");
query.setFirstResult(1);//从结果集的那一条开始(包括这一条)
query.setMaxResults(2);//最多几条
List&lt;User&gt; list=query.getResultList();

//query也可以用于批量修改和删除 
String hql = "UPDATE User set name = :name WHERE id &gt;= :id";
//String hql = "DELETE from User WHERE name = :name and id &gt;= :id";
Query&lt;User&gt; query = session.createQuery(hql);
query.setParameter("name", "andy hello");
query.setParameter("id", 19);
int result = query.executeUpdate();
System.out.println("处理了几条数据: " + result);
</code></pre>

<h4><a href="https://docs.jboss.org/hibernate/entitymanager/3.5/reference/en/html/querycriteria.html">CriteriaQuery</a> <a href="https://github.com/treehouse/giflib-hibernate/commit/f97a2828a466e849d8ae84884b5dce60a66cf412">废弃更新日志</a></h4>

<p>注意新的创建方式引用的包是 <code>import javax.persistence.criteria.CriteriaQuery</code>,而不是<code>import org.hibernate.criterion.CriteriaQuery</code>!!!</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//旧的已被废弃
</span><span class='line'>session.createCriteria(User.class) 的创建方式已经被废弃
</span><span class='line'>//改为这样,因为5.2.4的session已经继承了EntityManager，所以可以直接getCriteriaBuilder()。
</span><span class='line'>CriteriaBuilder cb = session.getCriteriaBuilder();
</span><span class='line'>CriteriaQuery&lt;User&gt; query = cb.createQuery(User.class);
</span><span class='line'>Root&lt;User&gt; user = query.from(User.class);
</span><span class='line'>query.select(user).where(cb.equal(user.get("name"), "andy"));
</span><span class='line'>List&lt;User&gt; list = session.createQuery(query).getResultList();</span></code></pre></td></tr></table></div></figure>


<h4>原生SQL</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>String sql = "select * from user where id = :tmpId";
</span><span class='line'>NativeQuery&lt;User&gt; nativeQuery = session.createNativeQuery(sql,User.class);
</span><span class='line'>nativeQuery.setParameter("tmpId", 19);
</span><span class='line'>nativeQuery.setFirstResult(1);
</span><span class='line'>nativeQuery.setMaxResults(2);
</span><span class='line'>List&lt;User&gt; list = nativeQuery.getResultList();
</span><span class='line'>//nativeQuery.executeUpdate(); 修改或者删除</span></code></pre></td></tr></table></div></figure>


<h4>one-to-many / many-to-one</h4>

<p>举个栗子： <code>User(单方)----Book(多方)</code>,一个user有多个book, 一个book只属于一个user。</p>

<pre><code>public class User {
    public int id;
    public String name;
    private Set&lt;Book&gt; books = new HashSet&lt;Book&gt;();
    //下面 getter setter
}

public class Book {
    public int id;
    public String name;
    public User user;
    //下面 getter setter
}
</code></pre>

<p>User mapper</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;
&lt;hibernate-mapping package="com.sgm.bean"&gt;
    &lt;class name="User" table="user"&gt;
        &lt;id name="id" type="int" column="id"&gt;
            &lt;generator class="native" /&gt;
        &lt;/id&gt;
        &lt;property name="name" column="name" type="string" /&gt;

        &lt;set name="books" inverse="true" cascade="all"&gt;
            &lt;key column="userId"&gt;&lt;/key&gt;
            &lt;one-to-many class="com.sgm.bean.Book" /&gt;
        &lt;/set&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>Book mapper</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;
&lt;hibernate-mapping package="com.sgm.bean"&gt;
    &lt;class name="Book" table="book"&gt;
        &lt;id name="id" type="int" column="id"&gt;
            &lt;generator class="native" /&gt;
        &lt;/id&gt;
        &lt;property name="name" column="name" type="string" /&gt;

        &lt;many-to-one name="user" class="com.sgm.bean.User"&gt;
            &lt;column name="userId"&gt;&lt;/column&gt;
        &lt;/many-to-one&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>测试</p>

<pre><code>public class Main {
    private static SessionFactory factory;
    static {
        try {
            Configuration config = new Configuration().configure("com/sgm/config/hibernate.xml");
            factory = config.buildSessionFactory();
        } catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
        }
    }

    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        Session session = factory.openSession();
        Transaction transaction = null;
        try {
            transaction = session.beginTransaction();
            // do some work
            User user = new User();
            user.setName("andy");

            Book book1 = new Book();
            book1.setName("哈利波特");
            book1.setUser(user);

            Book book2 = new Book();
            book2.setName("功夫之王");
            book2.setUser(user);

            user.getBooks().add(book1);
            user.getBooks().add(book2);

            session.save(user);

            transaction.commit();
        } catch (Exception e) {
            if (transaction != null)
                transaction.rollback();
            e.printStackTrace();
        } finally {
            session.close();
        }
    }
}
</code></pre>

<p><img src="http://andyfightting.github.io/myimg/java/hibernate_om.png" alt="" /></p>

<h4>中文乱码</h4>

<p>用Hibernate 插入中文到MySQL数据库时，即使MySQL数据库设置编码 <code>Character set = utf-8</code> 还是乱码。要改Hibernate 的配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;property name="connection.url"&gt;jdbc:mysql://localhost:8889/java_db&lt;/property&gt;
</span><span class='line'>//改为
</span><span class='line'>&lt;property name="connection.url"&gt;&lt;![CDATA[jdbc:mysql://localhost:8889/java_db?useUnicode=true&characterEncoding=utf8]]&gt;&lt;/property&gt;</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring 依赖注入]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/15/spring-ioc/"/>
    <updated>2016-11-15T09:17:48+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/15/spring-ioc</id>
    <content type="html"><![CDATA[<p><a href="https://spring.io/">Spring</a>是一个大东西，框架集合。Spring MVC, Spring AOP, Spring IoC&hellip;等等。先看看Spring IoC(Inversion of Control)控制反转。就是把原先要手动 new 一个对象，现在只要在Srping 的配置文件里配置就可以了，从主动控制对象，到被动接收对象，这就叫控制反转，也叫依赖注入(dependency injection)！ 依赖注入是Spring的核心机制，把对象之间的依赖关系转为用配置文件来管理，这有赖于它的核心组件 Beans, Core, Context 。</p>

<p><img src="http://andyfightting.github.io/myimg/java/spring_core.png" alt="" /></p>

<p>开始之前要下载Spring jar包，但是官网上只看到了maven 和 gradle 的添加方式，要手动下载jar包还不好找呢，藏得跟宝藏似的。<a href="http://repo.spring.io/release/org/springframework/spring/">Spring jar 包下载</a>，还需要它的依赖包 <a href="http://commons.apache.org/proper/commons-logging/download_logging.cgi">Commons Logging</a>。</p>

<p><img src="http://andyfightting.github.io/myimg/java/spring_jar.png" alt="" /></p>

<p>把上面的包下载下来添加到项目里，然后 Add to build path。</p>

<p><img src="http://andyfightting.github.io/myimg/java/spring_add.png" alt="" /></p>

<p>Spring 可以用注解方式注入和xml方式注入。</p>

<h5>1.注解的方式注入一个接口的实现</h5>

<p>接口定义</p>

<pre><code>public interface MessageInterface {
   public String getMessage();
   public String getName();
}
</code></pre>

<p>操作Action</p>

<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component //必须要
public class MessageAction {

final private MessageInterface service;

@Autowired //可不要
public MessageAction(MessageInterface service) {
    this.service = service;
}

public void printMessage() {
    System.out.println(this.service.getMessage() + this.service.getName());
  }
}
</code></pre>

<p>测试类</p>

<pre><code>import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.*;

@Configuration //可不要
@ComponentScan //必须要
public class Application {
    @Bean
    MessageInterface injectImp() {
        return new MessageInterface() {
            public String getMessage() {
              return "Hello World!";
            };

        public String getName(){
            return "sgm";
        }
    };
}

  public static void main(String[] args) {
      ApplicationContext context = new AnnotationConfigApplicationContext(Application.class);
      MessageAction printer = context.getBean(MessageAction.class);
      printer.printMessage();
  }
}
</code></pre>

<p>结果打印出</p>

<pre><code>Hello World!sgm
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Configuration 用于标注一个类，表示bean定义的源文件
</span><span class='line'>@ComponentScan  用于标注一个类，表示扫描指定包中的@Component标注的类。通过该实例得到 ApplicationContext
</span><span class='line'>@Component  用于标注一个类组件，然后通过 ApplicationContext 对象获取
</span><span class='line'>@Bean 用于注入一个实例对象，相当于Spring &lt;bean&gt;XML里的配置
</span><span class='line'>@Autowired  用于标注setter方法，构造器，包含多个参数的方法，集合等等，用于自动注入绑定实例</span></code></pre></td></tr></table></div></figure>


<h5>2.用xml的方式注入一个接口的实现</h5>

<p>如下，UserService是接口，里面定义一个print()方法。UserServiceImp是UserService的一个实现类，实现print(&ldquo;hello wrold&rdquo;)。</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="userService" class="com.sgm.implement.UserServiceImp"/&gt;

&lt;/beans&gt;
</code></pre>

<p>userService.print()就会打印出绑定实现类里的"hello wrold"。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> ApplicationContext context =  new ClassPathXmlApplicationContext("com/sgm/spring/bean.xml");
</span><span class='line'> UserService userService = (UserService) context.getBean("userService");
</span><span class='line'> userService.print();</span></code></pre></td></tr></table></div></figure>


<p>用xml的方式还可以通过类的构造函数注入，上面的例子是通过属性的set方法注入的。</p>

<pre><code>&lt;bean id="serviceProvider" class="com.sgm.service.ServiceProvider"&gt;
    &lt;constructor-arg ref="userService"&gt;&lt;/constructor-arg&gt;  
&lt;/bean&gt; 

&lt;bean id="userService" class="com.sgm.implement.UserServiceImp"/&gt;
</code></pre>

<p>xml默认都是注入一个单例对象的，即bean的属性 scope = &ldquo;singleton&rdquo; 为默认值。如果要每次都注入一个新对象，则设置bean的属性 scope = &ldquo;prototype"。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis 的使用]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/14/mybatis/"/>
    <updated>2016-11-14T19:26:25+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/14/mybatis</id>
    <content type="html"><![CDATA[<p>Mybatis是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>

<p>需要两个包：<a href="https://github.com/mybatis/mybatis-3/releases">MyBatis包</a>和<a href="https://www.mysql.com/products/connector/">JDBC Driver for MySQL</a></p>

<p>无论是用过的mybatis和hibernate他们的共同点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1.从配置文件(通常是XML配置文件中)得到sessionfactory
</span><span class='line'>2.由sessionfactory产生session
</span><span class='line'>3.在session中完成对数据的增删改查和事务提交等
</span><span class='line'>4.在用完之后关闭session 
</span><span class='line'>5.在java 对象和数据库之间有mapping的配置文件，也通常是xml文件</span></code></pre></td></tr></table></div></figure>


<p>主要XML配置文件中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源和决定事务范围和控制方式的事务管理器。通过加载该文件获取SqlSessionFactory。</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;!--对象别名定义 --&gt;
    &lt;typeAliases&gt;
        &lt;typeAlias alias="User" type="com.sgm.java.User" /&gt;
    &lt;/typeAliases&gt;

&lt;!--数据库连接 --&gt;
&lt;environments default="development"&gt;
    &lt;environment id="development"&gt;
        &lt;transactionManager type="JDBC" /&gt;
        &lt;dataSource type="POOLED"&gt;
            &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt;
            &lt;property name="url" value="jdbc:mysql://localhost:8889/java_db" /&gt;
            &lt;property name="username" value="root" /&gt;
            &lt;property name="password" value="root" /&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;

&lt;!--数据库操作映射文件 --&gt;
&lt;mappers&gt;
    &lt;mapper resource="com/sgm/mybatis/User.xml" /&gt;
&lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>

<p>数据库操作映射文件</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;!--namespace很重要，绑定对应的接口文件！--&gt;
&lt;mapper namespace="com.sgm.java.UserDao"&gt;

&lt;resultMap type="User" id="resultListUser"&gt;
    &lt;result column="name" property="name" /&gt;
    &lt;result column="age" property="age" /&gt;
&lt;/resultMap&gt;

&lt;!--id名字要和UserDao里的方法名一样  --&gt;
&lt;insert id="addUser" parameterType="User" useGeneratedKeys="true" keyProperty="id"&gt;
    insert into user(name, age) values(#{name}, #{age});
&lt;/insert&gt;

&lt;delete id="deleteUserById" parameterType="int"&gt;
    delete from user where id = #{id};
&lt;/delete&gt;

&lt;update id="updateUser" parameterType="User" &gt;
     update user set name = #{name}, age = #{age} where id = #{id};
&lt;/update&gt;

&lt;select id="getAllUsers" resultMap="resultListUser"&gt;
    select * from user ;
&lt;/select&gt;

&lt;select id="selectUserById" parameterType="int" resultType="User"&gt;
   select * from user where id = #{id};
&lt;/select&gt;
&lt;/mapper&gt;
</code></pre>

<p>定义数据库操作接口，方法要和对应的映射文件里的id名称一样！</p>

<pre><code>public interface UserDao {
    //  方法名要和User.xml配置文件里的id名称一样
    public void addUser(User user);

    public void deleteUserById(int id);

    public void updateUser(User user);

    public List&lt;User&gt; getAllUsers();

    public User selectUserById(int id);
}
</code></pre>

<p>操作的Java对象</p>

<pre><code>public class User {
        public int id;
        public String name;
        public int age;

    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre>

<p>测试</p>

<pre><code>public class Main {
    private static Reader reader;
    private static SqlSessionFactory sqlSessionFactory;

static {
    try {
        reader = Resources.getResourceAsReader("MyBatisConfig.xml");
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public static void main(String[] args) {
    SqlSession session = sqlSessionFactory.openSession();
    UserDao userDao = session.getMapper(UserDao.class);

    try {
//          // 增
//          User newUser = new User();
//          newUser.setName("andy");
//          newUser.setAge(20);
//          userDao.addUser(newUser);
//          session.commit();//必须提交
//          System.out.println("reult------： 新增的userId " + newUser.getId());    
//          //删
//          userDao.deleteUserById(1);
//          session.commit();//必须提交

//          //改
//          User updateUser = new User();
//          updateUser.setId(4);
//          updateUser.setName("andy");
//          updateUser.setAge(20);
//          userDao.updateUser(updateUser);
//          session.commit();//必须提交

//          //列表
//          List&lt;User&gt; userList = userDao.getAllUsers();
//          for(User user : userList){
//              System.out.println("reult------：  " + user.getName());            
//          }
            //查单个
//          User user = userDao.selectUserById(4);
//          System.out.println("reult------：  " + user.getName());
        } finally {
            session.close();//必须关闭
        }
    }
}
</code></pre>

<h3>传参方式</h3>

<h5>1.用下标获取</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//Dao层接口定义
</span><span class='line'>public User selectUser(String name,String password);
</span><span class='line'>//对应的映射方法,用下标获取
</span><span class='line'>&lt;select id="selectUser" resultMap="userList"&gt;
</span><span class='line'>    select  *  from user where name = #{0} and password=#{1}
</span><span class='line'>&lt;/select&gt;
</span><span class='line'>//定义userList
</span><span class='line'>&lt;resultMap type="User" id="userList"&gt;
</span><span class='line'>  &lt;result column="id" property="id" /&gt;
</span><span class='line'>  &lt;result column="name" property="name" /&gt;
</span><span class='line'>  &lt;result column="password" property="password" /&gt;
</span><span class='line'>&lt;/resultMap&gt;</span></code></pre></td></tr></table></div></figure>


<h5>2.传自定义对象</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void updateUser(User user);
</span><span class='line'>&lt;update id="updateUser" parameterType="User"&gt;
</span><span class='line'>  update user set name = #{name}, password = #{password} where id = #{id};
</span><span class='line'>&lt;/update&gt;
</span><span class='line'>//定义User别名
</span><span class='line'>&lt;typeAliases&gt;
</span><span class='line'>  &lt;typeAlias alias="User" type="com.sgm.bean.User" /&gt;
</span><span class='line'>&lt;/typeAliases&gt;</span></code></pre></td></tr></table></div></figure>


<h5>3.用注解的方式</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public User selectUser(@Param("name")String name,@Param("password")String password);
</span><span class='line'>&lt;select id="selectUser" resultType="User"&gt;
</span><span class='line'>  select * from user where name = #{name} and password = #{password};
</span><span class='line'>&lt;/select&gt;</span></code></pre></td></tr></table></div></figure>


<h4>动态SQL语句</h4>

<pre><code>&lt;select id="selectSameAddressUser" parameterType="User" resultType="userList"&gt;
    select * from user 
        &lt;if test="name != null"&gt;
            title = #{name}
        &lt;/if&gt;
        &lt;if test="address != null"&gt;
            and address = #{address}
        &lt;/if&gt;
&lt;/select&gt;
</code></pre>

<h3>注意!</h3>

<h5>SqlSessionFactoryBuilder</h5>

<p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围,也就是局部方法变量。可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p>

<h5>SqlSessionFactory</h5>

<p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次。因此 SqlSessionFactory 的最佳范围是应用范围。可以使用单例模式或者静态单例模式。</p>

<h5>SqlSession</h5>

<p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的范围是请求或方法范围。不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。每次操作应该打开一个 SqlSession，处理数据，处理完后就关闭它。关闭操作很重要，应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SqlSession session = sqlSessionFactory.openSession();
</span><span class='line'>try {
</span><span class='line'>  // do work
</span><span class='line'>} finally {
</span><span class='line'>  session.close();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 一行代码选取图片]]></title>
    <link href="http://andyfightting.github.io/blog/2016/11/11/android-select-photo/"/>
    <updated>2016-11-11T19:31:33+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/11/11/android-select-photo</id>
    <content type="html"><![CDATA[<p>一行代码模仿iOS的选取图片效果。思路主要是把相机和相册的回调放在一个透明的Activity里，然后在这个透明的Activity中弹出自定义的ActionSheet选择框，选取调相机还是相册。相机比较简单，直接调系统的。相册就不用系统的了，不同手机差别太大，效果也不好。自己遍历本地图片文件然后显示。这样即时在不同手机上也能展示相同的效果了。封装后使用就简单了，一行代码调用就可以，不会和业务Activity耦合了！</p>

<h4>使用:</h4>

<p>1.选取一张正方形图片</p>

<pre><code>   SelectPhotoSheet.showCropImageSheet(this, new AlbumResultListener() {
            @Override
            public void complete(View tapedView, List&lt;String&gt; pathList) {
                cache.displayBmp(headImageView, pathList.get(0), new Point(100, 100));
            }
        });
</code></pre>

<p>2.选取限制数量的全尺寸图片</p>

<pre><code>SelectPhotoSheet.showFullImageSheet(this, 8, new AlbumResultListener() {
            @Override
            public void complete(View tapedView, List&lt;String&gt; pathList) {
                localPathList.clear();
                localPathList.addAll(pathList);
                adapter.notifyDataSetChanged();
            }
        });
</code></pre>

<p><img src="http://andyfightting.github.io/myimg/android/one_select.png" alt="" /></p>

<h4>实现</h4>

<p>1.自定义ActionSheet，弄一个Sheet的工具类 BaseSheetActivity。</p>

<pre><code>//用作弹出 action sheet 效果的 base activity
public class BaseSheetActivity extends Activity {
    protected int activityCloseEnterAnimation;
    protected int activityCloseExitAnimation;

public static ItemTapListener itemTapListener;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);

    TypedArray activityStyle = getTheme().obtainStyledAttributes(new int[] {android.R.attr.windowAnimationStyle});
    int windowAnimationStyleResId = activityStyle.getResourceId(0, 0);
    activityStyle.recycle();

    activityStyle = getTheme().obtainStyledAttributes(windowAnimationStyleResId, new int[] {android.R.attr.activityCloseEnterAnimation, android.R.attr.activityCloseExitAnimation});
    activityCloseEnterAnimation = activityStyle.getResourceId(0, 0);
    activityCloseExitAnimation = activityStyle.getResourceId(1, 0);
    activityStyle.recycle();
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    dismiss();
    if (itemTapListener != null){
        itemTapListener.itemTap(new View(this),"");
    }
    return super.onTouchEvent(event);
}

@Override
public void finish() {
    dismiss();
}

public void dismiss(){
    super.finish();
    overridePendingTransition(activityCloseEnterAnimation, activityCloseExitAnimation);
}

public static void show(Context context, Class showedActivityClass, ItemTapListener itemTapListener){
    BaseSheetActivity.itemTapListener = itemTapListener;
    Intent intent = new Intent(context,showedActivityClass);
    context.startActivity(intent);
}
}
</code></pre>

<p>  要使用ActionSheet的效果话就是继承它，然后theme选择ActionSheetTheme。然后把界面的布局从bottom开始布局。</p>

<pre><code>  public class PhotoSheet extends BaseSheetActivity {

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.action_photo_sheet); //action_photo_sheet的布局从bottom开始

}

public void itemTap(View view){
    dismiss();
    if (itemTapListener != null){
        itemTapListener.itemTap(view,"");
    }
}

@Override
public void onBackPressed() {
    dismiss();
    if (itemTapListener != null){
        itemTapListener.itemTap(new View(this),"");
    }
}
}

   //设置为自定义的样式
 &lt;activity
        android:name=".photo_lib.photo.PhotoSheet"
        android:theme="@style/ActionSheetTheme" /&gt;
</code></pre>

<p>2.读图片文件路径，不单单是相册里的图片</p>

<pre><code>public void getLocalImages() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                Uri mImageUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
                ContentResolver mContentResolver = AlbumDirActivity.this.getContentResolver();

            Cursor mCursor = mContentResolver.query(
                    mImageUri,
                    null,
                    MediaStore.Images.Media.MIME_TYPE + "=? or " + MediaStore.Images.Media.MIME_TYPE + "=? or " + MediaStore.Images.Media.MIME_TYPE + "=?",
                    new String[]{"image/jpeg", "image/png", "image/jpg"},
                    MediaStore.Images.Media.DATE_MODIFIED);

            while (mCursor.moveToNext()) {
                String path = mCursor.getString(mCursor.getColumnIndex(MediaStore.Images.Media.DATA));
                String parentName = new File(path).getParentFile().getName();

                if (!dirMap.containsKey(parentName)) {
                    List&lt;String&gt; chileList = new ArrayList&lt;&gt;();
                    chileList.add(path);
                    dirMap.put(parentName, chileList);
                } else {
                    dirMap.get(parentName).add(path);
                }
            }
            mCursor.close();
            mHandler.sendEmptyMessage(SCAN_OK);
        }
    }).start();
}
</code></pre>

<p>3.用LruCache缓存显示压缩后的图片</p>

<pre><code>public class LocalImageCache {

private static LocalImageCache mInstance;

private Handler mHander = new Handler();
private LruCache&lt;String, Bitmap&gt; mMemoryCache;
private CacheImageCallBack mCallBack;
private ExecutorService mImageThreadPool = Executors.newFixedThreadPool(5);

private LocalImageCache() {
    final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
    final int cacheSize = maxMemory / 5;

    mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {
        @Override
        protected int sizeOf(String key, Bitmap bitmap) {
            return bitmap.getByteCount()/1024;
        }
    };

    mCallBack = new CacheImageCallBack() {
        @Override
        public void onImageLoader(ImageView imageView, Bitmap bitmap) {
            if (bitmap != null &amp;&amp; imageView != null) {
                imageView.setImageBitmap(bitmap);
            }
        }
    };
}

public static LocalImageCache getInstance() {
    synchronized (LocalImageCache.class) {
        if (mInstance == null) {
            mInstance = new LocalImageCache();
        }
        return mInstance;
    }
}

public static void clearCache() {
    LocalImageCache cache = getInstance();
    cache.mMemoryCache.evictAll();
}

public void displayBmp(final ImageView imageView, final String path, final Point mPoint) {
    if (TextUtils.isEmpty(path) || imageView == null) {
        return;
    }

    Bitmap bitmap = getBitmapFromMemCache(path);
    if (bitmap == null) {
        imageView.setImageBitmap(null);

        mImageThreadPool.execute(new Runnable() {
            Bitmap mBitmap;

            @Override
            public void run() {
                mBitmap = decodeThumbBitmapForFile(path, mPoint == null ? 0 : mPoint.x, mPoint == null ? 0 : mPoint.y);
                mHander.post(new Runnable() {
                    @Override
                    public void run() {
                        mCallBack.onImageLoader(imageView, mBitmap);
                    }
                });
                addBitmapToMemoryCache(path, mBitmap);
            }
        });
    } else {
        imageView.setImageBitmap(bitmap);
    }
}

private void addBitmapToMemoryCache(String key, Bitmap bitmap) {
    if (getBitmapFromMemCache(key) == null &amp;&amp; bitmap != null) {
        mMemoryCache.put(key, bitmap);
    }
}

private Bitmap getBitmapFromMemCache(String key) {
    return mMemoryCache.get(key);
}

private Bitmap decodeThumbBitmapForFile(String path, int viewWidth, int viewHeight) {
    BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeFile(path, options);
    options.inSampleSize = computeScale(options, viewWidth, viewHeight);
    options.inJustDecodeBounds = false;

    return BitmapFactory.decodeFile(path, options);
}

private int computeScale(BitmapFactory.Options options, int viewWidth, int viewHeight) {
    int inSampleSize = 1;
    if (viewWidth == 0 || viewHeight == 0) {
        return inSampleSize;
    }
    int bitmapWidth = options.outWidth;
    int bitmapHeight = options.outHeight;

    if (bitmapWidth &gt; viewWidth || bitmapHeight &gt; viewHeight) {
        int widthScale = Math.round((float) bitmapWidth / (float) viewWidth);
        int heightScale = Math.round((float) bitmapHeight / (float) viewHeight);

        inSampleSize = (widthScale+heightScale)/2;
    }
    return inSampleSize;
}


private interface CacheImageCallBack {
    void onImageLoader(ImageView imageView, Bitmap bitmap);
}
}
</code></pre>

<p>4.用DrawerLayout封装了一个手势返回的基础类</p>

<pre><code>public class BaseSwipeActivity extends AppCompatActivity {

private LinearLayout containerLayout;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    initSwipeView();
}

@Override
protected void onDestroy() {
    super.onDestroy();
}

private void initSwipeView() {
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    setContentView(R.layout.activity_base_swipe);

    containerLayout = (LinearLayout) findViewById(R.id.container_layout);

    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.base_drawer_layout);
    drawer.openDrawer(GravityCompat.END);
    ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawer, R.string.navigation_drawer_open, R.string.navigation_drawer_close) {
        @Override
        public void onDrawerClosed(View drawerView) {
            super.onDrawerClosed(drawerView);
            finish();
        }
    };
    drawer.addDrawerListener(toggle);
}

//子类要手势返回就用setMainView!!!!
public void setMainView(int viewId) {
    LayoutInflater inflater = LayoutInflater.from(this);
    View tmpView = inflater.inflate(viewId, null);

    if (tmpView instanceof LinearLayout) {
        LinearLayout.LayoutParams linearLayoutParams = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(linearLayoutParams);
    } else if (tmpView instanceof RelativeLayout) {
        RelativeLayout.LayoutParams relativeLayoutParams = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
        tmpView.setLayoutParams(relativeLayoutParams);
    }
    containerLayout.removeAllViews();
    containerLayout.addView(tmpView);
}

public void backViewTap(View v) {

}

public void backImageTap(View v) {
    finish();
}
}
</code></pre>

<p>其他Activity需要手势返回的话就继承它，然后使用setMainView()替代setContentView()设置界面布局，其他什么都不用管啦！</p>

<h4>注意</h4>

<p>要在使用的Activity的onDestroy()方法中调用 FileUtil.deleteAllFile(); 清除选取的临时缓存图片！！！</p>

<p><a href="https://github.com/AndyFightting/SelectPhoto_Android">下载</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Not Found for Architecture Arm64]]></title>
    <link href="http://andyfightting.github.io/blog/2016/09/12/link-bug/"/>
    <updated>2016-09-12T10:00:18+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/09/12/link-bug</id>
    <content type="html"><![CDATA[<p>接手维护一个项目，更新一下出现了下面这问题👇
<img src="http://andyfightting.github.io/myimg/ios/arm64.png" alt="image" /></p>

<p>好像不常见的问题，谷歌一下</p>

<p><a href="http://stackoverflow.com/questions/19213782/undefined-symbols-for-architecture-arm64">Stack Overflow</a>
<img src="http://andyfightting.github.io/myimg/ios/stackoverflow.png" alt="image" /></p>

<p>说是Architectures设置问题&hellip; 说是Other Linker Flags问题&hellip;说是Target Membership问题&hellip; 改了好像都没用啊，问题还是一动不动的出现在那里&hellip;
<img src="http://andyfightting.github.io/myimg/ios/targetMap.png" alt="image" /></p>

<p>继续找找找&hellip;用对应的类文件全局搜一下&hellip;诶~ 好像那里不对啊&hellip;路径怎么这样子??怎么和别的不一样~~ 喜出望外，好像知道原因了，果然项目文件夹里看不到该文件，Add Files to &ldquo;XXX"添加文件!
<img src="http://andyfightting.github.io/myimg/ios/errorLoad.png" alt="image" /></p>

<p>还是不行&hellip;把对应的.h .m文件拖到桌面上，再重新添加到项目里，解决了！！为什么一开始不怀疑是文件索引问题呢？ 因为项目编译没报 XXX.h not found &hellip;以为文件都好好的呢，以为是项目的配置问题&hellip; 所以一开始找问题的方向就跑偏了！其实这问题之前也遇到过，一般是第三方的XXX.a文件出现这问题，只是这次脑袋没长记性&hellip;这问题一般是多人开发项目用SVN更来更去导致的<code>project.pbxproj</code>里对应的文件索引没了。好了，再遇到这问题就不要跑偏了，把对应的文件重新添加就可以了！！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OkHttp and Retrofit]]></title>
    <link href="http://andyfightting.github.io/blog/2016/09/08/okhttp-retrofit/"/>
    <updated>2016-09-08T14:57:19+08:00</updated>
    <id>http://andyfightting.github.io/blog/2016/09/08/okhttp-retrofit</id>
    <content type="html"><![CDATA[<p><a href="http://square.github.io/okhttp/">OkHttp</a>和<a href="http://square.github.io/retrofit/">Retrofit</a>都是<a href="http://square.github.io/">Square</a>公司开源出来的网络请求框架。Retrofit是对OkHttp的封装，使其可以用注解的方式调用。</p>

<h4>OkHttp</h4>

<pre><code>//-----okhttp 网络请求 工具类-----

//异步请求结果放在主线程回调。
private static final Handler mainHandler = new Handler(Looper.getMainLooper()); 

private static final OkHttpClient client = new OkHttpClient.Builder()
        .connectTimeout(10, TimeUnit.SECONDS)
        .writeTimeout(10, TimeUnit.SECONDS)
        .readTimeout(10, TimeUnit.SECONDS)
        .build();

public static void getRequest(String url, final OkHttpListener listener) {
    Request request = new Request.Builder()
            .header("token", getUserToken())
            .header("client", "Android")
            .header("versionCode", getVersionCode())
            .header("versionName", getVersionName())
            .url(url)
            .build();
    beginRequest(request, listener);
}

//这样就不会有中文乱码问题
public static void postRequest(String url, final Map&lt;String, String&gt; params, final OkHttpListener listener) {
    StringBuilder stringBuilder = new StringBuilder("");
    if (params != null) {
        Set&lt;String&gt; keys = params.keySet();
        for (String key : keys) {
            String value = params.get(key);
            stringBuilder.append(key + "=" + value + "&amp;");
        }
    }

    MediaType mediaType = MediaType.parse("application/x-www-form-urlencoded;charset=utf-8");
    RequestBody body = RequestBody.create(mediaType, stringBuilder.toString());

    Request request = new Request.Builder()
            .header("token", getUserToken())
            .header("client", "Android")
            .header("versionCode", getVersionCode())
            .header("versionName", getVersionName())
            .url(url)
            .post(body)
            .build();

    beginRequest(request, listener);
}

//可添加图片文件
public static void postMutibleRequest(String url, final Map&lt;String, Object&gt; params, final OkHttpListener listener) {
    MultipartBody.Builder multipleBuilder = new MultipartBody.Builder();
    multipleBuilder.setType(MultipartBody.FORM);

    if (params != null) {
        Set&lt;String&gt; keys = params.keySet();
        for (String key : keys) {
            Object obj = params.get(key);

            if (obj instanceof File) {
                File tmpFile = (File) obj;
                multipleBuilder.addFormDataPart(key, tmpFile.getName(), MultipartBody.create(MediaType.parse("image/jpg"), tmpFile));
            } else {
                multipleBuilder.addPart(Headers.of("Content-Disposition", "form-data; name=\"" + key + "\""), RequestBody.create(null, (String) obj));
            }
        }
    }

    RequestBody multipleBody = multipleBuilder.build();
    Request request = new Request.Builder()
            .header("token", getUserToken())
            .header("client", "Android")
            .header("versionCode", getVersionCode())
            .header("versionName", getVersionName())
            .url(url)
            .post(multipleBody)
            .build();

    beginRequest(request, listener);
}

//保存网络图片到相册,返回本地存储路径
public static void downloadImageToSysPhoto(String imageUrl, final OkHttpListener listener) {
    Request request = new Request.Builder().url(imageUrl).build();
    Call call = client.newCall(request);
    call.enqueue(new Callback() {
        @Override
        public void onResponse(Call call, Response response) throws IOException {
            try {
                //系统相册路径
                final String localPath = "/storage/emulated/0/DCIM/Camera/" + CommonUtil.getUniqueString(10) + ".jpg";

                InputStream is = response.body().byteStream();
                FileOutputStream fos = new FileOutputStream(localPath);
                byte[] buffer = new byte[1024];

                int len;
                while ((len = is.read(buffer)) != -1) {
                    fos.write(buffer, 0, len);
                }
                is.close();
                fos.close();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.success(localPath);
                        }
                    }
                });
            } catch (Exception e) {
                e.printStackTrace();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.fail(0, "");
                        }
                    }
                });
            }
        }

        @Override
        public void onFailure(Call call, IOException e) {
            mainHandler.post(new Runnable() {
                @Override
                public void run() {
                    if (listener != null) {
                        listener.fail(0, "");
                    }
                }
            });
        }
    });
}

private static void beginRequest(Request request, final OkHttpListener listener) {
    Call call = client.newCall(request);

    call.enqueue(new Callback() {//enqueue是异步请求
        @Override
        public void onResponse(Call call, Response response) throws IOException {
            final String responseString = response.body().string();
            final int code = response.code();

            if (response.isSuccessful()) {
                CommonUtil.logJson(responseString);

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.success(responseString);
                        }
                    }
                });
            } else {
                //请求失败：    400  ---------   {"code":100004,"msg":"手机号已注册"}
                CommonUtil.logString("请求失败：" + code + "---------" + responseString);
                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        if (listener != null) {
                            listener.fail(code, responseString);
                        }
                    }
                });
            }
        }

        @Override
        public void onFailure(Call call, IOException e) {
            e.printStackTrace();
            CommonUtil.logString("请求错误");
            mainHandler.post(new Runnable() {
                @Override
                public void run() {
                    if (listener != null) {
                        listener.fail(0, "请求失败");
                    }
                }
            });
        }
    });
}

public static String getFailedMsg(String response) {
    try {
        JSONObject jsonObject = new JSONObject(response);
        return jsonObject.getString("msg");
    } catch (Exception e) {
        e.printStackTrace();
    }
    return "请求失败";
}

public static String getUserToken() {
    UserModel userModel = UserModel.getUser();
    if (userModel != null) {
        return userModel.getToken();
    }
    return "";
}

public static String getVersionCode() {
    try {
        PackageInfo pi = application.getPackageManager().getPackageInfo(application.getPackageName(), 0);
        return pi.versionCode + "";
    } catch (Exception e) {
        e.printStackTrace();
    }
    return "";
}

public static String getVersionName() {
    try {
        PackageInfo pi = application.getPackageManager().getPackageInfo(application.getPackageName(), 0);
        return pi.versionName;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return "";
}

//下载apk安装包，HUD是自定义的等待进度条
private static int apkProgress;
public static void downloadAPK(final Context context, String apkUrl) {
    HUD.show(context, "下载中...");
    HUD.setCancelable(false);

    Request request = new Request.Builder().url(apkUrl).build();
    Call call = client.newCall(request);
    call.enqueue(new Callback() {
        @Override
        public void onResponse(Call call, Response response) throws IOException {
            try {
                FileUtil.createDir();//创建  ~/paiqi/ 文件夹
                final String apkLocalPath = FileUtil.DIR_PATH + "paiqi.apk";

                InputStream is = response.body().byteStream();
                FileOutputStream fos = new FileOutputStream(apkLocalPath);
                int readNum;
                byte[] buffer = new byte[1024];

                int progressCount = 0;
                long totalLength = response.body().contentLength();

                while ((readNum = is.read(buffer)) != -1) {
                    progressCount += readNum;
                    apkProgress = (int) (((float) progressCount / totalLength) * 100);

                    mainHandler.post(new Runnable() {
                        @Override
                        public void run() {
                            HUD.setMessage("下载中 " + apkProgress + "%");
                        }
                    });

                    fos.write(buffer, 0, readNum);
                }
                is.close();
                fos.close();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        HUD.dismiss();
                        installAPK(context, apkLocalPath);
                    }
                });
            } catch (Exception e) {
                e.printStackTrace();

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        HUD.dismiss();
                        CommonUtil.showToast("下载失败");
                    }
                });
            }
        }

        @Override
        public void onFailure(Call call, IOException e) {
            mainHandler.post(new Runnable() {
                @Override
                public void run() {
                    HUD.dismiss();
                    CommonUtil.showToast("下载失败");
                }
            });
        }
    });
}

//安装apk
private static void installAPK(Context context, String apkPath) {
    File apkFile = new File(apkPath);
    if (!apkFile.exists()) {
        CommonUtil.showToast("安装失败");
        return;
    }
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setDataAndType(Uri.parse("file://" + apkFile.toString()), "application/vnd.android.package-archive");
    context.startActivity(intent);
} 

//请求回调接口定义
public interface OkHttpListener {
   void success(String response);
   void fail(int code,String response);
}
</code></pre>

<p>要注意的是enqueue方法是异步请求，所以要把结果回调放在主线程中进行。</p>

<pre><code> mainHandler.post(new Runnable() {
                        @Override
                        public void run() {
                            if (listener != null) {
                                listener.success(responseString);
                            }
                        }
                    });
</code></pre>

<p>之前看过一个同事的网络库封装，把网络回调接口放在BaseActivity里，然后在子Activity里重写回调方法！这样导致的结果就是，Fragment里的请求都要通过Activity来重写方法，然后再转发给Fragment&hellip;简直想骂街啊有木有！下面这样调用是不是很简单呢~!</p>

<pre><code>//get异步请求,回调都已放在主线程中
 OkHttpHelper.getRequest(ulr, new OkHttpListener() {
        @Override
        public void success(String response) {

        }

        @Override
        public void fail() {

        }
    });

   //post异步请求，回调都已放在主线程中，也可以用于提交File
    Map&lt;String, Object&gt; paramter = new HashMap&lt;&gt;();
    paramter.put("name", "阿贵");
    paramter.put("file", new File("filePath"));//提交图片文件

    OkHttpHelper.postRequest(url, paramter, new OkHttpListener() {
        @Override
        public void success(String response) {

        }

        @Override
        public void fail() {

        }
    });
</code></pre>

<p>还有很多人喜欢把网络请求和结果解析写在一起，比如通过请求结果直接得到对应的Bean。这样导致的结果就是网球请求结果类型不统一，返回各种Bean。个人不太喜欢这样，可以对结果解析进行简单封装一下，这样网络返回的结果也会统一，数据解析也就一行代码。</p>

<pre><code>//使用: getBean(json, User.class);
public static &lt;T&gt; T getBean(String json, Class&lt;T&gt; clazz) {
    T bean = null;
    try {
        Gson gson = new Gson();
        bean = gson.fromJson(json, clazz);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return bean;
}

   //使用：getBeanList(json, User[].class);
    public static &lt;T&gt; List&lt;T&gt; getBeanList(String json, Class&lt;T[]&gt; type) {
        try{
            T[] list = new Gson().fromJson(json, type);
            return Arrays.asList(list);
        }catch (Exception e){
            e.printStackTrace();
            return null;
        }
    }
</code></pre>

<h4>Retrofit</h4>

<p><a href="http://square.github.io/retrofit/">Retrofit官网</a>上的例子中返回结果是Bean，但又没说添加了GsonConverterFactory，所以会报 Could not locate ResponseBody converter for XXBean 错误！所以要引入GsonConverterFactory转化库<code>compile 'com.squareup.retrofit2:converter-gson:2.0.2'</code>, 然后在Retrofit初始化的时候添加该库！官网后面说了 By default, Retrofit can only deserialize HTTP bodies into OkHttp&rsquo;s ResponseBody type and it can only accept its RequestBody type for @Body. 默认只会返回ResponseBody！并且只有ResponseBody才可以使用@Body注解！我个人还是不喜欢直接在这里得到Bean, 我还是喜欢先通过得到response.body().string()，然后再转化成Bean，各司其职。注意是<code>response.body().string()</code>，不是<code>response.body().toString()</code>!!</p>

<pre><code>    Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://api.github.com/")
                .addConverterFactory(GsonConverterFactory.create()) //添加Bean转化库
                .build();

    ServiceInterface service = retrofit.create(ServiceInterface.class);

    Call&lt;TestBean&gt; requestCall = service.getUserInfo();

    requestCall.enqueue(new Callback&lt;TestBean&gt;() {
        @Override
        public void onResponse(Call&lt;TestBean&gt; call, Response&lt;TestBean&gt; response) {

                TestBean b = response.body();
        }

        @Override
        public void onFailure(Call&lt;TestBean&gt; call, Throwable t) {

        }
    });

 public interface ServiceInterface {
    @GET("users/andyfightting")
    Call&lt;TestBean&gt; getUserInfo();

    //这里继续添加其他接口

}
</code></pre>
]]></content>
  </entry>
  
</feed>
