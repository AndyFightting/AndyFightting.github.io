
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>阿贵</title>
  <meta name="author" content="guimingsu">

  
  <meta name="description" content="React Native Navigator Dec 1st, 2016 9:27 am 这里主要记录一下Navigator的基本使用，页面间的传参，回调，以及在push,pop过程中生命周期方法的调用顺序。 React 的“页面”的概念和Android或iOS有点不一样， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://andyfightting.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="阿贵" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">  -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

<script>
  function addBlankTargetForLinks () {
    $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
    });
  }
  $(document).bind('DOMNodeInserted', function(event) {
    addBlankTargetForLinks();
  });
</script>
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">阿贵</a></h1>
  
    <h2>All growth is a leap in the dark.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="andyfightting.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li> 
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/12/01/react-navigator/">React Native Navigator</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-12-01T09:27:30+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>9:27 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这里主要记录一下Navigator的基本使用，页面间的传参，回调，以及在push,pop过程中生命周期方法的调用顺序。</p>

<p>React 的“页面”的概念和Android或iOS有点不一样，不像Android有个Activity作为页面容器，iOS有Controller作为页面容器。React 的“页面”本身就是一个组件集合，和Text,Image等基础组件是一个级别的东西。只不过是把多个组件拼起来充满屏幕，就组成一个“页面”了。</p>

<p>通过在Navigator的route里放置一个params参数，params里面放key-value传参。注意，方法也是对象，也可以当做value传递，这样就可回调了。就像Android的接口回调或iOS的block似的，在A页面实现方法，然后传递给B页面，在B页面使用方法，这样数据就从B回传给A了。数据从方法使用的地方传到方法实现的地方。</p>

<h4>在Index.js里初始化Navigator并且显示第一个页面FirstView:</h4>

<p><img src="/myimg/java/lift0.png" width="500" alt="" /></p>

<h4>从FirstView push 到SecondView</h4>

<p><img src="/myimg/java/lift1.png" width="500" alt="" /></p>

<h4>不调用FirstView的回调方法直接pop。</h4>

<p><img src="/myimg/java/life3.png" width="500" alt="" /></p>

<h4>如果在SecondView里点击返回的时候，先掉用FirstView的回调方法, 在回调方法里调用 setState() 刷新FirstView，然后 pop 。</h4>

<p><img src="/myimg/java/lift2.png" width="500" alt="" /></p>

<p>从上面可以看出不管是从A到B还是从B返回A,A的componentWillReceiveProps都会被调用! A的更新流程都会先走一遍！</p>

<p><img src="/myimg/java/life4.png" width="600" alt="" /></p>

<pre><code>configureScene 属性用来配置场景动画。
configureScene={(route, routeStack) =&gt; {
                return Navigator.SceneConfigs.PushFromRight;
              }}
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>在/node_modules/react-native/Libraries/CustomComponents/Navigator/NavigatorSceneConfigs 中预设了很多转场动画。
</span><span class='line'>PushFromRight
</span><span class='line'>PushFromLeft
</span><span class='line'>FloatFromRight // We will want to customize this soon
</span><span class='line'>FloatFromLeft
</span><span class='line'>FloatFromBottom
</span><span class='line'>FloatFromBottomAndroid
</span><span class='line'>FadeAndroid
</span><span class='line'>HorizontalSwipeJump
</span><span class='line'>HorizontalSwipeJumpFromRight
</span><span class='line'>HorizontalSwipeJumpFromLeft
</span><span class='line'>VerticalUpSwipeJump
</span><span class='line'>VerticalDownSwipeJump</span></code></pre></td></tr></table></div></figure>


<h4>其他方法</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>getCurrentRoutes() - 获取当前栈里的所有路由
</span><span class='line'>jumpBack() - 跳回之前的路由，还保留现在的，还可以再跳回来，会保留原样
</span><span class='line'>jumpForward() - 与上一个方法对应
</span><span class='line'>jumpTo(route) - 跳转到已有的场景并且不卸载
</span><span class='line'>push(route) - 跳转到新的场景，并且将场景入栈
</span><span class='line'>pop() - 跳转回去并且卸载掉当前场景
</span><span class='line'>replace(route) - 用一个新的路由替换掉当前场景
</span><span class='line'>replaceAtIndex(route, index) - 替换掉指定序列的路由场景
</span><span class='line'>replacePrevious(route) - 替换掉之前的场景
</span><span class='line'>resetTo(route) - 跳转到新的场景，并且重置整个路由栈
</span><span class='line'>immediatelyResetRouteStack(routeStack) - 用新的路由数组来重置路由栈
</span><span class='line'>popToRoute(route) - pop到路由指定的场景，在整个路由栈中，处于指定场景之后的场景将会被卸载
</span><span class='line'>popToTop() - pop到栈中的第一个场景，卸载掉所有的其他场景</span></code></pre></td></tr></table></div></figure>


<h4>index.ios.js</h4>

<pre><code>import React, {Component} from 'react';
import {View,Navigator,AppRegistry} from 'react-native';
import FirstView from './FirstView';

   var logName = 'Index:--------';

   export default class BaseNavigator extends Component {
     constructor(props){
          console.log(logName + 'constructor');
          super(props);
      }
      componentWillMount(){
          console.log(logName + 'componentWillMount');
      }
       render() {
         console.log(logName+'render')
        return (
        &lt;Navigator
          //把下面一行的/都去掉，因为Markdown转化不了所以加的
          initialRoute=/{/{params: /{/},view: FirstView /}/}
          renderScene={(route, navigator) =&gt; {
            let ShowedView = route.view;
            return &lt;ShowedView {...route.params} nav={navigator} /&gt;
          }} /&gt;
        );
       }

       componentDidMount() {
           console.log(logName + 'componentDidMount');
       }

       componentWillReceiveProps(nextprops){
              console.log(logName + 'componentWillReceiveProps');
        }
        shouldComponentUpdate(nextProps,nextState){
              console.log(logName + 'shouldComponentUpdate');
            return true;
        }
        componentWillUpdate(nextProps,nextState){
              console.log(logName + 'componentWillUpdate');
        }
        componentDidUpdate(prevProps,prevState){
            console.log(logName + 'componentDidUpdate');
        }
        componentWillUnmount(){
            console.log(logName + 'componentWillUnmount');
        }
   }
AppRegistry.registerComponent('MyReact', () =&gt; BaseNavigator);
</code></pre>

<h4>FirstView.js</h4>

<pre><code>import React,{Component} from 'react';
import {View,StyleSheet,Text} from 'react-native';
import SecondView from './SecondView';

var logName = 'FirstView:--------';
export default class FirstView extends Component { 
  constructor(props) {
    console.log(logName + 'constructor');
        super(props);
        this.state = {
            callBackMsg: '',
        };
    }
   componentWillMount(){
       console.log(logName + 'componentWillMount');
   }

    render() {
      console.log(logName+'render')
        return (
            &lt;View style={styles.backView}&gt;
                  &lt;Text style={styles.tapView}  onPress={this.pressedFun.bind(this)}&gt;点击跳转&lt;/Text&gt;
                  &lt;Text style={styles.msgView}&gt;
                    {this.state.callBackMsg}
                  &lt;/Text&gt;
            &lt;/View&gt;
        );
    }
    componentDidMount() {
        console.log(logName + 'componentDidMount');
    }

    componentWillReceiveProps(nextprops){
           console.log(logName + 'componentWillReceiveProps');
     }
     shouldComponentUpdate(nextProps,nextState){
           console.log(logName + 'shouldComponentUpdate');
         return true;
     }
     componentWillUpdate(nextProps,nextState){
           console.log(logName + 'componentWillUpdate');
     }
     componentDidUpdate(prevProps,prevState){
         console.log(logName + 'componentDidUpdate');
     }
     componentWillUnmount(){
         console.log(logName + 'componentWillUnmount');
     }
//-------个人方法--------
    pressedFun() {
        let nav = this.props.nav;
        let tmpThis = this;
            nav.push({
                view: SecondView,
                params:{
                  userId: 123,
                  userName: 'andy',
                  callBackFun: function(newMsg){
                      tmpThis.setState({
                        callBackMsg: newMsg,
                      })
                  },
                },
            });
          }
}

const styles = StyleSheet.create({
  backView:{
    flex: 1,
    justifyContent: 'center',
    backgroundColor: 'azure',
  },
  tapView:{
    fontSize: 20,
    alignSelf: 'center',
    textAlign: 'center',
    width: 130,
    height: 50,
    lineHeight: 50,
    color: 'yellow',
    borderColor: 'yellow',
    borderWidth: 2,
    borderRadius: 25,
    backgroundColor: 'blue',
    overflow: 'hidden',//不然边角会有背景色
  },
  msgView:{
    fontSize: 16,
    marginTop: 30,
    textAlign: 'center',
  },
});
</code></pre>

<h4>SecondView.js</h4>

<pre><code>import React,{Component} from 'react';
import {View,Navigator,StyleSheet,TouchableWithoutFeedback,Image,Text,} from 'react-native';

var logName = 'SecondView:--------';
export default class SecondView extends Component {
  static defaultProps = {
      // testProp: 'testProp默认值',
  }
  static propTypes = {
      // testProp: React.PropTypes.string.isRequired,
  }
  constructor(props) {
        console.log(logName + 'constructor');
        super(props);
        this.state = {};
    }
    componentWillMount(){
        console.log(logName + 'componentWillMount');
    }
    render() {
      console.log(logName+'render')
       return (
            &lt;View style={styles.backView}&gt;
              &lt;View style={styles.titleBackView}&gt;
              &lt;TouchableWithoutFeedback onPress={this.backPressed.bind(this)}&gt;
                 &lt;Image style={styles.backImage} source= {require('./images/backImage.png')}/&gt;
              &lt;/TouchableWithoutFeedback&gt;
                &lt;Text style={styles.titleView}&gt;标题&lt;/Text&gt;
              &lt;/View&gt;
                &lt;Text&gt;上个页面传来的参数userId: {this.props.userId}&lt;/Text&gt;
                &lt;Text&gt;上个页面传来的参数userName: {this.props.userName}&lt;/Text&gt;
            &lt;/View&gt;
        );
    }
    componentDidMount() {
        console.log(logName + 'componentDidMount');
    }

    componentWillReceiveProps(nextprops){
           console.log(logName + 'componentWillReceiveProps');
     }
     shouldComponentUpdate(nextProps,nextState){
           console.log(logName + 'shouldComponentUpdate');
         return true;
     }
     componentWillUpdate(nextProps,nextState){
           console.log(logName + 'componentWillUpdate');
     }
     componentDidUpdate(prevProps,prevState){
         console.log(logName + 'componentDidUpdate');
     }
     componentWillUnmount(){
         console.log(logName + 'componentWillUnmount');
     }

//------个人方法--------
     backPressed() {
         let nav = this.props.nav;
             this.props.callBackFun('这是消失的页面通过回调方法传来的数据！');
             nav.pop();
     }
}
const styles = StyleSheet.create({
  backView:{
    flex: 1,
    backgroundColor: 'bisque',
  },
  titleBackView:{
    height: 65,
    backgroundColor: 'darkkhaki',
    flexDirection: 'row'
  },
  titleView:{
    height:45,
    lineHeight:45,
    marginTop:20,
    color: 'white',
    fontSize: 18,
    textAlign: 'center',
    alignSelf: 'center',
    flex: 1,
    marginRight:20,
  },
  backImage:{
    marginTop:35,
    marginLeft:10,
    width: 10,
    height: 20,
  },
});
</code></pre>
</div>
  
  


      | <a href="/blog/2016/12/01/react-navigator/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/30/react-native-life/">React Native 组件生命周期</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-30T11:08:59+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:08 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>生命周期就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期是开发的基础。ES5语法和ES6语法有所变化，在ES5语法中，有getDefaultPropTypes方法，这个方法在组件被创建时调用一次，它的返回值成为了this.props的初始值。而ES6语法中，属性的类型和默认值声明不像ES5语法那样在组件定义内部声明,而是在组件定义的外部声明，所以没有了getDefaultPropTypes方法.</p>

<p><img src="/myimg/java/life2.png" alt="" /></p>

<h4>可以把组件生命周期大致分为三个阶段：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化；
</span><span class='line'>第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互接收事件更新界面；
</span><span class='line'>第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。</span></code></pre></td></tr></table></div></figure>


<p><strong>constructor(props) :</strong>这个方法会在组件创建的时候调用一次。 这个方法中可以通过this.state初始化状态参数，ES5是通过getInitialState()方法初始化的。</p>

<p><strong>getDefaultProps() :</strong>在组件类创建的时候调用一次，然后返回值被缓存下来。全局调用一次，所有实例共享。</p>

<p><strong>getInitialState() :</strong>在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。</p>

<p><strong>componentWillMount() :</strong>在组件创建并初始化了状态之后，在第一次 render() 之前。可以在这里做一些初始化操作。这个函数在整个生命周期中只被调用一次。</p>

<p><strong>render() :</strong>这个方法是必须的，对视图进行渲染，也可以返回 null 或者 false 来表明不需要渲染任何东西.</p>

<p><strong>componentDidMount() :</strong>在组件第一次绘制之后，会调用该方法通知组件已经加载完成。这个方法调用的时候，其虚拟 DOM 已经构建完成，可以在这个函数里获取其中的元素或者子组件。框架是先调用子组件的该方法，然后再调用父组件的。可以在这里发起网络请求等。</p>

<p><strong>componentWillReceiveProps(nextProps) :</strong> 父组件改变子组件的属性的时候会调用该方法,初次渲染时不会调用该方法。参数nextProps是即将被设置的属性，旧的属性还是可以通过 this.props 来获取。</p>

<p><strong>shouldComponentUpdate(nextProps,nextState) :</strong>当组件接收到新的属性或状态改变的话会调用该方法。参数 nextProps 和上面的方法一样。nextState 表示组件即将更新的状态值。这个方法的返回值决定是否需要更新组件，默认返回true。可以重载这个函数来决定组件是否需要更新。</p>

<p><strong>componentWillUpdate(nextProps,nextState) :</strong>如果组件状态改变，并且上面的方法返回为true，就会开始准更新组件。这里可以做一些在更新组件之前要做的事情。<strong>在这个方法里面不能再调用 this.setState 来修改状态</strong>。这个方法调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着就会调用 render() 来更新组件了。</p>

<p><strong>componentDidUpdate(prevProps,prevState) :</strong>在调用了 render() 更新组件同步到 DOM 中之后立刻调用该方法。因为到这里已经完成了属性和状态的更新了，此方法的参数变成了 prevProps 和 prevState。</p>

<p><strong>componentWillUnmount() :</strong>当组件从 DOM 中移除的时候就会调用该方法。可以这个方法中做一些资源清理工作。</p>

<p><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5 ES6写法对照表</a></p>

<p><a href="http://blog.kdchang.cc/2016/04/04/react-react-native-es5-es6-cheat-sheet/">ES5 ES6区别</a></p>

<p><a href="https://babeljs.io/blog/2015/06/07/react-on-es6-plus">React on ES6</a></p>

<p><a href="http://egorsmirnov.me/2015/06/14/react-and-es6-part2.html">React and ES6</a></p>
</div>
  
  


      | <a href="/blog/2016/11/30/react-native-life/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/30/css-flex-box/">Flexbox 布局</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-30T08:56:06+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>8:56 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>弹性盒子布局由弹性容器和弹性子item组成。容器默认存在两根轴：水平的主轴和垂直的交叉轴。主轴的开始位置叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。item默认沿主轴排列。item占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size
<img src="/myimg/java/flexbox.png" width="600" alt="" /></p>

<p><strong>用在容器上的属性：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>flex-direction :决定item的排列方向。(row,row-reverse,column,column-reverse)
</span><span class='line'>flex-wrap :决定item如何换行。(nowrap,wrap,wrap-reverse)
</span><span class='line'>justify-content :决定itme在主轴上的对齐方式。(flex-start,flex-end,center,space-between,space-around)
</span><span class='line'>align-items :决定item在交叉轴上的对齐方式。(stretch,flex-start,flex-end,center,baseline:item第一行文字基线对齐)
</span><span class='line'>align-content :决定多条交叉轴线的对齐方式。(flex-start,flex-end,center,space-between,space-around,stretch)</span></code></pre></td></tr></table></div></figure>


<p>align-content:</p>

<p><img src="/myimg/java/flex1.png" width="400" alt="" /></p>

<p><strong>用在Item上的属性</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>order :定义item的排列顺序。数值越小，排列越靠前，默认为0。
</span><span class='line'>flex-grow :定义item的放大比例。默认为0，即如果存在剩余空间也不放大。有多个的话按比例均分。
</span><span class='line'>flex-shrink :定义item的缩小比例。默认为1，即如果空间不足，该项目将缩小。0则不缩小。
</span><span class='line'>flex-basis :定义了在分配多余空间之前，item占据的主轴空间,默认auto,即本来大小。
</span><span class='line'>flex : flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。
</span><span class='line'>align-self :设置item自身在交叉轴上的对齐方式。可覆盖align-items属性。
</span><span class='line'>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
</span><span class='line'>(auto,flex-start,flex-end,center,baseline,stretch)</span></code></pre></td></tr></table></div></figure>


<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，也有些差异:flexDirection的默认值是column而不是row，alignItems的默认值是stretch而不是flex-start。使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求。</p>

<p><code>flexDirection</code>: 决定布局的主轴。子元素是沿着水平轴方向排列，还是沿着竖直轴方向排列。</p>

<p><code>justifyContent</code>: 决定子元素沿着主轴的排列方式。有flex-start、center、flex-end、space-around 和 space-between。</p>

<p><code>alignItems</code>: 决定其子元素沿着交叉轴的排列方式。有flex-start、center、flex-end以及stretch。<strong>注意：要使stretch选项生效的话，子元素在次轴方向上不能固定尺寸。</strong></p>

<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Fexbox布局实例</a></p>
</div>
  
  


      | <a href="/blog/2016/11/30/css-flex-box/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/29/rn-style/">React Native 样式属性</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-29T22:27:51+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:27 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>React Native 采用CSS样式来布局，也会有继承和覆盖作用。只要在样式表中书写一个不存在的样式，就会报错，提示该样式不存在，然后提供所有可用的样式：
<img src="/myimg/java/style.png" alt="" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//边框
</span><span class='line'>borderBottomWidth 
</span><span class='line'>borderLeftWidth 
</span><span class='line'>borderRightWidth 
</span><span class='line'>borderTopWidth 
</span><span class='line'>borderWidth </span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//边框颜色
</span><span class='line'>borderBottomColor
</span><span class='line'>borderLeftColor
</span><span class='line'>borderRightColor
</span><span class='line'>borderTopColor
</span><span class='line'>borderColor</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//外边距
</span><span class='line'>marginTop
</span><span class='line'>marginBottom
</span><span class='line'>marginLeft
</span><span class='line'>marginRight
</span><span class='line'>marginVertical //相当于marginTop 和 marginBottom
</span><span class='line'>marginHorizontal //相当于 marginLeft 和 marginRight
</span><span class='line'>margin</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//内边距  
</span><span class='line'>paddingTop  
</span><span class='line'>paddingBottom
</span><span class='line'>paddingLeft  
</span><span class='line'>paddingRight  
</span><span class='line'>paddingVertical //相当于 paddingTop 和 paddingBottom
</span><span class='line'>paddingHorizontal  //相当于 paddingLeft 和 paddingRight
</span><span class='line'>padding </span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//边框圆角
</span><span class='line'>borderTopLeftRadius
</span><span class='line'>borderTopRightRadius
</span><span class='line'>borderBottomLeftRadius
</span><span class='line'>borderBottomRightRadius
</span><span class='line'>borderRadius</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//flex 布局
</span><span class='line'>flex number 
</span><span class='line'>flexDirection enum('row', 'column') 
</span><span class='line'>flexWrap enum('wrap', 'nowrap') 
</span><span class='line'>alignItems enum('flex-start', 'flex-end', 'center', 'stretch') 
</span><span class='line'>alignSelf enum('auto', 'flex-start', 'flex-end', 'center', 'stretch') 
</span><span class='line'>justifyContent enum('flex-start', 'flex-end', 'center', 'space-between', 'space-around') 
</span><span class='line'>position属性值为absolute和relative，当使用绝对布局时，定位根据屏幕来进行。</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//字体相关属性
</span><span class='line'>color 字体颜色
</span><span class='line'>fontFamily 字体族
</span><span class='line'>fontSize 字体大小
</span><span class='line'>fontStyle 字体样式，正常，倾斜等，值为enum('normal', 'italic')
</span><span class='line'>fontWeight 字体粗细，值为enum("normal", 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900')
</span><span class='line'>letterSpacing 字符间隔
</span><span class='line'>lineHeight 行高
</span><span class='line'>textAlign 字体对齐方式，值为enum("auto", 'left', 'right', 'center', 'justify')
</span><span class='line'>textDecorationLine 上划线，下划线，删除线，无修饰，值为enum("none", 'underline', 'line-through', 'underline line-through')
</span><span class='line'>textDecorationStyle 修饰的线的类型 enum("solid", 'double', 'dotted', 'dashed')
</span><span class='line'>textDecorationColor 修饰的线的颜色
</span><span class='line'>writingDirection enum("auto", 'ltr', 'rtl') 书写方向，从左往右写还是从右往左写</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//图片相关属性
</span><span class='line'>resizeMode enum('cover', 'contain', 'stretch')
</span><span class='line'>overflow enum('visible', 'hidden') 超出部分是否显示，hidden为隐藏
</span><span class='line'>tintColor 着色，rgb字符串类型
</span><span class='line'>opacity 透明度
</span><span class='line'>scaleX:水平方向缩放
</span><span class='line'>scaleY:垂直方向缩放
</span><span class='line'>rotation:旋转
</span><span class='line'>translateX:水平方向平移
</span><span class='line'>translateY:水平方向平移
</span><span class='line'>//阴影,默认透明的，要设置shadowOpacity大于0才有效果
</span><span class='line'>shadowColor
</span><span class='line'>shadowOffset
</span><span class='line'>shadowOpacity
</span><span class='line'>shadowRadius</span></code></pre></td></tr></table></div></figure>



</div>
  
  


      | <a href="/blog/2016/11/29/rn-style/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/28/react-native-run-bug/">React Native 问题汇总</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-28T18:46:09+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:46 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Android 设备:小米 red note MUI 8.0, iOS 设备:iPhone 6Plus 8.3</p>

<h5>1.运行不起来</h5>

<p>按照<a href="https://facebook.github.io/react-native/docs/getting-started.html#content">官网</a>的步骤一步一步下来运行报：</p>

<pre><code>com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Failed to establish session
</code></pre>

<p><a href="https://github.com/facebook/react-native/issues/6499">这里</a>说小米系列的手机都这样，我们平时用Android Studio调试运行不是会弹出个弹出框问是否安装吗？这是用USB链接的，所以没问题，但是用命令就掉动不起来那弹出框&hellip;
<img src="/myimg/java/react_error_xm0.png" alt="" /></p>

<p>解决办法如下，关键是第4步，关闭小米的优化
<img src="/myimg/java/react_error_xm1.png" alt="" /></p>

<h5>2.运行不起来</h5>

<p>报错：</p>

<pre><code>com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: Unable to upload some APKs
</code></pre>

<p>解决：把 /项目/android/build.gradle 文件里的 <code>classpath 'com.android.tools.build:gradle:1.3.1'</code> 改成 <code>classpath 'com.android.tools.build:gradle:1.2.3'</code>就可以了&hellip;.why? yeah,why?</p>

<h5>3.白屏</h5>

<p>运行起来了，等啊等，怎么还是白屏？不是有东西的吗？摇啊摇不是有弹出框的吗？弹出框呢？？</p>

<p>解决：进系统设置，应用管理，找到这个应用，点击应用详情里的权限管理，开启显示悬浮框。刷新一下再摇一摇就有弹出框了。</p>

<h5>4.Could not connect to development server</h5>

<p>摇啊摇弹出框后，点击最后的 <code>Dev Settings</code> ，然后设置 <code>Debug server host &amp; port for device</code> 为<code>本机IP:8081</code>后返回刷新出现如下错误:</p>

<p><img src="/myimg/java/react_error2.png" alt="" /></p>

<p>解决：命令行进入项目文件夹，运行如下命令：</p>

<pre><code>react-native start &gt; /dev/null 2&gt;&amp;1 &amp; curl "http://localhost:8081/index.android.bundle?platform=android" -o "android/app/src/main/assets/index.android.bundle"
</code></pre>

<p>如果提示没有 assets 文件夹，则先手动建一个再运行。之后就能真机运行起来了：</p>

<p><img src="/myimg/java/react_android.png" alt="" /></p>

<h5>iOS模拟器Cmd+R不刷新，Cmd+D也没弹出框</h5>

<p>解决：要开启模拟器的键盘链接。模拟器菜单<code>Hardware</code>-><code>Keyboard</code> 选中 <code>Connect Hardware Keyboard</code></p>
</div>
  
  


      | <a href="/blog/2016/11/28/react-native-run-bug/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/26/react-native-basic/">React Native 基础知识</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-26T11:16:25+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>11:16 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>React 的核心思想是：封装组件! React 应用都是构建在组件之上，各个组件维护自己的状态和 UI，当状态变更，自动重新渲染自身组件。组件的第一个字母必须大写,组件只能包含一个顶层标签。</h4>

<h4>Declarative</h4>

<p><a href="https://facebook.github.io/react/">React</a> 可以很好的创建交互式组件，设计不同状态下的组件，并且React可以根据组件的不同参数高效的刷新渲染。这样的组件可以让你的代码更加的可预测并且更方便调试。</p>

<h4>Component-Based</h4>

<p>基于组件，封装一个组件，让它们管理自己的状态，然后用它们去组成更加复杂的UI。由于组件的逻辑是写在JavaScript里的而不是模板里，这样你可以很轻松的让它穿梭于复杂的数据之间，并且在DOM外保持自己的状态。</p>

<h4>Learn Once, Write Anywhere</h4>

<p>我们不假定你现在的技术栈是怎样的，所以你可以不用重写已存在的代码来用React开放新的功能。React也可以在服务器端渲染，也可以用React Native创建强大的移动应用。</p>

<h4>A Simple Component</h4>

<p>React 组件调用 <code>render()</code> 方法来输入参数然后返回要显示的样子。这个例子用一个类似XML语言的我们称之为JSX，通过<code>this.props</code>输入数据传到组件内部可以被<code>render()</code>方法获取。使用React的话，JSX是可选的，不是必须要使用的。试着点击<code>Complied JS</code>去看看通过JSX编译器产生的原生的JavaScript 代码。</p>

<h4>A Stateful Component</h4>

<p>除了通过<code>this.props</code>来传入参数，组件可以通过<code>this.state</code>来维护自己内部状态的数据。当组件的状态数据改变时，渲染器就会重新调用<code>render()</code>方法来刷新。</p>

<h4>An Application</h4>

<p>使用<code>props</code>和<code>state</code>我们可以收集一个小型的代办事项申请。这个例子用<code>state</code>来跟踪当前列表和用户输入的数据。虽然事件处理程序似乎是呈现内联,他们会通过事件代理被收集和使用。</p>

<h4>A Component Using External Plugins</h4>

<p>React 是灵活的，并且提供了一个钩子来和库或框架进行链接。这个例子使用<code>remarkable</code>,一个外部的 Markdown 库，来实时转化文本内容。</p>

<p>哎呀~ 自己翻译果然别扭&hellip;😞  React 是什么呢？React 是Facebook 封装的一组JS代码库：</p>

<p><img src="/myimg/java/react.png" alt="" /></p>

<p>按它规则可封装一个一个模块组件，这个模块组件有自己的状态，自己的逻辑等，它是一个独立的东西，然后把这样的组件一个一个组合起来。按照React 的规则可以混合着写JavaScript和HTML,这样的一个组件就是一个独立的模块化的View。添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。</p>

<p>React 还封装了一个自己的虚拟的DOM，通过这个Virtual DOM去更新真实的DOM，由这个Virtual DOM管理真实DOM的更新。因为如果大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个虚拟 DOM，组件 DOM 结构就是映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 <a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html">diff</a> 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性。给组件设置一个 <code>ref</code> 属性，然后用 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点对象。</p>

<h4>Hello World</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;

    &lt;script type="text/babel"&gt;
    var MyComponent = React.createClass({
      render: function() {
        return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;
      }
    });

    ReactDOM.render(&lt;MyComponent name="World !" /&gt;,
                    document.getElementById('example') );
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>上面的代码中用React的语法自定义了一个组件叫<code>MyComponent</code>,这个组件返回一个块区间，里面显示 Hello + 这个组件的<code>name</code>属性值。注意script 的type 要声明为<code>text/babel</code>。这样就可以在其他地方使用这个自定义的组件了。可以把 <code>props</code> 看作是组件的配置属性，在组件内部是不变的，只是在调用这个组件的时候传入不同的属性值来定制显示这个组件。当组件状态 <code>state</code> 有更改的时候，React 会自动调用组件的 <code>render()</code> 方法重新渲染整个组件的 UI。<code>this.props</code> 对象的属性与组件的属性一一对应，<code>this.props.children</code> 表示组件的所有子节点。需要注意， <code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 <code>this.props.children</code> 的时候要小心。上面的代码把 HTML 直接嵌入了 JS 代码里面了，这就是 React 提出的一种叫 JSX 的语法。把原来网页设计的代码分离，现在又融合了！</p>

<p><img src="/myimg/java/react_hello.png" alt="" /></p>

<p>Hello World 运行起来了！嗯~ 我已经成功了一半！😆</p>

<h4>组件组合</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;

    &lt;script type="text/babel"&gt;

    var Avatar = React.createClass({
        render: function() {
            return (
                &lt;div&gt;
                    &lt;ProfilePic username={this.props.username} /&gt;
                    &lt;ProfileName username={this.props.username} /&gt;
                &lt;/div&gt;
            );
        }
       });

    var ProfilePic = React.createClass({
        render: function() {
            return (
                &lt;img src={'https://gss0.bdstatic.com/70cFsj3f_gcX8t7mm9GUKT-xh_/avatar/100/r6s1g6.gif'} /&gt;
            );
        }
    });

    var ProfileName = React.createClass({
        render: function() {
            return (
              &lt;div&gt;
                &lt;a href={'http://guimingsu.com'}&gt;
                    {this.props.username}
                &lt;/a&gt;
              &lt;/div&gt;
            );
        }
    });

    ReactDOM.render(
        &lt;Avatar username="hello world " /&gt;,
        document.getElementById('example')
      );

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这里显示了一个Avatar 组件，这个Avatar 组件是由两个更小的组件ProfilePic和ProfileName组合而成的。父组件和子组件间可以通过<code>props</code>一层一层的传值。Remember: React is all about one-way data flow down the component hierarchy.</p>

<p><img src="/myimg/java/react_hello0.png" alt="" /></p>

<h4>状态变化</h4>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src="../build/react.js"&gt;&lt;/script&gt;
    &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="example"&gt;&lt;/div&gt;
    &lt;script type="text/babel"&gt;

     var LikeButton = React.createClass({
      getInitialState: function() {
        return {liked: false};
      },

      handleClick: function(event) {
        this.setState({liked: !this.state.liked});
      },

      render: function() {
        var text = this.state.liked ? 'like' : 'haven\'t liked';
        return (
          &lt;p onClick={this.handleClick}&gt;
            You {text} this. Click to toggle.
          &lt;/p&gt;
        );
      }
    });

    ReactDOM.render(
      &lt;LikeButton /&gt;,
      document.getElementById('example')
    );

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>上面代码是一个 <code>LikeButton</code> 组件，它的 <code>getInitialState</code> 方法用于定义初始状态，也就是一个对象，这个对象可以通过 <code>this.state</code> 属性读取。当用户点击组件，导致状态变化，<code>this.setState</code> 方法就修改状态值，每次修改以后，自动调用 <code>this.render</code> 方法，再次渲染组件。
由于 <code>this.props</code> 和 <code>this.state</code> 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，<code>this.props</code> 表示那些一旦定义，就不再改变的特性，而 <code>this.state</code> 是会随着用户互动而产生变化的特性。即把要跟随某个参数实时变化的代码写在 <code>render: function() {};</code>里，然后在用户调用的方法里调用<code>this.setState({ });</code>方法来改变参数就可以了，因为他们触发<code>render</code>方法。这样就可以根据不同参数值自动显示不同内容。</p>

<h4>生命周期</h4>

<p>组件的生命周期分成三个状态：</p>

<ol>
<li>Mounting：已插入真实 DOM</li>
<li>Updating：正在被重新渲染</li>
<li>Unmounting：已移出真实 DOM</li>
</ol>


<p>React 为每个状态都提供了两种处理函数，<code>will</code> 函数在进入状态之前调用，<code>did</code> 函数在进入状态之后调用，三种状态共计五种处理函数。</p>

<ol>
<li>componentWillMount()</li>
<li>componentDidMount()</li>
<li>componentWillUpdate(object nextProps, object nextState)</li>
<li>componentDidUpdate(object prevProps, object prevState)</li>
<li>componentWillUnmount()</li>
</ol>


<p>此外，React 还提供两种特殊状态的处理函数:</p>

<ol>
<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</li>
<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用</li>
</ol>


<p><img src="/myimg/java/react_life.png" alt="" /></p>

<p>把这个<a href="https://facebook.github.io/react/docs/thinking-in-react.html">官方例子</a>看完就能收获不少了。主要在于思考，拿到设计图如何拆分模块，如何组建，如何选取放置状态参数，如何看懂别人写好的代码等。<a href="/mysrc/java/reactPriceDemo.zip">下载</a></p>

<h5>链接</h5>

<ol>
<li><a href="http://www.cnblogs.com/sakurayeah/category/868210.html">React入门</a></li>
<li><a href="https://babeljs.io/docs/learn-es2015/">ECMAScript 2015</a></li>
<li><a href="http://es6.ruanyifeng.com/">ECMAScript 6入门</a></li>
<li><a href="http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8">ES5和ES6的写法对照表</a></li>
</ol>

</div>
  
  


      | <a href="/blog/2016/11/26/react-native-basic/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/24/atom-edit/">Atom</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-24T14:31:17+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>2:31 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://atom.io/">Atom</a>是由GitHub开发的一款免费开源的编辑器，通过给它安装不同的插件包，就可以变成一款智能的IDE了。这里主要记录一下为了开发<a href="https://facebook.github.io/react-native/">React Native</a>所安装的插件包及基本使用。</p>

<p><a href="https://nuclide.io/">Nuclide</a>是官方推荐的开发React Native的基于Atom的工具。Nuclide 安装好后进入设置，选中<code>Install Recommented Packages on Startup</code>选项，下次启动的时候就会安装Nuclide所建议安装的插件了。</p>

<h4>插件</h4>

<p><strong>atom-react-native-autocomplete :</strong>React Native自动提示。</p>

<p><strong>atom-beautify :</strong> 文件排版格式化。ctrl-alt-b，可以进它的设置里选中 Beauty on Save 自动格式化。</p>

<p><strong>atom-html-preview :</strong> html预览。 ctrl-shift-h
<img src="/myimg/java/atom-html-preview.png" width="700" alt="" /></p>

<p><strong>autocomplete-paths :</strong> 文件路径提示</p>

<p><img src="/myimg/java/autocomplete-paths.png" width="500" alt="" /></p>

<p><strong>color-picker :</strong>颜色选取器，点击色块即可弹出，或者右键选择 Color Picker.</p>

<p><img src="/myimg/java/color-picker.png" width="500" alt="" /></p>

<p><strong>docblockr :</strong> 快捷文档注释</p>

<p><strong>emmet :</strong>web开发神器</p>

<p><strong>file-icons :</strong>给文件加icon</p>

<p><img src="/myimg/java/file-icons.png" width="200" alt="" /></p>

<p><strong>highlight-selected :</strong>选中相同的字符串高亮
<img src="/myimg/java/highlight-selected.png" width="500" alt="" /></p>

<p><strong>js-hyperclick :</strong> js对象 cmd-点击 跳转</p>

<p><strong>merge-conflicts :</strong>解决版本冲突</p>

<p><strong>minimap :</strong>右边位置小地图
<img src="/myimg/java/minimap.png" width="700" alt="" /></p>

<p><strong>pigments :</strong> 显示颜色。 快捷面板里搜 Pigments: Show Palette 可以打开调色板🎨。</p>

<p><img src="/myimg/java/pigment.png" width="400" alt="" /></p>

<p><strong>pretty-json :</strong> Json 格式化。Packages->PrettyJson->Prettify</p>

<p><strong>react-snippets :</strong> React代码块快捷输入
<img src="/myimg/java/react-snippets.png" width="700" alt="" /></p>

<p><strong>sort-lines :</strong>把列按字母排序。功能键 f5(电脑，设置，键盘里要开启功能选项) 或者 Edit->Lines->Sort</p>

<p><strong>tool-bar :</strong>上面显示工具栏，ctrl-alt-t 开/关
<img src="/myimg/java/tool-bar.png" width="500" alt="" /></p>

<p>安装后的插件包不在Atom应用文件夹里，在 <code>/Users/用户名/.atom/packages/</code> 文件夹里。且 <code>.atom</code> 文件夹默认是隐藏的。在命令窗口输入显示文件夹命令。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//显示隐藏文件
</span><span class='line'>defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder
</span><span class='line'>//隐藏文件
</span><span class='line'>defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder</span></code></pre></td></tr></table></div></figure>


<p><img src="/myimg/java/packages.png" width="300" alt="" /></p>

<h4>包的默认值修改</h4>

<p>可以直接点击<code>View Code</code>打开包的代码修改。也可以像上面先显示文件夹，找到对应的包，然后修改里面的默认配置。在Settings -> Open Config Folder 也可以打开所有插件包的配置。
<img src="/myimg/java/package_change.png" width="700" alt="" /></p>

<h4>快捷键</h4>

<p>ctrl-space : 补全提示 (Mac要把设置->键盘->快捷键->Spotlight 里对应的快捷键取消掉! 不然电脑的优先级更高)</p>

<p>ctrl-alt-b : atom-beautify插件 代码格式化，为什么JSX格式化后有点乱&hellip;</p>

<p>cmd-shift-p : 打开快捷面板</p>

<p>cmd-f : 文件里搜索</p>

<p>cmd-shift-f : 项目里搜索</p>

<p>cmd-alt-[ : 折叠代码</p>

<p>cmd-alt-] : 展开代码</p>

<p>cmd-alt-shift-{ : 折叠所有代码</p>

<p>cmd-alt-shift-} : 展开所有代码</p>

<p>ctrl-[ : 左移动</p>

<p>ctrl-] : 右移动</p>

<p>ctrl-g : 跳转到某行</p>

<p>cmd-\ : 左边目录显示或隐藏</p>

<p>cmd-shift-o : 打开文件夹</p>

<p>cmd-b : 在打开的文件间切换</p>

<p>cmd-delete : 删除光标左边的</p>

<p>ctrl-shift-l : 删除一整行</p>

<p>ctrl-shift-&ldquo;+&rdquo; : 增大字体</p>

<p>ctrl-shift-&ldquo;-&rdquo; : 缩小字体</p>

<p><a href="https://github.com/kompasim/atom-plugins">[92款插件推荐]</a></p>

<p><strong>嗯，还是WebStorm好用！！提示更智能也更多东西可以跳转查看，Atom没跳两下就跳不了了&hellip;</strong></p>
</div>
  
  


      | <a href="/blog/2016/11/24/atom-edit/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/18/struts-spring-mybatis/">Struts + Spring + MyBatis</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-18T09:22:51+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>9:22 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>基本信息：</h4>

<p><code>Mac OS 10.11</code>, <code>eclipse neon</code>, <code>jdk1.8</code>, <code>tomcat7</code>, <code>struts2.5.5</code>, <code>spring4.3.4</code>, <code>mybatis3.4.1</code>,<code>mybatis-spring1.3</code>,<code>mysql数据库</code></p>

<h4>结构简介：</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>用struts2的配置文件来控制方法的调用和页面的跳转，
</span><span class='line'>jps和Action通过strtus2标签方式或者EL表达式传值取值。
</span><span class='line'>Action负责业务逻辑处理，Action调用Service接口，Service接口注入某个Service的实现，
</span><span class='line'>在Service的实现里调用Dao来处理数据库。
</span><span class='line'>而Dao是用Mybatis通过对应的xml映射文件来关联的,
</span><span class='line'>且Action里的Service实现注入,Service实现类里的Dao注入,Dao的Section注入，
</span><span class='line'>都是通过Spring配置文件实现的。</span></code></pre></td></tr></table></div></figure>


<h4>截图:</h4>

<p><img src="/myimg/java/ssm_index.png" alt="" />
<img src="/myimg/java/ssm_list.png" alt="" />
<img src="/myimg/java/ssm_json.png" alt="" />
<img src="/myimg/java/ssm.png" alt="" /></p>

<p><a href="/mysrc/java/SSM.zip">下载</a></p>
</div>
  
  


      | <a href="/blog/2016/11/18/struts-spring-mybatis/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/17/springmvc-hibernate-jian/">SpringMVC + Spring + Hibernate</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-17T19:34:43+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>7:34 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>基本信息：</h4>

<p><code>Mac OS 10.11</code>, <code>eclipse neon</code>, <code>jdk1.8</code>, <code>tomcat7</code>, <code>spring4.3.4</code>, <code>Hibernate5.2.4</code>,<code>jackson2.5</code>,<code>mysql数据库</code></p>

<h4>截图:</h4>

<p><img src="/myimg/java/ssh_frame.png" alt="" />
<img src="/myimg/java/ssh_pack.png" alt="" /></p>

<h4>Controller从JSP取值</h4>

<pre><code>//1.使用HttpServletRequest获取
public String addUser(HttpServletRequest request) {
    String name = request.getParameter("name");
    String pass = request.getParameter("password");
    return "/addUser";
}
//2.使用注解
public String addUser(@RequestParam("name") String name,@RequestParam("password") String password) {
    System.out.println(name+password);
    return "/addUser";
}
//3.自动注入Entity属性
public String addUser(User user) {
    System.out.println(user.getName() + user.getPassword());
    return "/addUser";
}
</code></pre>

<h4>Controller传值给JSP</h4>

<pre><code>//1.使用HttpServletRequest 然后setAttribute()，就和Servlet中一样
public String getAllUser(HttpServletRequest request) {
    request.setAttribute("userList", userService.getAllUser());
    return "/index";
}
//2.使用Spring的ModelMap `public class ModelMap extends LinkedHashMap&lt;String, Object&gt;`，ModelMap数据会利用HttpServletRequest的Attribute传值
public String getAllUser(ModelMap modelMap) {
    modelMap.put("userList", userService.getAllUser());
    return "/index";
}
//3.HttpServletReequest的getSession()  
public String getAllUser(HttpServletRequest request) {
    HttpSession session = request.getSession();
    session.setAttribute("userList", userService.getAllUser());
    return "/index";
}
</code></pre>

<p><a href="/mysrc/java/SSH.zip">下载</a></p>
</div>
  
  


      | <a href="/blog/2016/11/17/springmvc-hibernate-jian/#comments">Comments</a>


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/16/hibernate/">Hibernate 的使用</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-16T09:20:12+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>9:20 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>可以认为MyBatis是半自动化，而Hibernate是全自动化(也可半自动)。MyBatis是面向表和列的SQL查询，而Hibernate是用面向对象和对象属性的 HQL查询。 HQL 查询被 Hibernate 翻译为传统的 SQL 查询从而对数据库进行操作。尽管Hibernate可以直接使用本地 SQL 语句，但还是尽可能的使用 HQL 语句，以避免数据库移植产生的麻烦。在 HQL 中一些关键字比如 SELECT ，FROM 和 WHERE 等，是不区分大小写的，但对象名和属性名是区分大小写的。Hibernate也可以用注解方式来进行对象和表的关系映射，类似于<a href="http://ormlite.com/">OrmLit</a>这样。</p>

<p><img src="/myimg/java/hibernate_frame.png" alt="" /></p>

<p>和Mybatis 很像，都是加载配置文件得到SessionFactory, 然后通过SessionFactory获取 Session,然后用Session进行HQL操作。</p>

<p>Hibernate(5.2.4)配置文件</p>

<pre><code>&lt;?xml version="1.0" encoding="GBK"?&gt;  
&lt;!DOCTYPE hibernate-configuration PUBLIC  
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"  
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;
&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;
        &lt;property name="connection.url"&gt;jdbc:mysql://localhost:8889/java_db&lt;/property&gt;
        &lt;property name="connection.username"&gt;root&lt;/property&gt;
        &lt;property name="connection.password"&gt;root&lt;/property&gt;
        &lt;!-- 指定连接池里最大连接数 --&gt;
        &lt;property name="hibernate.c3p0.max_size"&gt;50&lt;/property&gt;
        &lt;!-- 指定连接池里最小连接数 --&gt;
        &lt;property name="hibernate.c3p0.min_size"&gt;5&lt;/property&gt;
        &lt;!-- 指定连接池里连接的超时时长 --&gt;
        &lt;property name="hibernate.c3p0.timeout"&gt;3000&lt;/property&gt;
        &lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt;
        &lt;property name="hibernate.c3p0.max_statements"&gt;100&lt;/property&gt;
        &lt;property name="hibernate.c3p0.idle_test_perxiod"&gt;3000&lt;/property&gt;
        &lt;property name="hibernate.c3p0.acquire_increment"&gt;2&lt;/property&gt;
        &lt;property name="hibernate.c3p0.validate"&gt;true&lt;/property&gt;
        &lt;!-- 指定数据库方言 --&gt;
        &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt;
        &lt;!-- 根据需要自动创建数据表 --&gt;
        &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;
        &lt;!-- 显示Hibernate持久化操作所生成的SQL --&gt;
        &lt;property name="show_sql"&gt;true&lt;/property&gt;
        &lt;!-- 将SQL脚本进行格式化后再输出 --&gt;
        &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;

        &lt;!-- 下面罗列所有的映射文件 --&gt;
        &lt;mapping resource="com/sgm/config/user.xml" /&gt;

    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;
</code></pre>

<p>对象到表的映射文件</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; 
&lt;hibernate-mapping package="com.sgm.bean"&gt;
   &lt;class name="User" table="user"&gt;
      &lt;id name="id" type="int" column="id"&gt;
         &lt;generator class="native"/&gt;
      &lt;/id&gt;
      &lt;property name="name" column="name" type="string"/&gt;
      &lt;property name="password" column="password" type="string"/&gt;
   &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>基本使用</p>

<pre><code>public class Main {
    private static SessionFactory factory;
    static{
        try {
            Configuration config = new Configuration().configure("com/sgm/config/hibernate.xml");
            factory = config.buildSessionFactory();
        } catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
        }
    }

@SuppressWarnings("unchecked")
public static void main(String[] args) {
    Session session = factory.openSession();
    Transaction transaction = null;
    try {
        transaction = session.beginTransaction();
        //数据库处理

        transaction.commit();
    } catch (Exception e) {
        if (transaction != null)
            transaction.rollback();
        e.printStackTrace();
    } finally {
        session.close();
    }
  }
}
</code></pre>

<p><img src="/myimg/java/hibernate_zsg.png" alt="" /></p>

<p>一般情况下，用不带entityName参数的方法就可以了。带entityName的是hibernate在探索不使用pojo类进行O/R，不建议使用。</p>

<h4>查询</h4>

<pre><code>//from后面是对象！不是表名！对象和表在mapper文件里关联好了。hql面向的是对象，不是表！
String hql = "FROM User as u where u.id &gt;= 17 ";
Query&lt;User&gt; query = session.createQuery(hql);
List&lt;User&gt; list = query.getResultList();

//用setParameter设置查询参数，setFirstResult和setMaxResults可用于分页
String hql="from User as u where u.name=? and u.password = :password ORDER BY u.id DESC";
Query&lt;User&gt; query=session.createQuery(hql);
query.setParameter(0, "andy");
query.setParameter("password", "123");
query.setFirstResult(1);//从结果集的那一条开始(包括这一条)
query.setMaxResults(2);//最多几条
List&lt;User&gt; list=query.getResultList();

//query也可以用于批量修改和删除 
String hql = "UPDATE User set name = :name WHERE id &gt;= :id";
//String hql = "DELETE from User WHERE name = :name and id &gt;= :id";
Query&lt;User&gt; query = session.createQuery(hql);
query.setParameter("name", "andy hello");
query.setParameter("id", 19);
int result = query.executeUpdate();
System.out.println("处理了几条数据: " + result);
</code></pre>

<h4><a href="https://docs.jboss.org/hibernate/entitymanager/3.5/reference/en/html/querycriteria.html">CriteriaQuery</a> <a href="https://github.com/treehouse/giflib-hibernate/commit/f97a2828a466e849d8ae84884b5dce60a66cf412">废弃更新日志</a></h4>

<p>注意新的创建方式引用的包是 <code>import javax.persistence.criteria.CriteriaQuery</code>,而不是<code>import org.hibernate.criterion.CriteriaQuery</code>!!!</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//旧的已被废弃
</span><span class='line'>session.createCriteria(User.class) 的创建方式已经被废弃
</span><span class='line'>//改为这样,因为5.2.4的session已经继承了EntityManager，所以可以直接getCriteriaBuilder()。
</span><span class='line'>CriteriaBuilder cb = session.getCriteriaBuilder();
</span><span class='line'>CriteriaQuery&lt;User&gt; query = cb.createQuery(User.class);
</span><span class='line'>Root&lt;User&gt; user = query.from(User.class);
</span><span class='line'>query.select(user).where(cb.equal(user.get("name"), "andy"));
</span><span class='line'>List&lt;User&gt; list = session.createQuery(query).getResultList();</span></code></pre></td></tr></table></div></figure>


<h4>原生SQL</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>String sql = "select * from user where id = :tmpId";
</span><span class='line'>NativeQuery&lt;User&gt; nativeQuery = session.createNativeQuery(sql,User.class);
</span><span class='line'>nativeQuery.setParameter("tmpId", 19);
</span><span class='line'>nativeQuery.setFirstResult(1);
</span><span class='line'>nativeQuery.setMaxResults(2);
</span><span class='line'>List&lt;User&gt; list = nativeQuery.getResultList();
</span><span class='line'>//nativeQuery.executeUpdate(); 修改或者删除</span></code></pre></td></tr></table></div></figure>


<h4>one-to-many / many-to-one</h4>

<p>举个栗子： <code>User(单方)----Book(多方)</code>,一个user有多个book, 一个book只属于一个user。</p>

<pre><code>public class User {
    public int id;
    public String name;
    private Set&lt;Book&gt; books = new HashSet&lt;Book&gt;();
    //下面 getter setter
}

public class Book {
    public int id;
    public String name;
    public User user;
    //下面 getter setter
}
</code></pre>

<p>User mapper</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;
&lt;hibernate-mapping package="com.sgm.bean"&gt;
    &lt;class name="User" table="user"&gt;
        &lt;id name="id" type="int" column="id"&gt;
            &lt;generator class="native" /&gt;
        &lt;/id&gt;
        &lt;property name="name" column="name" type="string" /&gt;

        &lt;set name="books" inverse="true" cascade="all"&gt;
            &lt;key column="userId"&gt;&lt;/key&gt;
            &lt;one-to-many class="com.sgm.bean.Book" /&gt;
        &lt;/set&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>Book mapper</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE hibernate-mapping PUBLIC 
 "-//Hibernate/Hibernate Mapping DTD//EN"
 "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;
&lt;hibernate-mapping package="com.sgm.bean"&gt;
    &lt;class name="Book" table="book"&gt;
        &lt;id name="id" type="int" column="id"&gt;
            &lt;generator class="native" /&gt;
        &lt;/id&gt;
        &lt;property name="name" column="name" type="string" /&gt;

        &lt;many-to-one name="user" class="com.sgm.bean.User"&gt;
            &lt;column name="userId"&gt;&lt;/column&gt;
        &lt;/many-to-one&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre>

<p>测试</p>

<pre><code>public class Main {
    private static SessionFactory factory;
    static {
        try {
            Configuration config = new Configuration().configure("com/sgm/config/hibernate.xml");
            factory = config.buildSessionFactory();
        } catch (Throwable ex) {
            throw new ExceptionInInitializerError(ex);
        }
    }

    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        Session session = factory.openSession();
        Transaction transaction = null;
        try {
            transaction = session.beginTransaction();
            // do some work
            User user = new User();
            user.setName("andy");

            Book book1 = new Book();
            book1.setName("哈利波特");
            book1.setUser(user);

            Book book2 = new Book();
            book2.setName("功夫之王");
            book2.setUser(user);

            user.getBooks().add(book1);
            user.getBooks().add(book2);

            session.save(user);

            transaction.commit();
        } catch (Exception e) {
            if (transaction != null)
                transaction.rollback();
            e.printStackTrace();
        } finally {
            session.close();
        }
    }
}
</code></pre>

<p><img src="/myimg/java/hibernate_om.png" alt="" /></p>

<h4>中文乱码</h4>

<p>用Hibernate 插入中文到MySQL数据库时，即使MySQL数据库设置编码 <code>Character set = utf-8</code> 还是乱码。要改Hibernate 的配置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;property name="connection.url"&gt;jdbc:mysql://localhost:8889/java_db&lt;/property&gt;
</span><span class='line'>//改为
</span><span class='line'>&lt;property name="connection.url"&gt;&lt;![CDATA[jdbc:mysql://localhost:8889/java_db?useUnicode=true&characterEncoding=utf8]]&gt;&lt;/property&gt;</span></code></pre></td></tr></table></div></figure>



</div>
  
  


      | <a href="/blog/2016/11/16/hibernate/#comments">Comments</a>


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/12/01/react-navigator/">React Native Navigator</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/30/react-native-life/">React Native 组件生命周期</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/30/css-flex-box/">Flexbox 布局</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/29/rn-style/">React Native 样式属性</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/28/react-native-run-bug/">React Native 问题汇总</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/android/'>android (9)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (10)</a></li>
<li class='category'><a href='/blog/categories/other/'>other (8)</a></li>
<li class='category'><a href='/blog/categories/react/'>react (7)</a></li>

  </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - guimingsu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
